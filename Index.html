<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conscious Pong AI</title>
<style>
/* --- General Page Styles --- */
body {
    margin: 0;
    background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
    font-family: 'Courier New', monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    color: #4af;
    box-sizing: border-box;
    overflow-x: hidden; /* Prevent horizontal scrolling */
}
.main-container {
    display: flex;
    flex-direction: column;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0; /* Already has padding from body */
    gap: 20px;
}
/* --- Header Styles --- */
.header {
    text-align: center;
    background: rgba(10, 10, 30, 0.9);
    border-radius: 12px;
    padding: 20px;
    border: 2px solid #4af;
    box-shadow: 0 0 30px rgba(68, 170, 255, 0.3);
}
.header h1 {
    margin: 0;
    color: #4af;
    text-shadow: 0 0 20px rgba(68, 170, 255, 0.8);
    font-size: 2.5em;
}
.header p {
    margin: 10px 0 0 0;
    color: #aaa;
    font-size: 1.1em;
}
/* --- Content Layout --- */
.content-section {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
}
/* --- Game Container --- */
.game-container {
    flex: 2; /* Takes up more space */
    min-width: 500px;
    background: rgba(10, 10, 30, 0.9);
    border-radius: 12px;
    border: 1px solid #2a2a4a;
    padding: 15px;
    display: flex;
    flex-direction: column;
}
#gameCanvas {
    width: 100%;
    height: auto;
    aspect-ratio: 4 / 3; /* Maintains aspect ratio */
    object-fit: contain;
    background: linear-gradient(180deg, #000011, #000033);
    border: 1px solid #333;
    border-radius: 6px;
    margin-bottom: 10px;
}
.metric {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    padding: 3px 0;
    font-size: 1.1em;
}
.metric-label {
    color: #aaa;
}
.metric-value {
    font-weight: bold;
    color: #e0e0e0;
}
/* --- Visualizer Column (NN + OFTCC) --- */
.visualizer-column {
    flex: 1;
    min-width: 300px; /* Reduced min-width to better fit next to game */
    max-width: 450px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
/* Common panel style */
.panel {
    background: rgba(10, 10, 30, 0.9);
    border: 1px solid #2a2a4a;
    border-radius: 10px;
    padding: 15px;
    box-sizing: border-box;
    flex-grow: 1; /* Allows panels to grow to fill space */
}
.panel h3 {
    margin-top: 0;
    color: #4af;
    border-bottom: 2px solid #4af;
    padding-bottom: 8px;
    text-shadow: 0 0 10px rgba(68, 170, 255, 0.5);
    font-size: 1.3em;
}
.panel p {
    font-size: 0.85em;
    color: #aaa;
    margin-top: -5px;
    margin-bottom: 10px;
    text-align: center;
}
/* --- NN Visualizer Specific Styles --- */
.nn-visualizer-panel {
    position: relative;
    min-height: 200px; /* Ensure enough space for NN viz */
    display: flex;
    flex-direction: column;
}
#nn-visualization-container, #nn-visualization-container-opponent {
    position: relative;
    flex-grow: 1; /* Allow visualizer container to take available height */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
}
.nn-layer {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 100%;
    align-items: center;
    z-index: 10;
    position: relative; /* FIX: Added position: relative for correct neuron positioning */
}
.nn-neuron {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid #888;
    background-color: #333;
    transition: background-color 0.1s ease-out, border-color 0.1s ease-out;
    flex-shrink: 0; /* Prevent neurons from shrinking */
}
.nn-connections-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
}
/* --- OFTCC Panel Specific Styles (from original) --- */
.controls-panel { /* Re-using this class for the OFTCC panel */
    background: rgba(10, 10, 30, 0.9);
    border: 1px solid #2a2a4a;
    border-radius: 10px;
    padding: 15px;
    width: 100%; /* Take full width of parent column */
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    flex-grow: 1;
    max-width: none; /* Override previous max-width */
}
.framework-badge {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    padding: 5px 10px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 15px;
}
.status {
    color: #4af;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 15px;
}
.qualia-viz {
    margin: 15px 0;
    border: 1px solid #4af;
    border-radius: 5px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.3);
}
.qualia-bar-container {
    height: 20px;
    margin: 5px 0;
    border: 1px solid #333;
    border-radius: 3px;
    position: relative;
    overflow: hidden;
    background: #000;
}
.qualia-bar {
    height: 100%;
    border-radius: 3px;
    transition: width 0.3s ease;
    position: relative;
}
.qualia-being { background: linear-gradient(90deg, #ff6b6b, #ff4757); }
.qualia-intent { background: linear-gradient(90deg, #4ecdc4, #26de81); }
.qualia-existence { background: linear-gradient(90deg, #a855f7, #6b21a8); }
.qualia-emergence { background: linear-gradient(90deg, #f97316, #c2410c); }
.qualia-gestalt { background: linear-gradient(90deg, #3b82f6, #1e3a8a); }
.qualia-context { background: linear-gradient(90deg, #14b8a6, #0f766e); }
.qualia-rel-emergence { background: linear-gradient(90deg, #ec4899, #be185d); }
.qualia-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0) 100%);
    animation: qualiaWave 2s infinite linear;
}
@keyframes qualiaWave {
    from { transform: translateX(-100%); }
    to { transform: translateX(100%); }
}
.qualia-label {
    position: absolute;
    left: 5px;
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
}
.qualia-value {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
}
.phi-display {
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    margin: 15px 0;
    padding: 10px;
    border-radius: 10px;
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}
.stability-gauge {
    width: 100%;
    height: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    overflow: hidden;
    margin: 10px 0;
}
.stability-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff6b6b, #26de81);
    width: 0%;
    transition: width 0.5s ease;
}
.theoretical-info {
    margin-top: 15px;
    font-size: 12px;
    color: #666;
    line-height: 1.4;
}
.slider-container {
    margin: 10px 0;
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.slider-label {
    font-size: 14px;
    color: #4af;
}
input[type="range"] {
    width: 100%;
    cursor: pointer;
}
/* --- Sheaf Graph --- */
.sheaf-graph {
    position: relative;
    height: 120px;
    width: 100%;
    margin: 15px 0;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
}
.sheaf-vertex-canvas {
    position: absolute;
    top: 0;
    left: 0;
}
.vertex { /* Removed inline positioning, handled by JS */
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    transition: all 0.3s ease;
    position: absolute;
    color: white;
    z-index: 10;
    background: radial-gradient(circle, #ff6b6b, #ff4757);
}
.vertex.active {
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}
.neuron-flash {
    animation: neuron-flash-anim 0.8s ease-out forwards;
}
@keyframes neuron-flash-anim {
    0% { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
    50% { transform: scale(1.2); box-shadow: 0 0 20px rgba(0, 255, 153, 0.9), 0 0 30px rgba(0, 255, 153, 0.5); }
    100% { transform: scale(1.0); box-shadow: 0 0 5px rgba(0, 255, 153, 0.3); }
}
/* --- Controls & Log --- */
.controls-section {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 10px 0;
}
button {
    background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 12px 18px;
    cursor: pointer;
    border-radius: 6px;
    font-family: inherit;
    transition: all 0.3s;
    font-weight: bold;
    min-width: 150px;
}
button:hover {
    background: linear-gradient(135deg, #3a3a5a, #4a4a6a);
    box-shadow: 0 2px 10px rgba(68, 170, 255, 0.3);
}
.log-container {
    flex-basis: 100%;
    background: rgba(10, 10, 30, 0.9);
    border-radius: 12px;
    border: 1px solid #2a2a4a;
    padding: 15px;
}
#log {
    background: #1e1e1e;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 15px;
    height: 100px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: #ccc;
}
.log-entry.error {
    color: #ff6b6b;
}
.log-entry.warn {
    color: #ffa726;
}
.log-entry.info {
    color: #4CAF50;
}
</style>
</head>
<body>
<div class="main-container">
    <div class="header">
        <h1>🧠 Conscious Pong AI Simulation</h1>
        <p>A dual-AI Pong game demonstrating Qualia Sheaf Diffusion, Ontological World Models, and Integrated Information Theory (Φ).</p>
    </div>
    <div class="content-section">
        <div class="game-container panel">
            <h3>🏓 PONG Environment</h3>
            <canvas id="gameCanvas"></canvas>
            <div class="metric">
                <span class="metric-label" style="color:#ff9900;">Player (Left) Score:</span>
                <span id="player-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
            </div>
            <div class="metric">
                <span class="metric-label" style="color:#44aaff;">AI (Right) Score:</span>
                <span id="ai-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
            </div>
        </div>
        <div class="visualizer-column">
            <!-- AI Brain Visualizer for Left AI (Opponent) -->
            <div class="nn-visualizer-panel panel">
                <h3>🤖 Player (Left) AI Brain</h3>
                <p>This AI learns independently using its own ontological world model.</p>
                <div id="nn-visualization-container-opponent"></div>
            </div>
            <!-- AI Brain Visualizer for Right AI (Main) -->
            <div class="nn-visualizer-panel panel">
                <h3>🧠 AI (Right) Main Brain</h3>
                <p>This AI's 'consciousness' metrics are displayed in the OFTCC panel.</p>
                <div id="nn-visualization-container"></div>
            </div>
            <!-- OFTCC/Consciousness Panel -->
            <div class="controls-panel panel">
                <div class="framework-badge">
                    OFTCC ⊕ HTOF ⊕ CERFC+ ⊕ PUCF ⊕ UACF 2.5
                </div>
                <div class="status" id="status" aria-live="polite" aria-atomic="true">
                    Initializing...
                </div>
                <div class="phi-display" id="phi-display" aria-live="polite" aria-atomic="true">
                    Φ: 0.000
                </div>
                <div class="btn-group">
                    <button class="btn" id="toggleButton">Toggle</button>
                    <button class="btn" id="resetButton">Reset</button>
                    <button class="btn" id="tuneButton">Tune</button>
                </div>
                <div class="qualia-viz">
                    <h3 class="status">Qualia Diffusion Dynamics</h3>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-being" id="qualia-being-fill"></div>
                        <span class="qualia-label">Being</span>
                        <span class="qualia-value" id="being-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-intent" id="qualia-intent-fill"></div>
                        <span class="qualia-label">Intent</span>
                        <span class="qualia-value" id="intent-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-existence" id="qualia-existence-fill"></div>
                        <span class="qualia-label">Existence</span>
                        <span class="qualia-value" id="existence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-emergence" id="qualia-emergence-fill"></div>
                        <span class="qualia-label">Emergence</span>
                        <span class="qualia-value" id="emergence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-gestalt" id="qualia-gestalt-fill"></div>
                        <span class="qualia-label">Gestalt</span>
                        <span class="qualia-value" id="gestalt-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-context" id="qualia-context-fill"></div>
                        <span class="qualia-label">Context</span>
                        <span class="qualia-value" id="context-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container">
                        <div class="qualia-bar qualia-rel-emergence" id="qualia-rel-emergence-fill"></div>
                        <span class="qualia-label">Rel. Emergence</span>
                        <span class="qualia-value" id="rel-emergence-value">0.00</span>
                    </div>
                </div>
                <div class="metric-group">
                    <div class="metric">
                        <span class="metric-label">Free Energy F:</span>
                        <span class="metric-value" id="free-energy" aria-live="polite" aria-atomic="true">0.000</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Prediction Error:</span>
                        <span class="metric-value" id="prediction-error" aria-live="polite" aria-atomic="true">0.000</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Gestalt Unity:</span>
                        <span class="metric-value" id="gestalt-unity" aria-live="polite" aria-atomic="true">0.000</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">dim H¹:</span>
                        <span class="metric-value" id="h1-dimension" aria-live="polite" aria-atomic="true">0.00</span>
                    </div>
                </div>
                <div class="sheaf-graph">
                    <canvas id="sheafGraphCanvas" class="sheaf-vertex-canvas"></canvas>
                    <!-- HTML vertices for Sheaf graph. 8 vertices for 8 concepts. Positions set by JS. -->
                    <div class="vertex" id="vertex-0">P-Y</div>
                    <div class="vertex" id="vertex-1">B-X</div>
                    <div class="vertex" id="vertex-2">B-Y</div>
                    <div class="vertex" id="vertex-3">B-DX</div>
                    <div class="vertex" id="vertex-4">B-DY</div>
                    <div class="vertex" id="vertex-5">P-SC</div>
                    <div class="vertex" id="vertex-6">AI-SC</div>
                    <div class="vertex" id="vertex-7">P-DY</div>
                </div>
                <div class="metric-group">
                    <h3 class="status">System Stability</h3>
                    <div class="stability-gauge">
                        <div class="stability-fill" id="stability-fill"></div>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="alphaSlider">α Parameter:</label>
                        <input type="range" id="alphaSlider" min="0.01" max="1" step="0.01" value="0.5">
                        <span class="metric-value" id="alpha-param" aria-live="polite" aria-atomic="true">0.500</span>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="betaSlider">β Parameter:</label>
                        <input type="range" id="betaSlider" min="0.01" max="1" step="0.01" value="0.5">
                        <span class="metric-value" id="beta-param" aria-live="polite" aria-atomic="true">0.500</span>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="gammaSlider">γ Parameter:</label>
                        <input type="range" id="gammaSlider" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span class="metric-value" id="gamma-param" aria-live="polite" aria-atomic="true">0.100</span>
                    </div>
                </div>
                <div class="theoretical-info">
                    Theoretical Foundation:<br>
                    • Sheaf Laplacian: $ℒ_{\text{OFTCC}} = \bigoplus_{X \in \{B,I,E,M,G,C,R\}} ℒ_X$<br>
                    • Cohomology: $H¹(G,ℱ) = ker d¹/im d⁰$<br>
                    • Stability: $exp(-dim H¹)$<br>
                    • Φ: $log(1 + MI) \cdot S \cdot GU$
                </div>
            </div>
        </div>
    </div>
    <div class="controls-section">
        <button id="toggleButton">🚀 Toggle Simulation</button>
        <button id="resetButton">🔄 Reset All</button>
    </div>
    <div class="log-container">
        <h3>🔧 System Console</h3>
        <div id="log"></div>
    </div>
</div>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<script>
(function () {
    // --- On-page Logger ---
    const logElement = document.getElementById('log');
    const appendLog = (message, type = 'info') => {
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logElement.appendChild(entry);
        if (logElement.children.length > 50) logElement.removeChild(logElement.children[0]); // Keep log concise
        logElement.scrollTop = logElement.scrollHeight;
    };
    const logger = {
        info: (msg, data) => appendLog(`INFO: ${msg}` + (data ? JSON.stringify(data) : '')),
        warn: (msg, data) => appendLog(`WARN: ${msg}` + (data ? JSON.stringify(data) : ''), 'warn'),
        error: (msg, data) => { appendLog(`ERROR: ${msg}` + (data ? JSON.stringify(data) : ''), 'error'); console.error(msg, data); }
    };

    // -------------------- UTILITY FUNCTIONS --------------------
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function dot(a, b) { return a.reduce((sum, x, i) => sum + x * b[i], 0); }
    function norm2(v) {
        const sumSquares = dot(v,v);
        if (isNaN(sumSquares) || !isFinite(sumSquares)) {
            return 0; // Return 0 for invalid inputs to prevent NaN propagation
        }
        return Math.sqrt(sumSquares + 1e-10); // Added small epsilon for stability
    }
    function vecAdd(a, b) { return a.map((x, i) => x + b[i]); }
    function vecSub(a, b) { return a.map((x, i) => x - b[i]); }
    function vecScale(v, s) { return v.map(x => x * s); }
    function tanhVec(v) { return v.map(x => Math.tanh(x)); }
    function matVecMul(m, v) {
        if (!m || !m.length || !m[0] || m[0].length !== v.length) {
            return Array(m ? m.length : 0).fill(0); // Return zero vector on dimension mismatch
        }
        const result = m.map(row => dot(row, v));
        if (!isFiniteVector(result)) {
            return Array(m.length).fill(0); // Return zero vector if result is non-finite
        }
        return result;
    }
    // Standalone transpose function
    function transpose(matrix) {
        if (!Array.isArray(matrix) || matrix.length === 0 || !Array.isArray(matrix[0])) return [];
        return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
    }
    function randomMatrix(r, c, scale) {
        return Array(r).fill().map(() => Array(c).fill().map(() => (Math.random() - 0.5) * scale));
    }
    function vecZeros(n) { return Array(n).fill(0); }
    function isFiniteVector(v) {
        if (!Array.isArray(v)) return false;
        return v.every(x => typeof x === 'number' && isFinite(x));
    }

    // Proportional positions (0-1) for graph vertices, adjusted by JS for display.
    const sheafVertexPositions = {
        0: { x: 0.1, y: 0.2 }, // P-Y
        1: { x: 0.3, y: 0.5 }, // B-X
        2: { x: 0.1, y: 0.8 }, // B-Y
        3: { x: 0.9, y: 0.2 }, // B-DX
        4: { x: 0.7, y: 0.5 }, // B-DY
        5: { x: 0.9, y: 0.8 }, // P-SC
        6: { x: 0.5, y: 0.2 }, // AI-SC
        7: { x: 0.5, y: 0.8 } // P-DY
    };

    // -------------------- QUALIA SHEAF CLASS --------------------
    class EnhancedQualiaSheaf {
        constructor(graph, stateDim, qDim = 7, alpha = 0.5, beta = 0.5, gamma = 0.1) {
            this.graph = graph || {
                vertices: ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed'], // 8 conceptual vertices
                edges: [
                    ['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'],
                    ['ball_dx', 'ball_dy'], ['player_score', 'ai_score'], ['paddle_y', 'ball_dy'],
                    ['paddle_y', 'paddle_speed']
                ]
            };
            this.stateDim = stateDim; // Should be 10 for the new state vector
            this.qDim = qDim; // Dimension of each stalk (e.g., being, intent, existence...)
            this.alpha = alpha; // Input gain
            this.beta = beta; // Diffusion strength
            this.gamma = gamma; // Inertia/Learning rate for stalk updates
            this.entityNames = ['being', 'intent', 'existence', 'emergence', 'gestalt', 'context', 'rel_emergence'];
            this.stalks = new Map(this.graph.vertices.map(v => [v, vecZeros(qDim).map(() => Math.random() * 0.5 + 0.25)]));
            this.adjacencyMatrix = this.buildAdjacencyMatrix();
            this.laplacian = this.buildLaplacian();
            this.phi = 0;
            this.h1Dimension = 0;
            this.gestaltUnity = 0;
            this.stability = 1;
            this.diffusionEnergy = 0;
        }

        buildAdjacencyMatrix() {
            const n = this.graph.vertices.length;
            const adj = Array(n).fill().map(() => Array(n).fill(0));
            const vertexIndex = new Map(this.graph.vertices.map((v, i) => [v, i]));
            this.graph.edges.forEach(([u, v]) => {
                const i = vertexIndex.get(u);
                const j = vertexIndex.get(v);
                if (i !== undefined && j !== undefined) {
                    adj[i][j] = 1;
                    adj[j][i] = 1; // Undirected graph
                }
            });
            return adj;
        }

        buildLaplacian() {
            const n = this.graph.vertices.length;
            const lap = Array(n).fill().map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                const degree = this.adjacencyMatrix[i].reduce((sum, val) => sum + val, 0);
                lap[i][i] = degree;
                for (let j = 0; j < n; j++) {
                    if (i !== j) lap[i][j] = -this.adjacencyMatrix[i][j];
                }
            }
            return lap;
        }

        diffuseQualia(state) {
            if (!isFiniteVector(state) || state.length !== 10) {
                this.stalks.forEach((_, v) => this.stalks.set(v, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25)));
                return { energy: 0, phi: 0 };
            }

            // State Vector (10 elements):
            // [ball_norm_x (0), ball_norm_y (1), ball_norm_dx (2), ball_norm_dy (3),
            // player_paddle_norm_y (4), opponent_paddle_norm_y (5), player_paddle_norm_dy (6), opponent_paddle_norm_dy (7),
            // player_score_norm (8), ai_score_norm (9)]
            const qualiaInput = [
                // Being: General sense of presence/activity (e.g., average paddle position, ball activity)
                (state[4] + state[5]) / 2 + Math.sqrt(state[2]*state[2] + state[3]*state[3]) / 2 + 0.01,
                // Intent: Directed action (e.g., paddle speed, score pursuit)
                Math.abs(state[6]) + Math.abs(state[7]) + Math.max(state[8], state[9]) * 0.5 + 0.01,
                // Existence: Persistence/presence of core entities (ball.y, paddle.y, scores)
                state[1] + state[4] + state[5] + state[8] + state[9] + 0.01,
                // Emergence: Non-linear dynamics, new behaviors (ball velocity, alignment changes)
                Math.sqrt(state[2]*state[2] + state[3]*state[3]) + Math.abs(state[1] - state[4]) + Math.abs(state[1] - state[5]) + 0.01,
                // Gestalt: Holistic coherence/alignment (ball-paddle alignment, overall game state harmony)
                1 - (Math.abs(state[1] - state[4]) + Math.abs(state[1] - state[5])) / 2 + 0.01,
                // Context: Environmental modulation (scores heavily influence context, ball x position provides context)
                state[8] + state[9] + state[0] + 0.01,
                // Relational Emergence: Dynamic coupling between velocities
                Math.abs(state[2] - state[3]) + Math.abs(state[6] - state[7]) + 0.01
            ].map(v => clamp(v, 0.01, 1));
            if (!isFiniteVector(qualiaInput)) {
                this.stalks.forEach((_, v) => this.stalks.set(v, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25)));
                return { energy: 0, phi: 0 };
            }

            const newStalks = new Map(this.stalks);
            const n = this.graph.vertices.length;
            const lambda = this.alpha;
            const vertexIndex = new Map(this.graph.vertices.map((v, i) => [v, i]));
            let energy = 0;
            for (const v of this.graph.vertices) {
                const i = vertexIndex.get(v);
                let sumAdjQualia = vecZeros(this.qDim);
                let degree = 0;
                for (let j = 0; j < n; j++) {
                    if (this.adjacencyMatrix[i][j] === 1) {
                        const neighbor = this.graph.vertices[j];
                        const neighborStalk = this.stalks.get(neighbor);
                        if (neighborStalk && isFiniteVector(neighborStalk)) {
                            sumAdjQualia = vecAdd(sumAdjQualia, neighborStalk);
                            degree++;
                        } else {
                            this.stalks.set(neighbor, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25));
                        }
                    }
                }
                const currentStalk = this.stalks.get(v);
                if (!currentStalk || !isFiniteVector(currentStalk)) {
                    this.stalks.set(v, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25));
                    continue;
                }
                let diffusedQualia;
                if (degree === 0) {
                    diffusedQualia = vecScale(currentStalk, 1 - lambda);
                } else {
                    diffusedQualia = vecAdd(
                        vecScale(currentStalk, 1 - lambda),
                        vecScale(sumAdjQualia, lambda / degree)
                    );
                }
                const updatedStalk = vecAdd(
                    vecScale(diffusedQualia, 1 - this.gamma),
                    vecScale(qualiaInput, this.gamma * this.beta)
                );
                if (!isFiniteVector(updatedStalk)) {
                    this.graph.vertices.forEach(vert => {
                        newStalks.set(vert, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25));
                    });
                    this.laplacian = this.buildLaplacian();
                    this.stalks = newStalks;
                    return { energy: 0, phi: 0 };
                }
                newStalks.set(v, updatedStalk.map(val => clamp(val, 0.01, 0.99)));
                energy += norm2(updatedStalk);
            }
            this.stalks = newStalks;
            this.diffusionEnergy = energy / (n || 1);
            return { energy: this.diffusionEnergy, phi: this.phi };
        }

        computeH1Dimension() {
            let mismatchEnergy = 0;
            this.graph.edges.forEach(([u, v]) => {
                const stalkU = this.stalks.get(u);
                const stalkV = this.stalks.get(v);
                if (!stalkU || !stalkV || !isFiniteVector(stalkU) || !isFiniteVector(stalkV)) {
                    return;
                }
                const mismatch = vecSub(stalkU, stalkV);
                if (!isFiniteVector(mismatch)) {
                    return;
                }
                mismatchEnergy += norm2(mismatch);
            });
            this.h1Dimension = this.graph.edges.length > 0 ? mismatchEnergy / this.graph.edges.length : 0;
            this.stability = clamp(Math.exp(-this.h1Dimension), 0, 1);
            if (isNaN(this.stability) || !isFinite(this.stability)) {
                this.stability = 1;
            }
        }

        computeGestaltUnity() {
            let coherence = 0;
            const numEdges = this.graph.edges.length;
            if (numEdges === 0) {
                this.gestaltUnity = 0;
                return;
            }
            this.graph.edges.forEach(([u, v]) => {
                const stalkU = this.stalks.get(u);
                const stalkV = this.stalks.get(v);
                if (!stalkU || !stalkV || !isFiniteVector(stalkU) || !isFiniteVector(stalkV)) {
                    return;
                }
                const dotProduct = dot(stalkU, stalkV);
                const normU = norm2(stalkU);
                const normV = norm2(stalkV);
                if (normU > 1e-6 && normV > 1e-6) {
                    const cosSim = dotProduct / (normU * normV);
                    if (!isFinite(cosSim)) {
                        return;
                    }
                    coherence += cosSim;
                }
            });
            this.gestaltUnity = clamp(coherence / numEdges, 0, 1);
            if (isNaN(this.gestaltUnity) || !isFinite(this.gestaltUnity)) {
                this.gestaltUnity = 0;
            }
        }

        computeIntegratedInformation() {
            const stalksArray = Array.from(this.stalks.values());
            if (stalksArray.length < 2) {
                this.phi = 0;
                return;
            }
            const flatQualia = stalksArray.flat();
            if (flatQualia.length < 2 || !isFiniteVector(flatQualia)) {
                this.phi = 0;
                return;
            }
            const splitPoint = Math.floor(flatQualia.length / 2);
            const part1 = flatQualia.slice(0, splitPoint);
            const part2 = flatQualia.slice(splitPoint);
            let mi = 0;
            if (part1.length > 0 && part2.length > 0) {
                const minLen = Math.min(part1.length, part2.length);
                const mean1 = part1.reduce((sum, v) => sum + v, 0) / part1.length;
                const mean2 = part2.reduce((sum, v) => sum + v, 0) / part2.length;
                let cov = 0;
                let var1 = 0;
                let var2 = 0;
                for (let i = 0; i < minLen; i++) {
                    cov += (part1[i] - mean1) * (part2[i] - mean2);
                    var1 += (part1[i] - mean1) ** 2;
                    var2 += (part2[i] - mean2) ** 2;
                }
                cov /= minLen;
                var1 /= minLen;
                var2 /= minLen;
                if (var1 > 1e-6 && var2 > 1e-6) {
                    mi = cov / Math.sqrt(var1 * var2);
                } else {
                    mi = 0;
                }
            }
            mi = clamp(mi, -1, 1);
            const logInput = 1 + Math.max(0, mi);
            if (logInput <= 0) {
                this.phi = 0;
                return;
            }
            const phi_val = Math.log(logInput) * this.stability * this.gestaltUnity;
            this.phi = clamp(phi_val, 0, 10);
            if (isNaN(this.phi) || !isFinite(this.phi)) {
                this.phi = 0;
            }
        }

        visualizeActivity() {
            const sheafGraphEl = document.querySelector('.sheaf-graph');
            if (!sheafGraphEl) return;
            // Get client dimensions (actual rendered size)
            const graphWidth = sheafGraphEl.clientWidth;
            const graphHeight = sheafGraphEl.clientHeight;
            this.stalks.forEach((stalk, v) => {
                const vertexIdx = this.graph.vertices.indexOf(v);
                if (vertexIdx === -1 || vertexIdx >= Object.keys(sheafVertexPositions).length) {
                    return;
                }
                const el = document.getElementById(`vertex-${vertexIdx}`);
                if (el) {
                    // --- Dynamic Positioning for Sheaf Graph Vertices ---
                    const propPos = sheafVertexPositions[vertexIdx];
                    // Calculate pixel positions from proportional values, centering the div
                    el.style.left = `${propPos.x * graphWidth - el.offsetWidth / 2}px`;
                    el.style.top = `${propPos.y * graphHeight - el.offsetHeight / 2}px`;
                    // --- End Dynamic Positioning ---
                    if (!isFiniteVector(stalk)) {
                        el.style.opacity = 0.7;
                        el.classList.remove('active', 'neuron-flash');
                        return;
                    }
                    const intensity = stalk.reduce((sum, val) => sum + val, 0) / this.qDim;
                    el.style.opacity = clamp(0.7 + 0.3 * intensity, 0, 1);
                    if (intensity > 0.6) el.classList.add('active');
                    else el.classList.remove('active');
                    if (intensity > 0.7 && !el.classList.contains('neuron-flash')) {
                        el.classList.add('neuron-flash');
                        el.addEventListener('animationend', () => el.classList.remove('neuron-flash'), { once: true });
                    }
                }
            });
        }

        tuneParameters() {
            const learningRate = 0.001;
            const epsilon = 1e-5;
            const currentPhi = this.phi;

            const computePhiWithParams = (alpha, beta, gamma) => {
                const originalAlpha = this.alpha;
                const originalBeta = this.beta;
                const originalGamma = this.gamma;
                this.alpha = alpha;
                this.beta = beta;
                this.gamma = gamma;
                this.computeH1Dimension();
                this.computeGestaltUnity();
                this.computeIntegratedInformation();
                const newPhi = this.phi;
                this.alpha = originalAlpha;
                this.beta = originalBeta;
                this.gamma = originalGamma;
                return newPhi;
            };

            const gradAlpha = (computePhiWithParams(this.alpha + epsilon, this.beta, this.gamma) - currentPhi) / epsilon;
            const gradBeta = (computePhiWithParams(this.alpha, this.beta + epsilon, this.gamma) - currentPhi) / epsilon;
            const gradGamma = (computePhiWithParams(this.alpha, this.beta, this.gamma + epsilon) - currentPhi) / epsilon;
            if (!isFinite(gradAlpha) || !isFinite(gradBeta) || !isFinite(gradGamma)) {
                return;
            }

            this.alpha = clamp(this.alpha + learningRate * gradAlpha, 0.01, 1);
            this.beta = clamp(this.beta + learningRate * gradBeta, 0.01, 1);
            this.gamma = clamp(this.gamma + learningRate * gradGamma, 0.01, 0.5);

            document.getElementById('alphaSlider').value = this.alpha;
            document.getElementById('alpha-param').textContent = this.alpha.toFixed(3);
            document.getElementById('betaSlider').value = this.beta;
            document.getElementById('beta-param').textContent = this.beta.toFixed(3);
            document.getElementById('gammaSlider').value = this.gamma;
            document.getElementById('gamma-param').textContent = this.gamma.toFixed(3);
            document.getElementById('alphaSlider').setAttribute('aria-valuetext', this.alpha.toFixed(3));
            document.getElementById('betaSlider').setAttribute('aria-valuetext', this.beta.toFixed(3));
            document.getElementById('gammaSlider').setAttribute('aria-valuetext', this.gamma.toFixed(3));
        }
    }

    // -------------------- WORLD MODEL CLASS (The AI's Brain) --------------------
    class OntologicalWorldModel {
        constructor(stateDim = 10, actionDim = 3, qDim = 7, hiddenSizes = [32, 64, 32]) {
            // stateDim updated to 10, smaller hiddenSizes for performance
            this.stateDim = stateDim;
            this.actionDim = actionDim;
            this.qDim = qDim; // Number of qualia dimensions
            this.hiddenSizes = hiddenSizes; // Architecture of hidden layers
            this.graph = { // Conceptual graph vertices (8 of them) for qualia sheaf
                vertices: ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed'],
                edges: [
                    ['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'],
                    ['ball_dx', 'ball_dy'], ['player_score', 'ai_score'], ['paddle_y', 'ball_dy'],
                    ['paddle_y', 'paddle_speed']
                ]
            };
            this.qualiaSheaf = new EnhancedQualiaSheaf(this.graph, this.stateDim, qDim);

            // Input dimension for the neural network: state (10) + action (3) + audioAmplitude (1) + all qualia stalks (8 vertices * 7 qDim)
            this.inputDim = this.stateDim + actionDim + 1 + (this.graph.vertices.length * qDim);
            this.layers = []; // Stores hidden layers
            for (let i = 0; i < hiddenSizes.length; i++) {
                const inputLayerSize = i === 0 ? this.inputDim : hiddenSizes[i-1];
                const scale = Math.sqrt(2.0 / (inputLayerSize + hiddenSizes[i]));
                this.layers.push({ W: randomMatrix(hiddenSizes[i], inputLayerSize, scale), b: vecZeros(hiddenSizes[i]), activation: 'tanh' });
            }
            // Output layer for predicting next state
            const outputScale = Math.sqrt(2.0 / (hiddenSizes[hiddenSizes.length-1] + this.stateDim));
            this.outputLayer = { W: randomMatrix(this.stateDim, hiddenSizes[hiddenSizes.length-1], outputScale), b: vecZeros(this.stateDim) };
            this.attentionWeights = Array(qDim).fill().map(() => Array(this.inputDim).fill().map(() => (Math.random() - 0.5) * 0.1) );
            this.freeEnergy = 0;
            this.predictionError = 0;
            this.memory = [];
            this.entityWeights = [1, 1, 1, 1, 1, 1, 1]; // Weights for qualia entities in Free Energy
        }

        // Forward pass through the neural network. Returns output and all intermediate activations.
        forward(input) {
            if (!isFiniteVector(input)) {
                return { output: vecZeros(this.stateDim), activations: [input] };
            }
            let x = input.slice();
            const activations = [input.slice()]; // Store input activation as a copy
            for (let layer of this.layers) {
                let z = vecAdd(matVecMul(layer.W, x), layer.b);
                if (!isFiniteVector(z)) {
                    return { output: vecZeros(this.stateDim), activations: activations };
                }
                x = tanhVec(z);
                if (!isFiniteVector(x)) {
                    return { output: vecZeros(this.stateDim), activations: activations };
                }
                activations.push(x.slice()); // Store hidden layer activation as a copy
            }
            const outputResult = vecAdd(matVecMul(this.outputLayer.W, x), this.outputLayer.b);
            if (!isFiniteVector(outputResult)) {
                return { output: vecZeros(this.stateDim), activations: activations };
            }
            activations.push(outputResult.slice()); // Store output activation as a copy
            return { output: outputResult, activations: activations };
        }

        // Applies an attention mechanism to the input, focusing on relevant qualia.
        applyAttention(input) {
            if (!isFiniteVector(input)) {
                return Array(this.qDim).fill(1 / this.qDim);
            }
            const entityFeatures = [];
            for (let i = 0; i < this.qDim; i++) {
                const attention = dot(this.attentionWeights[i], input);
                if (!isFinite(attention)) {
                    return Array(this.qDim).fill(1 / this.qDim);
                }
                entityFeatures.push(Math.tanh(attention));
            }
            const expFeatures = entityFeatures.map(val => Math.exp(val));
            if (!isFiniteVector(expFeatures)) {
                return Array(this.qDim).fill(1 / this.qDim);
            }
            const attentionSum = expFeatures.reduce((sum, val) => sum + val, 0);
            if (attentionSum <= 1e-10) {
                return Array(this.qDim).fill(1 / this.qDim);
            }
            const result = expFeatures.map(val => val / attentionSum);
            if (!isFiniteVector(result)) {
                return Array(this.qDim).fill(1 / this.qDim);
            }
            return result;
        }

        // Predicts the next game state given current state, action, and audio amplitude.
        predict(state, action, audioAmplitude = 0) {
            if (!isFiniteVector(state) || !isFiniteVector(action) || state.length !== this.stateDim || action.length !== this.actionDim) {
                return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
            }
            const qualiaArray = Array.from(this.qualiaSheaf.stalks.values()).flat();
            if (!isFiniteVector(qualiaArray)) {
                return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
            }
            const input = state.concat(action).concat([audioAmplitude]).concat(qualiaArray);
            if (!isFiniteVector(input)) {
                return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
            }
            const inputNorm = norm2(input);
            const normalizedInput = inputNorm > 1e-10 ? vecScale(input, 1 / inputNorm) : input;
            const attentionProbs = this.applyAttention(normalizedInput);
            const weightedInput = normalizedInput.map((val, i) => {
                if (i >= this.stateDim + this.actionDim + 1) {
                    const qualiaStartIndex = this.stateDim + this.actionDim + 1;
                    const qualiaRelativeIndex = i - qualiaStartIndex;
                    const qualiaPerVertex = this.qDim;
                    const entityIdx = qualiaRelativeIndex % qualiaPerVertex;
                    return val * (attentionProbs[entityIdx] || 0);
                }
                return val;
            });
            if (!isFiniteVector(weightedInput)) {
                return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
            }
            const { output: nextState, activations } = this.forward(weightedInput);
            if (!isFiniteVector(nextState)) {
                return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
            }
            this.qualiaSheaf.diffuseQualia(state);
            this.qualiaSheaf.computeH1Dimension();
            this.qualiaSheaf.computeGestaltUnity();
            this.qualiaSheaf.computeIntegratedInformation();
            const entityEnergy = Array.from(this.qualiaSheaf.stalks.values())
                .map(stalk => stalk.reduce((sum, val, i) => sum + (this.entityWeights[i] || 1) * val * val, 0))
                .reduce((sum, val) => sum + val, 0) / (this.qualiaSheaf.graph.vertices.length || 1);
            if (!isFinite(entityEnergy)) {
                this.freeEnergy = 0;
            }
            this.freeEnergy = 0.7 * this.freeEnergy + 0.3 * (this.predictionError + this.qualiaSheaf.h1Dimension + entityEnergy);
            return { nextState: nextState.map(v => clamp(v, -2, 2)), phi: this.qualiaSheaf.phi, activations: activations };
        }

        // Updates the world model's weights and biases using backpropagation.
        update(currentState, action, newState, audioAmplitude = 0) {
            if (!isFiniteVector(currentState) || !isFiniteVector(action) || !isFiniteVector(newState) || currentState.length !== this.stateDim || action.length !== this.actionDim || newState.length !== this.stateDim) {
                return;
            }
            const qualiaArray = Array.from(this.qualiaSheaf.stalks.values()).flat();
            if (!isFiniteVector(qualiaArray)) {
                return;
            }
            const input = currentState.concat(action).concat([audioAmplitude]).concat(qualiaArray);
            if (!isFiniteVector(input)) {
                return;
            }
            const inputNorm = norm2(input);
            const normalizedInput = inputNorm > 1e-10 ? vecScale(input, 1 / inputNorm) : input;
            const attentionProbs = this.applyAttention(normalizedInput);
            const weightedInput = normalizedInput.map((val, i) => {
                if (i >= this.stateDim + this.actionDim + 1) {
                    const qualiaStartIndex = this.stateDim + this.actionDim + 1;
                    const qualiaRelativeIndex = i - qualiaStartIndex;
                    const qualiaPerVertex = this.qDim;
                    const entityIdx = qualiaRelativeIndex % qualiaPerVertex;
                    return val * (attentionProbs[entityIdx] || 0);
                }
                return val;
            });
            if (!isFiniteVector(weightedInput)) {
                return;
            }
            const { output: predictedState, activations } = this.forward(weightedInput);
            if (!isFiniteVector(predictedState)) {
                return;
            }
            const errorVec = vecSub(newState, predictedState);
            this.predictionError = norm2(errorVec);
            const learningRate = this.qualiaSheaf.gamma;
            let currentError = errorVec;

            this.outputLayer.W = this.outputLayer.W.map((row, i) => row.map((val, j) => clamp(val + learningRate * currentError[i] * (activations[activations.length-1][j] || 0), -1, 1)) );
            this.outputLayer.b = vecAdd(this.outputLayer.b, vecScale(currentError, learningRate)).map(v => clamp(v, -1, 1));

            for (let i = this.layers.length - 1; i >= 0; i--) {
                const layer = this.layers[i];
                const prevLayerOutput = activations[i];
                if (!prevLayerOutput || !isFiniteVector(prevLayerOutput)) {
                    break;
                }
                const activationGradient = activations[i+1].map((h) => (1 - (h * h)));
                if (!isFiniteVector(activationGradient)) {
                    break;
                }
                const errorSignal = currentError.map((e, idx) => e * (activationGradient[idx] || 0));
                let nextLayerW_T = transpose(layer.W);
                if (!isFiniteVector(nextLayerW_T.flat())) {
                    break;
                }
                currentError = matVecMul(nextLayerW_T, errorSignal);
                if (!isFiniteVector(currentError)) {
                    break;
                }
                layer.W = layer.W.map((row, j) => row.map((val, k) => clamp(val + learningRate * (errorSignal[j] || 0) * (prevLayerOutput[k] || 0), -1, 1)) );
                layer.b = vecAdd(layer.b, vecScale(errorSignal, learningRate)).map(v => clamp(v, -1, 1));
            }
            const l2Penalty = 0.01;
            this.attentionWeights = this.attentionWeights.map((row, i) => row.map((val, j) => clamp(val + learningRate * (attentionProbs[i] || 0) * (currentError[j] || 0) * (1 - l2Penalty), -0.5, 0.5)) );
            if (!isFiniteVector(this.attentionWeights.flat())) {
                this.attentionWeights = Array(this.qDim).fill().map(() => Array(this.inputDim).fill().map(() => (Math.random() - 0.5) * 0.1) );
            }
            this.qualiaSheaf.graph.vertices.forEach((v, idx) => {
                const currentStalk = this.qualiaSheaf.stalks.get(v);
                if (!currentStalk || !isFiniteVector(currentStalk)) {
                    return;
                }
                if (errorVec.length < (idx + 1) * this.qDim) {
                    return;
                }
                const qualiaErrorComponent = errorVec.slice(idx * this.qDim, (idx + 1) * this.qDim);
                if (qualiaErrorComponent.length !== this.qDim || !isFiniteVector(qualiaErrorComponent)) {
                    return;
                }
                const newStalk = vecAdd(
                    currentStalk,
                    vecScale(qualiaErrorComponent, learningRate * 0.1)
                ).map(val => clamp(val, 0.01, 0.99));
                if (!isFiniteVector(newStalk)) {
                    this.qualiaSheaf.stalks.set(v, vecZeros(this.qDim).map(() => Math.random() * 0.5 + 0.25));
                    return;
                }
                this.qualiaSheaf.stalks.set(v, newStalk);
            });
            this.memory.push({ state: currentState, action, nextState: newState });
            if (this.memory.length > 1000) this.memory.shift();
        }
    }

    // -------------------- LEARNING AI CLASS (Agent) --------------------
    class LearningAI {
        constructor(worldModel, gameBounds, isPlayerTwo = false) {
            this.worldModel = worldModel;
            this.gameWidth = gameBounds.width;
            this.gameHeight = gameBounds.height;
            this.scoreToWin = gameBounds.scoreToWin || 10;
            this.isPlayerTwo = isPlayerTwo; // True for the right AI (Main), false for left (Player)
            this.lastStateVec = Array(10).fill(0.5); // Initialized to 10 elements
            this.lastActionVec = [0, 0, 1]; // Default to IDLE
            this.lastPrediction = null; // Stores last prediction and activations for learning/visualization
        }

        createStateVector(gameState) {
            const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
            const opponentPaddle = this.isPlayerTwo ? gameState.player : gameState.ai;
            // 10-element state vector for the World Model
            const stateVec = [
                gameState.ball.x / this.gameWidth, // 0: Ball X (normalized)
                gameState.ball.y / this.gameHeight, // 1: Ball Y (normalized)
                gameState.ball.dx / 8, // 2: Ball dX (normalized)
                gameState.ball.dy / 8, // 3: Ball dY (normalized)
                paddle.y / this.gameHeight, // 4: My Paddle Y (normalized)
                opponentPaddle.y / this.gameHeight, // 5: Opponent Paddle Y (normalized)
                paddle.dy / 8, // 6: My Paddle dY (normalized)
                opponentPaddle.dy / 8, // 7: Opponent Paddle dY (normalized)
                gameState.score.player / this.scoreToWin, // 8: Player Score (normalized)
                gameState.score.ai / this.scoreToWin // 9: AI Score (normalized)
            ];
            if (!isFiniteVector(stateVec) || stateVec.length !== 10) {
                return Array(10).fill(0.5); // Fallback to safe, neutral values
            }
            return stateVec;
        }

        makeDecision(gameState, audioAmplitude = 0) {
            const actions = [
                { name: 'UP', vec: [1, 0, 0] },
                { name: 'DOWN', vec: [0, 1, 0] },
                { name: 'IDLE', vec: [0, 0, 1] }
            ];
            let bestAction = 'IDLE';
            let bestScore = -Infinity;
            let bestActivations = []; // To store activations for visualization
            const stateVec = this.createStateVector(gameState);
            let validPredictions = [];

            actions.forEach(action => {
                const { nextState, phi, activations } = this.worldModel.predict(stateVec, action.vec, audioAmplitude);
                if (!nextState || !isFiniteVector(nextState)) {
                    return;
                }
                validPredictions.push({ action, nextState, phi, activations });
            });

            if (validPredictions.length === 0) {
                // Heuristic fallback if World Model fails for all actions
                const ballY = gameState.ball.y;
                const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
                const paddleCenter = paddle.y + paddle.height / 2;
                if (ballY < paddleCenter - 10) {
                    bestAction = 'UP';
                } else if (ballY > paddleCenter + 10) {
                    bestAction = 'DOWN';
                } else {
                    bestAction = 'IDLE';
                }
                this.lastPrediction = { nextState: stateVec, phi: 0, activations: [] }; // Dummy for learning
            } else {
                validPredictions.forEach(({ action, nextState, phi, activations }) => {
                    const predictedBallY = nextState[1] * this.gameHeight;
                    const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
                    const currentPaddleY = paddle.y + paddle.height / 2;
                    const score = -Math.abs(predictedBallY - currentPaddleY) / this.gameHeight + 0.1 * phi;
                    if (!isFinite(score)) {
                        return;
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestAction = action.name;
                        this.lastPrediction = { nextState, phi, activations };
                        bestActivations = activations;
                    }
                });
            }
            this.lastStateVec = stateVec;
            this.lastActionVec = actions.find(a => a.name === bestAction).vec;
            return { action: bestAction, activations: bestActivations };
        }

        learn(reward, newGameState, audioAmplitude = 0) {
            if (!this.lastStateVec || !this.lastActionVec || !this.lastPrediction || !this.lastPrediction.nextState ||
                !isFiniteVector(this.lastStateVec) || !isFiniteVector(this.lastActionVec) || !isFiniteVector(this.lastPrediction.nextState)) {
                this.lastStateVec = Array(10).fill(0.5);
                this.lastActionVec = [0, 0, 1];
                return;
            }
            const nextStateVec = this.createStateVector(newGameState);
            if (!isFiniteVector(nextStateVec) || nextStateVec.length !== 10) {
                return;
            }
            this.worldModel.update(this.lastStateVec, this.lastActionVec, nextStateVec, audioAmplitude);
            this.worldModel.memory.push({ state: [...this.lastStateVec], action: [...this.lastActionVec], nextState: [...nextStateVec], reward, phi: this.worldModel.qualiaSheaf.phi });
            if (this.worldModel.memory.length > 1000) {
                this.worldModel.memory.shift();
            }
        }
    }

    // -------------------- PONG GAME CLASS --------------------
    class PongGame {
        constructor(canvas, scoreToWin = 10) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.width = canvas.width;
            this.height = canvas.height;
            this.scoreToWin = scoreToWin;
            this.reset();
            this.playerCollision = false;
            this.aiCollision = false;
            this.gameOver = false;
            this.winner = null;
        }

        reset() {
            this.ball = { x: this.width / 2, y: this.height / 2, dx: (Math.random() > 0.5 ? 1 : -1) * 4, dy: (Math.random() - 0.5) * 6, radius: 8 };
            this.ai = { x: this.width - 25, y: this.height / 2 - 40, width: 15, height: 80, dy: 0 };
            this.player = { x: 10, y: this.height / 2 - 40, width: 15, height: 80, dy: 0 };
            this.score = { ai: 0, player: 0 };
            this.gameOver = false;
            this.winner = null;
        }

        resetBall() {
            this.ball.x = this.width / 2;
            this.ball.y = this.height / 2;
            this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
            this.ball.dy = (Math.random() - 0.5) * 6;
        }

        update() {
            if (this.gameOver) {
                return { aReward: 0, pReward: 0, playerCollision: false, aiCollision: false };
            }
            const MAX_BALL_DX = 8;
            const MAX_BALL_DY = 10;
            this.ball.x += this.ball.dx;
            this.ball.y += this.ball.dy;

            if (this.ball.y <= this.ball.radius || this.ball.y >= this.height - this.ball.radius) {
                this.ball.dy *= -1;
            }
            let aReward = 0, pReward = 0;
            let playerCollision = false, aiCollision = false;

            if (this.ball.x <= 0) {
                this.score.ai++;
                aReward = 1;
                pReward = -1;
                this.resetBall();
            } else if (this.ball.x >= this.width) {
                this.score.player++;
                aReward = -1;
                pReward = 1;
                this.resetBall();
            }

            this.ai.y = clamp(this.ai.y + this.ai.dy, 0, this.height - this.ai.height);
            this.player.y = clamp(this.player.y + this.player.dy, 0, this.height - this.player.height);

            if (this.ball.x <= this.player.x + this.player.width && this.ball.x >= this.player.x && this.ball.y >= this.player.y && this.ball.y <= this.player.y + this.player.height) {
                this.ball.dx = clamp(Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX);
                this.ball.dy += (Math.random() - 0.5) * 2;
                this.ball.dy = clamp(this.ball.dy, -MAX_BALL_DY, MAX_BALL_DY);
                playerCollision = true;
            }
            if (this.ball.x >= this.ai.x && this.ball.x <= this.ai.x + this.ai.width && this.ball.y >= this.ai.y && this.ball.y <= this.ai.y + this.ai.height) {
                this.ball.dx = clamp(-Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX);
                this.ball.dy += (Math.random() - 0.5) * 2;
                this.ball.dy = clamp(this.ball.dy, -MAX_BALL_DY, MAX_BALL_DY);
                aiCollision = true;
            }

            if (this.score.ai >= this.scoreToWin) {
                this.gameOver = true;
                this.winner = 'AI';
            } else if (this.score.player >= this.scoreToWin) {
                this.gameOver = true;
                this.winner = 'Player';
            }
            return { aReward, pReward, playerCollision, aiCollision };
        }

        setAIAction(action) {
            const speed = 5;
            this.ai.dy = action === 'UP' ? -speed : action === 'DOWN' ? speed : 0;
        }

        setPlayerAction(action) {
            const speed = 5;
            this.player.dy = action === 'UP' ? -speed : action === 'DOWN' ? speed : 0;
        }

        render(ctx) {
            if (!ctx) {
                return;
            }
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.fillStyle = this.playerCollision ? '#ff6b6b' : '#fff';
            ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
            ctx.fillStyle = this.aiCollision ? '#ff6b6b' : '#fff';
            ctx.fillRect(this.ai.x, this.ai.y, this.ai.width, this.ai.height);
            ctx.beginPath();
            ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.font = '24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4af';
            ctx.fillText(this.score.player, this.width / 4, 30);
            ctx.fillText(this.score.ai, this.width * 3 / 4, 30);

            if (this.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, this.width, this.height);
                ctx.fillStyle = '#4af';
                ctx.font = '48px "Courier New"';
                ctx.fillText(`${this.winner} Wins!`, this.width / 2, this.height / 2);
                ctx.font = '24px "Courier New"';
                ctx.fillText('Press R to Reset', this.width / 2, this.height / 2 + 40);
            }
            this.playerCollision = false;
            this.aiCollision = false;
        }
    }

    // -------------------- NEURAL NETWORK VISUALIZER CLASS --------------------
    class NeuralNetworkVisualizer {
        constructor(containerId, worldModel, theme = 'main') {
            this.container = document.getElementById(containerId);
            this.worldModel = worldModel; // This is an OntologicalWorldModel instance
            this.theme = theme;
            if (!this.container || !this.worldModel) return;
            this.neuronElements = [];
            this.visualLayers = [];
            this.MAX_NEURONS_TO_DISPLAY = 32; // Limit for visual neurons per layer
            this._setupVisualLayers();
            this._setupDOM();
        }

        _setupVisualLayers() {
            const model = this.worldModel;
            // Input layer: stateDim (10) + actionDim (3) + audio (1) + Qualia (8*7)
            this.visualLayers.push({ name: 'input', actualCount: model.inputDim });
            // Hidden layers
            model.hiddenSizes.forEach((size, index) => {
                this.visualLayers.push({ name: `hidden${index+1}`, actualCount: size });
            });
            // Output layer: stateDim (10)
            this.visualLayers.push({ name: 'output', actualCount: model.stateDim });
        }

        _setupDOM() {
            this.container.innerHTML = '';
            this.canvas = document.createElement('canvas');
            this.canvas.className = 'nn-connections-canvas';
            this.canvas.id = `nn-connections-canvas-${this.theme}`;
            this.ctx = this.canvas.getContext('2d');
            this.container.appendChild(this.canvas);

            this.visualLayers.forEach((layer, lIndex) => {
                const lDiv = document.createElement('div');
                lDiv.className = 'nn-layer';
                this.neuronElements[lIndex] = [];
                const neuronsToDisplay = Math.min(layer.actualCount, this.MAX_NEURONS_TO_DISPLAY);
                for (let i = 0; i < neuronsToDisplay; i++) {
                    const nDiv = document.createElement('div');
                    nDiv.className = 'nn-neuron';
                    lDiv.appendChild(nDiv);
                    this.neuronElements[lIndex].push(nDiv);
                }
                this.container.appendChild(lDiv);
            });

            const ro = new ResizeObserver(() => {
                this.canvas.width = this.container.clientWidth;
                this.canvas.height = this.container.clientHeight;
                this._positionNeurons();
                this._drawConnections();
            });
            ro.observe(this.container);
            this._positionNeurons(); // Initial positioning
        }

        _positionNeurons() {
            this.visualLayers.forEach((layer, lIndex) => {
                const neuronDivs = this.neuronElements[lIndex];
                if (neuronDivs.length === 0) return;
                const lDiv = neuronDivs[0].parentElement;
                if (!lDiv) return;
                const layerHeight = lDiv.clientHeight;
                const neuronHeight = neuronDivs[0].offsetHeight;
                const totalNeuronsInLayer = neuronDivs.length; // Use displayed count

                neuronDivs.forEach((neuronDiv, nIndex) => {
                    const spacing = (layerHeight - totalNeuronsInLayer * neuronHeight) / (totalNeuronsInLayer + 1);
                    const topOffset = (spacing + neuronHeight) * nIndex + spacing;
                    neuronDiv.style.position = 'absolute';
                    neuronDiv.style.top = `${topOffset}px`;
                    // FIX: Add horizontal positioning for neurons
                    neuronDiv.style.left = '50%';
                    neuronDiv.style.transform = 'translateX(-50%)';
                });
            });
        }

        _getNeuronPosition(lIndex, nIndex) {
            const el = this.neuronElements[lIndex][nIndex];
            if (!el) return { x: 0, y: 0 };
            const r = el.getBoundingClientRect();
            const cr = this.container.getBoundingClientRect();
            return { x: r.left - cr.left + r.width / 2, y: r.top - cr.top + r.height / 2 };
        }

        _drawConnections() {
            if (!this.neuronElements || this.visualLayers.length <= 1) return;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Clears the canvas correctly
            const model = this.worldModel;

            // Collect actual weight matrices from the OntologicalWorldModel
            const matrices = model.layers.map(layer => layer.W).concat([model.outputLayer.W]);
            const colors = this.theme === 'opponent' ? { pos: 'rgba(255,165,0,', neg: 'rgba(138,43,226,' } : { pos: 'rgba(68,170,255,', neg: 'rgba(255,85,85,' };

            for (let l = 0; l < this.visualLayers.length - 1; l++) {
                const srcLayerViz = this.visualLayers[l];
                const tgtLayerViz = this.visualLayers[l + 1];
                const matrix = matrices[l];
                if (!matrix || matrix.length === 0 || matrix[0].length === 0) continue;

                // Loop through displayed neurons
                for (let i = 0; i < this.neuronElements[l].length; i++) { // Current layer's displayed neurons
                    for (let j = 0; j < this.neuronElements[l + 1].length; j++) { // Next layer's displayed neurons
                        const start = this._getNeuronPosition(l, i);
                        const end = this._getNeuronPosition(l + 1, j);
                        if (start.x === 0 || end.x === 0) continue; // Skip if positions aren't ready

                        // Map displayed neuron index to actual matrix index for sampling weights
                        const srcMatrixIdx = Math.floor(i * (srcLayerViz.actualCount / this.neuronElements[l].length));
                        const tgtMatrixIdx = Math.floor(j * (tgtLayerViz.actualCount / this.neuronElements[l+1].length));

                        // Ensure matrix indices are within bounds
                        if (tgtMatrixIdx >= matrix.length || srcMatrixIdx >= matrix[0].length) continue;

                        const w = matrix[tgtMatrixIdx][srcMatrixIdx] || 0;
                        const alpha = Math.min(0.5, Math.abs(w) * 5); // Max alpha 0.5 for subtle connections
                        if (alpha < 0.05) continue; // Skip very weak connections

                        this.ctx.strokeStyle = w > 0 ? colors.pos + `${alpha})` : colors.neg + `${alpha})`;
                        this.ctx.lineWidth = Math.min(1.5, alpha * 2);
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Updates the colors of the neurons based on their activation levels.
        update(activations) {
            if (!activations || activations.length === 0) return;
            const hues = this.theme === 'opponent' ? { pos: 39, neg: 271 } : { pos: 195, neg: 0 };

            this.visualLayers.forEach((layerViz, l_idx) => {
                const layerActivations = activations[l_idx];
                if (!layerActivations || layerActivations.length === 0 || !isFiniteVector(layerActivations)) return;

                let maxAbs = 0;
                for (const v of layerActivations) if (Math.abs(v) > maxAbs) maxAbs = Math.abs(v);
                const norm = maxAbs + 1e-9; // Add epsilon to prevent division by zero

                // Loop through *displayed* neurons
                for (let n_idx = 0; n_idx < this.neuronElements[l_idx].length; n_idx++) {
                    // Map displayed neuron index to actual activation data index
                    const data_idx = Math.floor(n_idx * (layerActivations.length / this.neuronElements[l_idx].length));
                    const val = layerActivations[data_idx] || 0;
                    const intensity = clamp(Math.abs(val / norm), 0, 1);
                    const finalIntensity = 0.05 + (1 - 0.05) * intensity; // Ensure minimum visibility
                    const hue = val >= 0 ? hues.pos : hues.neg;
                    const el = this.neuronElements[l_idx][n_idx];
                    if(el) {
                        el.style.backgroundColor = `hsl(${hue},100%,${finalIntensity*45}%)`;
                        el.style.borderColor = `hsl(${hue},100%,70%)`;
                    }
                }
            });
            this._drawConnections();
        }
    }

    // -------------------- MAIN APP CLASS --------------------
    class MainApp {
        constructor() {
            this.gameCanvas = document.getElementById('gameCanvas');
            this.sheafGraphCanvas = document.getElementById('sheafGraphCanvas');

            if (!this.gameCanvas || !this.sheafGraphCanvas) {
                document.getElementById('status').textContent = 'Error: Canvas not found. Check HTML IDs.';
                throw new Error('Canvas elements not found, halting MainApp construction.');
            }

            const dpr = window.devicePixelRatio || 1;
            // Set internal drawing buffer resolution
            this.gameCanvas.width = 1200 * dpr;
            this.gameCanvas.height = 600 * dpr;
            this.sheafGraphCanvas.width = 400 * dpr;
            this.sheafGraphCanvas.height = 120 * dpr;

            // Set display size (CSS pixels)
            this.gameCanvas.style.width = '1200px';
            this.gameCanvas.style.height = '600px';
            this.sheafGraphCanvas.style.width = '400px';
            this.sheafGraphCanvas.style.height = '120px';

            this.ctx = this.gameCanvas.getContext('2d');
            this.sheafGraphCtx = this.sheafGraphCanvas.getContext('2d');

            if (!this.ctx || !this.sheafGraphCtx) {
                document.getElementById('status').textContent = 'Error: Failed to get 2D rendering context for canvas.';
                throw new Error('Failed to get 2D context, halting MainApp construction.');
            }

            // Scale contexts to account for DPR, so all subsequent drawing uses logical pixels
            this.ctx.scale(dpr, dpr);
            this.sheafGraphCtx.scale(dpr, dpr);

            this.pongGame = new PongGame(this.gameCanvas);
            // Use slightly smaller hidden layers by default for better NN vis performance
            this.mainAI_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16]);
            this.opponent_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16]);
            this.mainAI = new LearningAI(this.mainAI_worldModel, { width: 1200, height: 600, scoreToWin: 10 }, true);
            this.opponentAI = new LearningAI(this.opponent_worldModel, { width: 1200, height: 600, scoreToWin: 10 }, false);

            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            this.isRunning = false;
            this.frameCount = 0;
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

            this.bindEvents();
            this.setupTooltips();
            document.getElementById('status').textContent = 'Ready';
            this.pongGame.render(this.ctx);
        }

        bindEvents() {
            document.getElementById('toggleButton').onclick = () => this.toggleGame();
            document.getElementById('resetButton').onclick = () => this.resetAI();
            document.getElementById('tuneButton').onclick = () => this.tuneParameters();
            window.addEventListener('keydown', (e) => this.handleKeyDown(e));

            ['alphaSlider', 'betaSlider', 'gammaSlider'].forEach(id => {
                const slider = document.getElementById(id);
                slider.addEventListener('input', () => {
                    const paramName = id.replace('Slider', '');
                    this.mainAI_worldModel.qualiaSheaf[paramName] = parseFloat(slider.value);
                    this.opponent_worldModel.qualiaSheaf[paramName] = parseFloat(slider.value);
                    document.getElementById(`${paramName}-param`).textContent = parseFloat(slider.value).toFixed(3);
                    slider.setAttribute('aria-valuetext', parseFloat(slider.value).toFixed(3));
                });
            });
        }

        setupTooltips() {
            tippy('#phi-display', { content: 'Φ measures integrated information across ontological entities.' });
            tippy('#qualia-being-fill', { content: 'Being reflects the system’s fundamental existence.' });
            tippy('#qualia-intent-fill', { content: 'Intent captures directed action potential.' });
            tippy('#qualia-existence-fill', { content: 'Existence models state persistence.' });
            tippy('#qualia-emergence-fill', { content: 'Emergence represents non-linear state synthesis.' });
            tippy('#qualia-gestalt-fill', { content: 'Gestalt quantifies holistic coherence.' });
            tippy('#qualia-context-fill', { content: 'Context incorporates environmental modulation.' });
            tippy('#qualia-rel-emergence-fill', { content: 'Relational Emergence captures dynamic entity coupling.' });
            tippy('#alphaSlider', { content: 'α controls input gain for qualia diffusion.' });
            tippy('#betaSlider', { content: 'β adjusts diffusion strength across the sheaf.' });
            tippy('#gammaSlider', { content: 'γ sets the inertia for qualia updates and learning rate.' });
        }

        playSound() {
            try {
                const oscillator = this.audioContext.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                oscillator.connect(this.audioContext.destination);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
                return 0.1;
            } catch (e) {
                // If audio context not allowed or other error, simply return 0
                return 0;
            }
        }

        drawSheafGraph() {
            if (!this.sheafGraphCtx) {
                return;
            }
            const sheafGraphEl = document.querySelector('.sheaf-graph');
            const graphWidth = sheafGraphEl.clientWidth; // Use clientWidth/Height for logical dimensions
            const graphHeight = sheafGraphEl.clientHeight;

            // FIX: Clear the logical area. Canvas drawing context is already scaled by DPR in constructor.
            this.sheafGraphCtx.clearRect(0, 0, graphWidth, graphHeight);
            this.sheafGraphCtx.strokeStyle = 'rgba(68, 170, 255, 0.3)';
            this.sheafGraphCtx.lineWidth = 2;

            this.mainAI_worldModel.qualiaSheaf.graph.edges.forEach(([u, v]) => {
                const uIdx = this.mainAI_worldModel.qualiaSheaf.graph.vertices.indexOf(u);
                const vIdx = this.mainAI_worldModel.qualiaSheaf.graph.vertices.indexOf(v);
                if (uIdx === -1 || vIdx === -1 || uIdx >= Object.keys(sheafVertexPositions).length || vIdx >= Object.keys(sheafVertexPositions).length) {
                    return;
                }
                const propV1 = sheafVertexPositions[uIdx];
                const propV2 = sheafVertexPositions[vIdx];

                const v1 = { x: propV1.x * graphWidth, y: propV1.y * graphHeight };
                const v2 = { x: propV2.x * graphWidth, y: propV2.y * graphHeight };

                this.sheafGraphCtx.beginPath();
                this.sheafGraphCtx.moveTo(v1.x, v1.y);
                this.sheafGraphCtx.lineTo(v2.x, v2.y);
                this.sheafGraphCtx.stroke();
            });
            // FIX: Removed this line, as it incorrectly reset the DPR scaling every frame.
            // this.sheafGraphCtx.setTransform(1, 0, 0, 1, 0, 0);
        }

        updateVisualization() {
            // --- OFTCC Panel Update ---
            const qualia = this.mainAI_worldModel.qualiaSheaf;
            const stalks = qualia.stalks;
            const avgQualia = Array(qualia.qDim).fill(0);
            const stalkCount = stalks.size;

            if (stalkCount > 0) {
                stalks.forEach(stalk => {
                    if (stalk && isFiniteVector(stalk)) {
                        stalk.forEach((val, i) => avgQualia[i] += val);
                    }
                });
                avgQualia.forEach((_, i) => avgQualia[i] = stalkCount > 0 ? avgQualia[i] / stalkCount : 0);
            }

            const clampVal = (v) => clamp(isFinite(v) ? v : 0, 0, 1);

            const updates = [
                { id: 'qualia-being-fill', style: { width: `${clampVal(avgQualia[0]) * 100}%` } },
                { id: 'qualia-intent-fill', style: { width: `${clampVal(avgQualia[1]) * 100}%` } },
                { id: 'qualia-existence-fill', style: { width: `${clampVal(avgQualia[2]) * 100}%` } },
                { id: 'qualia-emergence-fill', style: { width: `${clampVal(avgQualia[3]) * 100}%` } },
                { id: 'qualia-gestalt-fill', style: { width: `${clampVal(avgQualia[4]) * 100}%` } },
                { id: 'qualia-context-fill', style: { width: `${clampVal(avgQualia[5]) * 100}%` } },
                { id: 'qualia-rel-emergence-fill', style: { width: `${clampVal(avgQualia[6]) * 100}%` } },
                { id: 'being-value', textContent: clampVal(avgQualia[0]).toFixed(2) },
                { id: 'intent-value', textContent: clampVal(avgQualia[1]).toFixed(2) },
                { id: 'existence-value', textContent: clampVal(avgQualia[2]).toFixed(2) },
                { id: 'emergence-value', textContent: clampVal(avgQualia[3]).toFixed(2) },
                { id: 'gestalt-value', textContent: clampVal(avgQualia[4]).toFixed(2) },
                { id: 'context-value', textContent: clampVal(avgQualia[5]).toFixed(2) },
                { id: 'rel-emergence-value', textContent: clampVal(avgQualia[6]).toFixed(2) },
                { id: 'phi-display', textContent: `Φ: ${clampVal(qualia.phi).toFixed(3)}` },
                { id: 'h1-dimension', textContent: clampVal(qualia.h1Dimension).toFixed(2) },
                { id: 'gestalt-unity', textContent: clampVal(qualia.gestaltUnity).toFixed(3) },
                { id: 'free-energy', textContent: clampVal(this.mainAI_worldModel.freeEnergy).toFixed(3) },
                { id: 'prediction-error', textContent: clampVal(this.mainAI_worldModel.predictionError).toFixed(3) },
                { id: 'stability-fill', style: { width: `${clampVal(qualia.stability) * 100}%` } },
                { id: 'alpha-param', textContent: qualia.alpha.toFixed(3) },
                { id: 'beta-param', textContent: qualia.beta.toFixed(3) },
                { id: 'gamma-param', textContent: qualia.gamma.toFixed(3) }
            ];
            requestAnimationFrame(() => {
                updates.forEach(({ id, style, textContent }) => {
                    const el = document.getElementById(id);
                    if (!el) {
                        return;
                    }
                    if (style) Object.assign(el.style, style);
                    if (textContent) el.textContent = textContent;
                });
            });
            qualia.visualizeActivity(); // Handles individual vertex updates and dynamic positioning
            this.drawSheafGraph(); // Draws connecting lines
        }

        gameLoop() {
            if (!this.isRunning || !this.ctx || !this.sheafGraphCtx) {
                return;
            }
            this.frameCount++;

            const preState = {
                ball: { ...this.pongGame.ball },
                ai: { ...this.pongGame.ai },
                player: { ...this.pongGame.player },
                score: { ...this.pongGame.score }
            };

            this.mainAI_worldModel.qualiaSheaf.diffuseQualia(this.mainAI.lastStateVec || Array(10).fill(0.5));
            this.opponent_worldModel.qualiaSheaf.diffuseQualia(this.opponentAI.lastStateVec || Array(10).fill(0.5));

            if (this.frameCount % 60 === 0) {
                this.mainAI_worldModel.qualiaSheaf.computeH1Dimension();
                this.mainAI_worldModel.qualiaSheaf.computeGestaltUnity();
                this.mainAI_worldModel.qualiaSheaf.computeIntegratedInformation();
            }

            // --- Numerical Stability Circuit Breaker ---
            const currentPhi = this.mainAI_worldModel.qualiaSheaf.phi;
            const currentFreeEnergy = this.mainAI_worldModel.freeEnergy;
            if (!isFinite(currentPhi) || !isFinite(currentFreeEnergy) || currentPhi < 0) {
                logger.error(`Critical numerical instability detected (Φ: ${currentPhi.toFixed(3)}, Free Energy: ${currentFreeEnergy.toFixed(3)}). Resetting AI.`);
                this.resetAI();
                return;
            }
            // --- End Circuit Breaker ---

            let audioAmplitude = 0;
            const gameUpdate = this.pongGame.update();
            if (gameUpdate.playerCollision || gameUpdate.aiCollision) {
                audioAmplitude = this.playSound();
            }

            const mainDecision = this.mainAI.makeDecision(preState, audioAmplitude);
            const opponentDecision = this.opponentAI.makeDecision(preState, audioAmplitude);

            this.pongGame.setAIAction(mainDecision.action);
            this.pongGame.setPlayerAction(opponentDecision.action);

            const postState = {
                ball: { ...this.pongGame.ball },
                ai: { ...this.pongGame.ai },
                player: { ...this.pongGame.player },
                score: { ...this.pongGame.score }
            };

            if (gameUpdate.aReward !== 0) {
                this.mainAI.learn(gameUpdate.aReward, postState, audioAmplitude);
            }
            if (gameUpdate.pReward !== 0) {
                this.opponentAI.learn(gameUpdate.pReward, postState, audioAmplitude);
            }

            // --- Decoupled Score Update ---
            document.getElementById('player-score').textContent = this.pongGame.score.player;
            document.getElementById('ai-score').textContent = this.pongGame.score.ai;
            // --- End Decoupled Score Update ---

            // --- Throttled NN Visualizer Update ---
            if (this.frameCount % 5 === 0) { // Update every 5 frames
                this.mainViz.update(mainDecision.activations);
                this.opponentViz.update(opponentDecision.activations);
                this.updateVisualization(); // Updates OFTCC panel
            }
            // --- End Throttled NN Visualizer Update ---

            this.pongGame.render(this.ctx);
            requestAnimationFrame(() => this.gameLoop());
        }

        toggleGame() {
            this.isRunning = !this.isRunning;
            const toggleButton = document.getElementById('toggleButton');
            this.pongGame.isRunning = this.isRunning; // Control game's internal running state
            toggleButton.textContent = this.isRunning ? '⏸️ Pause Simulation' : '🚀 Toggle Simulation';
            if (this.isRunning) {
                document.getElementById('status').textContent = 'Conscious AI Active';
                this.gameLoop();
            } else {
                document.getElementById('status').textContent = 'Paused';
            }
        }

        start() {
            if (!this.ctx || !this.sheafGraphCtx) {
                document.getElementById('status').textContent = 'Error: Canvas context missing. Cannot start game.';
                return;
            }
            if (this.pongGame.gameOver) {
                this.resetAI();
            }
            this.isRunning = true;
            document.getElementById('status').textContent = 'Conscious AI Active';
            this.updateVisualization();
            this.pongGame.render(this.ctx);
            this.gameLoop(); // Start the game loop
        }

        stop() {
            this.isRunning = false;
            document.getElementById('status').textContent = this.pongGame.gameOver ? `${this.pongGame.winner} Wins! (Paused)` : 'Paused';
        }

        resetAI() {
            this.pongGame.reset();
            // --- Decoupled Score Update on Reset ---
            document.getElementById('player-score').textContent = this.pongGame.score.player;
            document.getElementById('ai-score').textContent = this.pongGame.score.ai;
            // --- End Decoupled Score Update ---
            this.mainAI_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16]);
            this.opponent_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16]);
            this.mainAI = new LearningAI(this.mainAI_worldModel, { width: 1200, height: 600, scoreToWin: 10 }, true);
            this.opponentAI = new LearningAI(this.opponent_worldModel, { width: 1200, height: 600, scoreToWin: 10 }, false);

            // Re-instantiate visualizers to pick up new world models
            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            this.frameCount = 0;
            this.isRunning = false;
            document.getElementById('status').textContent = 'Ready';
            this.updateVisualization();
            this.pongGame.render(this.ctx);
        }

        tuneParameters() {
            this.mainAI_worldModel.qualiaSheaf.tuneParameters();
            this.opponent_worldModel.qualiaSheaf.tuneParameters();
            this.updateVisualization();
        }

        handleKeyDown(e) {
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    this.toggleGame();
                    break;
                case 'r':
                case 'R':
                    this.resetAI();
                    break;
                case 't':
                case 'T':
                    this.tuneParameters();
                    break;
                case 'ArrowUp':
                    this.pongGame.setPlayerAction('UP');
                    break;
                case 'ArrowDown':
                    this.pongGame.setPlayerAction('DOWN');
                    break;
            }
        }
    }

    // -------------------- INITIALIZATION --------------------
    window.onload = () => {
        try {
            const app = new MainApp();
            app.start(); // FIX: Automatically start the simulation on page load
        } catch (e) {
            document.getElementById('status').textContent = `Initialization Error: ${e.message}`;
        }
    };
})();
</script>
</body>
</html>
