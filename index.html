<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conscious Pong AI — Enhanced & Optimized</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Page Styles --- */
        :root {
            --bg-dark: #0a0a15;
            --bg-gradient-start: #0a0a15;
            --bg-gradient-end: #1a0a2e;
            --primary-blue: #4af;
            --primary-blue-glow: rgba(68, 170, 255, 0.8);
            --secondary-dark: rgba(10, 10, 30, 0.9);
            --border-dark: #2a2a4a;
            --text-light: #e0e0e0;
            --text-medium: #aaa;
            --text-dark: #888;
            --error-red: #ff6b6b;
            --warn-orange: #ffa726;
            --info-green: #4CAF50;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            font-family: 'Courier Prime', monospace; /* Modern monospace font */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to start for better scroll */
            min-height: 100vh;
            padding: 20px;
            color: var(--primary-blue);
            box-sizing: border-box;
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden;
            line-height: 1.5;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 0;
            gap: 20px;
        }
        /* --- Header Styles --- */
        .header {
            text-align: center;
            background: var(--secondary-dark);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--primary-blue);
            box-shadow: 0 0 30px var(--primary-blue-glow);
            will-change: transform, box-shadow;
            transition: all 0.3s ease-in-out;
        }
        .header:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 40px var(--primary-blue-glow);
        }
        .header h1 {
            margin: 0;
            color: var(--primary-blue);
            text-shadow: 0 0 20px var(--primary-blue-glow);
            font-size: 2.5em;
            letter-spacing: 1px;
        }
        .header p {
            margin: 10px 0 0;
            color: var(--text-medium);
            font-size: 1.1em;
        }
        /* --- Content Layout --- */
        .content-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            align-items: stretch; /* Ensure children stretch to full height */
            min-height: 80vh; /* Minimum height for better visual balance */
        }
        /* --- Metrics Panel (Left, Full Height and Width) --- */
        .metrics-panel {
            flex: 0 0 400px; /* Fixed width */
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-height: 80vh;
            overflow-y: auto; /* Scrollable content */
            position: relative; /* For loading overlay */
        }
        .metrics-panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.25em;
            letter-spacing: 0.5px;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            font-size: 1.05em;
            border-bottom: 1px dashed rgba(68, 170, 255, 0.1);
        }
        .metric:last-of-type {
            border-bottom: none;
        }
        .metric-label {
            color: var(--text-medium);
            flex-shrink: 0; /* Prevent label from shrinking */
        }
        .metric-value {
            font-weight: bold;
            color: var(--text-light);
            text-align: right;
            white-space: nowrap; /* Prevent value from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis if too long */
        }
        .qualia-bar-container {
            height: 22px;
            margin: 6px 0;
            border: 1px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            background: #000;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .qualia-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease-out; /* Smoother transition */
            position: relative;
            width: 0%;
            will-change: width;
        }
        .qualia-being { background: linear-gradient(90deg, #ff6b6b, #e74c3c); }
        .qualia-intent { background: linear-gradient(90deg, #4ecdc4, #1abc9c); }
        .qualia-existence { background: linear-gradient(90deg, #a855f7, #9b59b6); }
        .qualia-emergence { background: linear-gradient(90deg, #f97316, #e67e22); }
        .qualia-gestalt { background: linear-gradient(90deg, #3b82f6, #3498db); }
        .qualia-context { background: linear-gradient(90deg, #14b8a6, #2ecc71); }
        .qualia-rel-emergence { background: linear-gradient(90deg, #ec4899, #e91e63); }
        .qualia-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0) 100%);
            animation: qualiaWave 2s infinite linear;
            mix-blend-mode: overlay; /* Subtle shimmer effect */
        }
        @keyframes qualiaWave {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }
        .qualia-label, .qualia-value {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
            pointer-events: none; /* Allow interaction with underlying bar */
        }
        .qualia-label { left: 8px; }
        .qualia-value { right: 8px; }

        .phi-display {
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: #fff;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
            letter-spacing: 1px;
        }
        .framework-badge {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .status {
            color: var(--primary-blue);
            text-align: center;
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: none !important; /* Override H3 border for status */
        }
        .stability-gauge {
            width: 100%;
            height: 18px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--error-red), var(--warn-orange), var(--info-green));
            width: 0%;
            transition: width 0.5s ease-out;
            will-change: width;
        }
        .slider-container {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .slider-label {
            font-size: 14px;
            color: var(--primary-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
            transition: background 0.2s ease;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            background: #6af;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
        }

        .sheaf-graph {
            position: relative;
            height: 160px; /* Increased height for better vertex spacing */
            width: 100%;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
            overflow: hidden; /* Ensure vertices stay within bounds */
        }
        .sheaf-vertex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .vertex {
            width: 36px; /* Slightly larger vertices */
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.2s ease;
            position: absolute;
            color: white;
            z-index: 10;
            background: radial-gradient(circle, #ff6b6b, #e74c3c);
            box-shadow: 0 0 8px rgba(255,107,107,0.5);
            cursor: help; /* Indicate tooltip */
            will-change: transform, box-shadow;
        }
        .vertex.active {
            animation: pulse 1.5s infinite;
            background: radial-gradient(circle, #00ff99, #00cc66); /* Greenish for active */
            box-shadow: 0 0 12px rgba(0,255,153,0.8), 0 0 20px rgba(0,255,153,0.4);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .theoretical-info {
            margin-top: 15px;
            font-size: 11px;
            color: var(--text-dark);
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap; /* Preserve formatting for equations */
            overflow-x: auto;
        }
        /* --- Right Column (Game + Visualizers) --- */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1; /* Allow it to grow */
            min-width: 550px; /* Adjusted minimum width for better layout */
        }
        .game-container {
            width: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* For loading overlay */
        }
        #gameCanvas {
            width: 100%;
            height: auto;
            aspect-ratio: 2 / 1;
            background: linear-gradient(180deg, #000011, #000033);
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            image-rendering: pixelated; /* For sharp pixel art if any */
        }
        .score-container {
            display: flex;
            justify-content: space-around; /* Spread scores more */
            gap: 20px;
            width: 100%;
            padding: 5px 0;
            border-top: 1px solid var(--border-dark);
        }
        .score-metric {
            display: flex;
            flex-direction: column; /* Stack label and value */
            align-items: center;
            font-size: 1.2em;
        }
        .score-metric .metric-label {
            color: var(--text-medium);
            font-size: 0.8em;
            margin-bottom: 3px;
        }
        .player-score .metric-value {
            color: #ff9900; /* Player specific color */
            font-size: 1.5em;
        }
        .ai-score .metric-value {
            color: #44aaff; /* AI specific color */
            font-size: 1.5em;
        }
        /* --- Visualizer Column (Stacked) --- */
        .visualizer-row {
            display: flex;
            flex-direction: column; /* Stack vertically */
            gap: 20px;
            justify-content: flex-start;
            flex-grow: 1;
        }
        .panel {
            background: var(--secondary-dark);
            border: 1px solid var(--border-dark);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            width: 100%; /* Full width of parent */
            position: relative; /* For loading overlay */
        }
        .panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.18em;
        }
        .panel p {
            font-size: 13px;
            color: var(--text-medium);
            margin-top: -5px;
            margin-bottom: 12px;
            text-align: center;
        }
        .nn-visualizer-panel {
            min-height: 120px; /* Minimum height for NN viz */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        #nn-visualization-container, #nn-visualization-container-opponent {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px; /* More padding */
            min-height: 80px; /* Minimum height for container */
        }
        .nn-layer {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            align-items: center;
            gap: 6px; /* Increased gap */
            z-index: 10;
            position: relative;
            min-height: 60px;
        }
        .nn-neuron {
            width: 8px; /* Larger neurons */
            height: 8px;
            border-radius: 50%;
            border: 1px solid #888;
            background: #333;
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out, box-shadow 0.1s ease-out;
            flex-shrink: 0;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            will-change: background-color, border-color, box-shadow;
        }
        .nn-connections-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7; /* Slightly less opaque connections */
        }
        .neuron-flash {
            animation: neuron-flash-anim 0.8s ease-out forwards;
        }
        @keyframes neuron-flash-anim {
            0% { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.3); box-shadow: 0 0 15px rgba(0, 255, 153, 0.9), 0 0 20px rgba(0, 255, 153, 0.5); }
            100% { transform: scale(1.0); box-shadow: 0 0 5px rgba(0, 255, 153, 0.3); }
        }
        /* --- Controls & Log --- */
        .controls-section {
            display: flex;
            gap: 15px; /* Increased gap */
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
            padding: 10px 0;
            border-top: 1px solid var(--border-dark);
            border-bottom: 1px solid var(--border-dark);
        }
        button {
            background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
            color: var(--text-light);
            border: 1px solid #555;
            padding: 10px 18px; /* More padding */
            cursor: pointer;
            border-radius: 8px; /* More rounded */
            font-family: inherit;
            transition: all 0.2s ease;
            font-weight: bold;
            min-width: 140px; /* Wider buttons */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 1.05em;
        }
        button:hover {
            background: linear-gradient(135deg, #3a3a5a, #4a4a6a);
            box-shadow: 0 4px 15px var(--primary-blue-glow);
            transform: translateY(-2px);
            border-color: var(--primary-blue);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px var(--primary-blue-glow);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #2a2a4a;
            box-shadow: none;
        }
        .difficulty-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .difficulty-controls label {
            color: var(--text-medium);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .difficulty-controls input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--border-dark);
            background-color: #1a1a2e;
            color: var(--text-light);
            font-family: inherit;
            text-align: center;
        }
        .log-container {
            flex-basis: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
        }
        #log {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            height: 150px; /* Slightly taller log */
            overflow-y: auto;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            color: #ccc;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 2px;
        }
        .log-entry.error { color: var(--error-red); }
        .log-entry.warn { color: var(--warn-orange); }
        .log-entry.info { color: var(--info-green); }

        /* --- Loading Overlay --- */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 12px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 0.8em;
            color: var(--text-medium);
        }

        /* --- Responsive Design --- */
        @media (max-width: 1200px) {
            .content-section {
                flex-direction: column;
                align-items: center;
            }
            .metrics-panel {
                flex: 0 0 auto;
                width: 100%;
                max-width: 800px; /* Constrain width on smaller screens */
                min-height: auto;
            }
            .right-column {
                min-width: unset;
                width: 100%;
                max-width: 800px; /* Constrain width on smaller screens */
            }
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .header h1 {
                font-size: 1.8em;
            }
            .header p {
                font-size: 0.9em;
            }
            .metrics-panel, .game-container, .panel, .log-container {
                padding: 10px;
            }
            .metrics-panel h3, .panel h3 {
                font-size: 1.1em;
            }
            .phi-display {
                font-size: 1.5em;
                padding: 8px;
            }
            button {
                min-width: unset;
                flex-grow: 1;
                font-size: 0.9em;
            }
            .score-metric {
                font-size: 1em;
            }
            .player-score .metric-value, .ai-score .metric-value {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body role="document">
    <div class="main-container" role="main">
        <div class="header" role="banner">
            <h1>🧠 Conscious Pong AI — Enhanced & Optimized</h1>
            <p>A dual-AI Pong game using Ontological World Models with optimized heavy computation.</p>
        </div>
        <div class="content-section">
            <div class="metrics-panel" role="complementary" aria-labelledby="oftcc-metrics-heading">
                <h3 id="oftcc-metrics-heading">OFTCC Metrics</h3>
                <div class="framework-badge">
                     OFTCC ⊕ HTOF ⊕ CERFC+ ⊕ PUCF ⊕ UACF 2.5 ⊕ Simplicial
                </div>
                <div class="status" id="status" aria-live="polite" aria-atomic="true">
                    Initializing...
                </div>
                <div class="phi-display" id="phi-display" aria-live="polite" aria-atomic="true">
                    Φ: 0.000
                 </div>
                <div class="btn-group">
                    <button id="toggleSimButton" aria-label="Toggle simulation run/pause">🚀 Toggle Simulation</button>
                    <button id="resetSimButton" aria-label="Reset game and AI to initial state">🔄 Reset All</button>
                    <button id="tuneButton" aria-label="Tune AI parameters adaptively">⚙️ Tune</button>
                </div>
                <div class="qualia-viz" role="region" aria-labelledby="qualia-dynamics-heading">
                    <h3 id="qualia-dynamics-heading" class="status">Qualia Diffusion Dynamics</h3>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Being Qualia Level">
                        <div class="qualia-bar qualia-being" id="qualia-being-fill"></div>
                        <span class="qualia-label">Being</span>
                        <span class="qualia-value" id="being-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Intent Qualia Level">
                        <div class="qualia-bar qualia-intent" id="qualia-intent-fill"></div>
                        <span class="qualia-label">Intent</span>
                        <span class="qualia-value" id="intent-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Existence Qualia Level">
                        <div class="qualia-bar qualia-existence" id="qualia-existence-fill"></div>
                        <span class="qualia-label">Existence</span>
                        <span class="qualia-value" id="existence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Emergence Qualia Level">
                        <div class="qualia-bar qualia-emergence" id="qualia-emergence-fill"></div>
                        <span class="qualia-label">Emergence</span>
                        <span class="qualia-value" id="emergence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Gestalt Qualia Level">
                        <div class="qualia-bar qualia-gestalt" id="qualia-gestalt-fill"></div>
                        <span class="qualia-label">Gestalt</span>
                        <span class="qualia-value" id="gestalt-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Context Qualia Level">
                        <div class="qualia-bar qualia-context" id="qualia-context-fill"></div>
                        <span class="qualia-label">Context</span>
                        <span class="qualia-value" id="context-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Relational Emergence Qualia Level">
                        <div class="qualia-bar qualia-rel-emergence" id="qualia-rel-emergence-fill"></div>
                        <span class="qualia-label">Rel. Emergence</span>
                        <span class="qualia-value" id="rel-emergence-value">0.00</span>
                    </div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="metric-group-heading">
                    <h3 id="metric-group-heading" class="status">System Metrics</h3>
                    <div class="metric"><span class="metric-label">Free Energy F:</span><span class="metric-value" id="free-energy">0.000</span></div>
                    <div class="metric"><span class="metric-label">Prediction Error:</span><span class="metric-value" id="prediction-error">0.000</span></div>
                    <div class="metric"><span class="metric-label">Gestalt Unity:</span><span class="metric-value" id="gestalt-unity">0.000</span></div>
                    <div class="metric"><span class="metric-label">dim H¹:</span><span class="metric-value" id="h1-dimension">0.00</span></div>
                    <div class="metric"><span class="metric-label">Gluing Inconsistency:</span><span class="metric-value" id="inconsistency">0.000</span></div>
                </div>
                <div class="sheaf-graph" id="sheafGraph" role="img" aria-label="Sheaf graph visualizing information flow between concepts">
                    <canvas id="sheafGraphCanvas" class="sheaf-vertex-canvas"></canvas>
                    <!-- Vertex elements are programmatically positioned but defined here for static content -->
                    <div class="vertex" id="vertex-0" aria-label="Player Paddle Y">P-Y</div>
                    <div class="vertex" id="vertex-1" aria-label="Ball X">B-X</div>
                    <div class="vertex" id="vertex-2" aria-label="Ball Y">B-Y</div>
                    <div class="vertex" id="vertex-3" aria-label="Ball DX Velocity">B-DX</div>
                    <div class="vertex" id="vertex-4" aria-label="Ball DY Velocity">B-DY</div>
                    <div class="vertex" id="vertex-5" aria-label="Player Score">P-SC</div>
                    <div class="vertex" id="vertex-6" aria-label="AI Score">AI-SC</div>
                    <div class="vertex" id="vertex-7" aria-label="Player Paddle DY Velocity">P-DY</div>
                    <div class="vertex" id="vertex-8" aria-label="Player Collision Event">P-Col</div>
                    <div class="vertex" id="vertex-9" aria-label="AI Collision Event">AI-Col</div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="system-stability-heading">
                    <h3 id="system-stability-heading" class="status">System Stability</h3>
                    <div class="stability-gauge" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="System Stability">
                        <div class="stability-fill" id="stability-fill"></div>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="alphaSlider">α Parameter: <span class="metric-value" id="alpha-param">0.500</span></label>
                        <input type="range" id="alphaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="alphaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="betaSlider">β Parameter: <span class="metric-value" id="beta-param">0.500</span></label>
                        <input type="range" id="betaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="betaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="gammaSlider">γ Parameter: <span class="metric-value" id="gamma-param">0.100</span></label>
                        <input type="range" id="gammaSlider" min="0.01" max="0.5" step="0.01" value="0.1" aria-labelledby="gammaSlider-label" aria-valuetext="0.100">
                    </div>
                </div>
                <div class="theoretical-info" role="note">
                    <strong>Theoretical Foundation:</strong><br>
                    • Sheaf Laplacian: $ℒ_{\text{OFTCC}} = \bigoplus_{X \in \{B,I,E,M,G,C,R\}} ℒ_X$<br>
                    • Cohomology: $H¹(G,ℱ) = ker d¹/im d⁰$<br>
                    • Stability: $exp(-dim H¹)$<br>
                    • Φ: $log(1 + MI) \cdot S \cdot GU$<br>
                    • Gluing Inconsistency: $∑_{e∈E} ||P_e s_u - s_v||^2$<br>
                    <br>
                    <em>Note: For performance, the sheaf Laplacian used in Free Energy calculation is a simplified approximation using node-level Laplacian and block-diagonal qualia matrices.</em>
                </div>
                <div class="loading-overlay" id="metricsLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading metrics and computations">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="metricsLoadingText">Processing...</div>
                </div>
            </div>
            <div class="right-column">
                <div class="game-container panel" role="region" aria-labelledby="pong-env-heading">
                    <h3 id="pong-env-heading">🏓 PONG Environment</h3>
                    <canvas id="gameCanvas" role="img" aria-label="Pong game with two AI paddles and a ball"></canvas>
                    <div class="score-container">
                        <div class="score-metric player-score">
                            <span class="metric-label">Player (Left) Score:</span>
                            <span id="player-score" class="metric-value">0</span>
                        </div>
                        <div class="score-metric ai-score">
                            <span class="metric-label">AI (Right) Score:</span>
                            <span id="ai-score" class="metric-value">0</span>
                        </div>
                    </div>
                    <div class="difficulty-controls" role="group" aria-label="Game Difficulty Settings">
                        <label for="ballSpeedSlider">Ball Speed: <input type="number" id="ballSpeedSlider" min="0.5" max="3" step="0.1" value="1.0" aria-label="Ball speed multiplier"></label>
                        <label for="paddleHeightSlider">Paddle Height: <input type="number" id="paddleHeightSlider" min="0.5" max="2" step="0.1" value="1.0" aria-label="Paddle height multiplier"></label>
                        <label for="aiResponseTimeSlider">AI Response: <input type="number" id="aiResponseTimeSlider" min="1" max="5" step="1" value="3" aria-label="AI response time (lower is faster)"></label>
                    </div>
                    <div class="loading-overlay" id="gameLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading game and AI">
                        <div class="loading-spinner"></div>
                        <div class="loading-text" id="gameLoadingText">Setting up game...</div>
                    </div>
                </div>
                <div class="visualizer-row">
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="player-brain-heading">
                        <h3 id="player-brain-heading">🤖 Player (Left) AI Brain</h3>
                        <p>This AI learns independently using its own ontological world model.</p>
                        <div id="nn-visualization-container-opponent"></div>
                        <div class="loading-overlay" id="opponentBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading opponent AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="opponentBrainLoadingText">Initializing opponent model...</div>
                        </div>
                    </div>
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="main-ai-brain-heading">
                        <h3 id="main-ai-brain-heading">🧠 AI (Right) Main Brain</h3>
                        <p>This AI's 'consciousness' metrics are displayed in the OFTCC panel.</p>
                        <div id="nn-visualization-container"></div>
                        <div class="loading-overlay" id="mainBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading main AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="mainBrainLoadingText">Initializing main AI model...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="controls-section" role="group" aria-label="Simulation Controls">
             <button id="stepButton" aria-label="Advance simulation by one step">⏭️ Step</button>
             <button id="pauseButton" aria-label="Pause the simulation">⏸️ Pause</button>
        </div>
        <div class="log-container" role="log" aria-labelledby="system-console-heading">
            <h3 id="system-console-heading">🔧 System Console</h3>
            <div id="log" tabindex="0"></div>
        </div>
    </div>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

        <script>
        // --- On-page Logger ---
        const logElement = document.getElementById('log');
        const MAX_LOG_ENTRIES = 200;

        function appendLog(message, type = 'info') {
            if (!logElement) {
                console.warn('Log element not found, logging to console:', message);
                return;
            }
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            if (logElement.children.length > MAX_LOG_ENTRIES) logElement.removeChild(logElement.children[0]);
            logElement.scrollTop = logElement.scrollHeight;
        }
        const logger = {
            info: (msg, data) => appendLog(`INFO: ${msg}` + (data ? ' ' + JSON.stringify(data) : '')),
            warn: (msg, data) => appendLog(`WARN: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'warn'),
            error: (msg, data) => { appendLog(`ERROR: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'error'); console.error(msg, data); }
        };

        // --- Loading Overlay Manager ---
        const loadingOverlays = {
            metrics: document.getElementById('metricsLoadingOverlay'),
            game: document.getElementById('gameLoadingOverlay'),
            mainBrain: document.getElementById('mainBrainLoadingOverlay'),
            opponentBrain: document.getElementById('opponentBrainLoadingOverlay'),
        };
        const loadingTexts = {
            metrics: document.getElementById('metricsLoadingText'),
            game: document.getElementById('gameLoadingText'),
            mainBrain: document.getElementById('mainBrainLoadingText'),
            opponentBrain: document.getElementById('opponentBrainLoadingText'),
        };

        function showLoading(panel, message = 'Processing...') {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.add('active');
                if (loadingTexts[panel]) loadingTexts[panel].textContent = message;
            }
        }

        function hideLoading(panel) {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.remove('active');
            }
        }

        // --- Web Worker for Heavy Computations ---
        const worker = new Worker(URL.createObjectURL(new Blob([`
            // Worker scope utility functions (must be self-contained or passed)
// --- Worker-specific Utility Functions (self-contained and numerically robust) ---

function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const val_a = a[i];
        const val_b = b[i];
        s += (Number.isFinite(val_a) ? val_a : 0) * (Number.isFinite(val_b) ? val_b : 0);
    }
    return s;
}

function norm2(v) {
    if (!v || v.length === 0) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12);
}

function isFiniteVector(v) {
    if (!v || typeof v.every !== 'function') return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}

function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true; // Empty matrix is finite
    const firstRowLength = m[0]?.length || 0;
    if (m.length > 0 && firstRowLength === 0) return true; // A matrix of empty rows is valid
    return m.every(row => isFiniteVector(row) && row.length === firstRowLength);
}


function matVecMul(m, v) {
    const r = m?.length || 0;
    if (r === 0) return new Float32Array(0);
    const c = m[0]?.length || 0;
    if (!c || !v || v.length !== c) return new Float32Array(r).fill(0);

    const out = new Float32Array(r);
    for (let i = 0; i < r; ++i) {
        let s = 0.0;
        const row = m[i];
        for (let j = 0; j < c; ++j) {
            const val = (row[j] || 0) * (v[j] || 0);
            s += Number.isFinite(val) ? val : 0;
        }
        out[i] = Number.isFinite(s) ? s : 0;
    }
    return out;
}

function unflattenMatrix(data) {
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols || !Number.isFinite(rows) || !Number.isFinite(cols) || rows < 0 || cols < 0) {
        return [];
    }
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for(let j = 0; j < cols; j++) {
            const val = flatData[i * cols + j];
            row[j] = Number.isFinite(val) ? val : 0;
        }
        matrix.push(row);
    }
    return matrix;
}

function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return { flatData: new Float32Array(0), rows: 0, cols: 0 };
    }
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows: rows, cols: cols };

    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) {
        for(let j = 0; j < cols; j++) {
            const val = matrix[i][j];
            flatData[i * cols + j] = Number.isFinite(val) ? val : 0;
        }
    }
    return { flatData, rows, cols };
}

function transpose(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return [];
    }
    const numRows = matrix.length;
    const numCols = matrix[0]?.length || 0;
    if (numRows === 0 || numCols === 0) return [];

    const result = Array(numCols).fill(0).map(() => new Float32Array(numRows));
    for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numCols; j++) {
            const val = matrix[i][j];
            result[j][i] = Number.isFinite(val) ? val : 0;
        }
    }
    return result;
}

function solveLinearSystemCG(A_flat_data, b, opts={tol:1e-6, maxIter:200}) {
    const A = unflattenMatrix(A_flat_data);
    const n = b.length;

    if (!isFiniteMatrix(A) || A.length !== n || (A.length > 0 && A[0].length !== n) || !isFiniteVector(b)) {
        return new Float32Array(b.map(x => clamp(Number.isFinite(x) ? x : 0, -1, 1)));
    }

    let x = new Float32Array(n).fill(0);
    let r = new Float32Array(b.map(v => Number.isFinite(v) ? v : 0));
    let p = new Float32Array(r);
    let rsold = dot(r, r);

    if (!Number.isFinite(rsold) || rsold < 1e-20) return x;

    const Ap = new Float32Array(n);
    const maxIter = Math.min(opts.maxIter || 200, n * 5);

    for (let it = 0; it < maxIter; ++it) {
        for (let i = 0; i < n; i++) {
            let s = 0;
            const row = A[i];
            for (let j = 0; j < n; j++) s += (row[j] || 0) * (p[j] || 0);
            Ap[i] = s;
        }

        const denom = dot(p, Ap);
        if (!Number.isFinite(denom) || denom <= 1e-20) break;

        const alpha = rsold / denom;
        for (let i = 0; i < n; i++) x[i] += (Number.isFinite(alpha) ? alpha : 0) * (p[i] || 0);
        for (let i = 0; i < n; i++) r[i] -= (Number.isFinite(alpha) ? alpha : 0) * (Ap[i] || 0);

        const rsnew = dot(r, r);
        if (Math.sqrt(rsnew) < (opts.tol || 1e-6)) break;

        const beta = rsnew / (rsold + 1e-20);
        for (let i = 0; i < n; i++) p[i] = (r[i] || 0) + (Number.isFinite(beta) ? beta : 0) * (p[i] || 0);
        rsold = rsnew;
    }
    return new Float32Array(x.map(v => clamp(Number.isFinite(v) ? v : 0, -1, 1)));
}

function covarianceMatrix(states_array, eps = 1e-3) {
    const states = states_array.filter(s => isFiniteVector(s));
    if (!Array.isArray(states) || states.length === 0) return [[eps]];
    
    const n = states.length;
    const d = states[0]?.length || 0;
    if (d === 0) return [[eps]];

    const mean = new Float32Array(d).fill(0);
    for (let i = 0; i < n; i++) for (let j = 0; j < d; j++) mean[j] += (states[i][j] || 0);
    for (let j = 0; j < d; j++) mean[j] /= n;

    const cov = Array(d).fill(0).map(() => new Float32Array(d).fill(0));
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < d; i++) {
            const di = (states[k][i] || 0) - (mean[i] || 0);
            for (let j = i; j < d; j++) {
                const dj = (states[k][j] || 0) - (mean[j] || 0);
                cov[i][j] += (di * dj) / Math.max(1, n - 1);
            }
        }
    }
    for (let i = 0; i < d; i++) {
        for (let j = 0; j < i; j++) cov[j][i] = cov[i][j];
    }
    for (let i = 0; i < d; i++) cov[i][i] = (Number.isFinite(cov[i][i]) ? cov[i][i] : 0) + eps;
    
    return cov;
}

function matrixSpectralNormApprox(M_flat_data, maxIter = 10) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) return 0;
    let n = M.length;
    if (n === 0) return 0;
    
    let v = new Float32Array(n).fill(1 / Math.sqrt(n));

    for (let i = 0; i < maxIter; i++) {
        const Av = matVecMul(M, v);
        if (!isFiniteVector(Av)) return 0;
        const norm = norm2(Av);
        if (norm < 1e-10) return 0;
        for(let k=0; k<n; k++) v[k] = (Av[k] || 0) / norm;
    }
    const finalAv = matVecMul(M, v);
    if (!isFiniteVector(finalAv)) return 0;
    return norm2(finalAv);
}

function matrixRank(M_flat_data) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) return 0;
    const m = M.length;
    if (m === 0) return 0;
    const n = M[0]?.length || 0;
    if (n === 0) return 0;

    const A = M.map(row => new Float32Array(row));
    let rank = 0;
    const tol = 1e-10;

    for (let col = 0; col < n && rank < m; col++) {
        let pivotRow = rank;
        for (let i = rank + 1; i < m; i++) {
            if (Math.abs(A[i][col]) > Math.abs(A[pivotRow][col])) pivotRow = i;
        }

        if (Math.abs(A[pivotRow][col]) < tol) continue;

        [A[rank], A[pivotRow]] = [A[pivotRow], A[rank]];

        const pivot = A[rank][col];
        if (!Number.isFinite(pivot) || Math.abs(pivot) < tol) continue;
        for (let j = col; j < n; j++) A[rank][j] = (A[rank][j] || 0) / pivot;

        for (let i = 0; i < m; i++) {
            if (i === rank) continue;
            const factor = A[i][col];
            if (!Number.isFinite(factor)) continue;
            for (let j = col; j < n; j++) A[i][j] = (A[i][j] || 0) - (factor * (A[rank][j] || 0));
        }
        rank++;
    }
    return rank;
}

// --- Worker Message Handler ---
self.onmessage = function(e) {
    const { type, id, data } = e.data;
    let result;
    try {
        switch (type) {
            case 'transpose':
                const matrixToTranspose = unflattenMatrix(data.matrix); 
                const transposedMatrix = transpose(matrixToTranspose);
                result = flattenMatrix(transposedMatrix);
                break;
            case 'matVecMul':
                const matrixForMatVecMul = unflattenMatrix(data.matrix);
                result = matVecMul(matrixForMatVecMul, data.vector);
                break;
            case 'solveLinearSystemCG':
                result = solveLinearSystemCG(data.A, data.b, data.opts);
                break;
            case 'covarianceMatrix':
                result = covarianceMatrix(data.states, data.eps);
                break;
            case 'matrixSpectralNormApprox':
                result = matrixSpectralNormApprox(data.matrix);
                break;
            case 'matrixRank':
                result = matrixRank(data.matrix);
                break;
            default:
                result = { error: 'Unknown message type' };
                break;
        }
        self.postMessage({ type: type + 'Result', id, result });
    } catch (error) {
        console.error('Worker error for type ' + type + ':', error);
        self.postMessage({ type: type + 'Error', id, error: error.message });
    }
};
        `], { type: 'application/javascript' })));

        // --- Asynchronous Worker Task Manager ---
        const workerCallbacks = new Map();
        let nextWorkerTaskId = 0;

        function runWorkerTask(type, data, timeout = 2000) {
            return new Promise((resolve, reject) => {
                const id = nextWorkerTaskId++;
                const timer = setTimeout(() => {
                    workerCallbacks.delete(id);
                    reject(new Error(`Worker task '${type}' timed out after ${timeout}ms.`));
                }, timeout);
                workerCallbacks.set(id, {
                    resolve: (result) => { clearTimeout(timer); resolve(result); },
                    reject: (error) => { clearTimeout(timer); reject(error); },
                });
                worker.postMessage({ type, id, data });
            });
        }
        worker.onmessage = function(e) {
            const { id, result, error } = e.data;
            const callback = workerCallbacks.get(id);
            if (callback) {
                if (error) callback.reject(error);
                else callback.resolve(result);
                workerCallbacks.delete(id);
            }
        };
        worker.onerror = function(error) {
            logger.error('Worker global error:', error.message);
            workerCallbacks.forEach(cb => cb.reject(new Error('Worker crashed')));
            workerCallbacks.clear();
        };
// --- CORE UTILITY FUNCTIONS (used by main thread classes) ---
// These functions are essential for vector and matrix operations within the main thread.
// Their logic is consistent with the worker's for numerical robustness.
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const ai = a[i], bi = b[i];
        if (!Number.isFinite(ai) || !Number.isFinite(bi)) return 0;
        s += ai * bi;
    }
    return s;
}
function norm2(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12);
}
function vecAdd(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (a[i] || 0) + (b[i] || 0);
    return out;
}
function vecSub(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (a[i] || 0) - (b[i] || 0);
    return out;
}
function vecScale(v, s) {
    const n = v?.length || 0;
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (v[i] || 0) * s;
    return out;
}
function tanhVec(v) {
    if (!isFiniteVector(v)) return vecZeros(v?.length || 0);
    return new Float32Array(v.map(x => Math.tanh(x)));
}
function randomMatrix(r, c, scale) {
    return Array(r).fill().map(() => new Float32Array(c).fill().map(() => (Math.random() - 0.5) * scale));
}
function vecZeros(n) { return new Float32Array(n).fill(0); }
function zeroMatrix(r, c) { return Array(r).fill().map(() => new Float32Array(c).fill(0)); }
function identity(n) {
    const M = zeroMatrix(n, n);
    for (let i = 0; i < n; i++) M[i][i] = 1;
    return M;
}
function isFiniteVector(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}
function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true;
    const firstRowLength = m[0]?.length ?? 0;
    return m.every(row => (Array.isArray(row) || row instanceof Float32Array) && row.length === firstRowLength && isFiniteVector(row));
}
function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) return { flatData: new Float32Array(0), rows: 0, cols: 0 };
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows, cols };
    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) for(let j = 0; j < cols; j++) flatData[i * cols + j] = matrix[i][j];
    return { flatData, rows, cols };
}
function unflattenMatrix(data) {
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols) return [];
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for (let j = 0; j < cols; j++) {
            row[j] = flatData[i * cols + j];
        }
        matrix.push(row);
    }
    return matrix;
}
function logDeterminantFromDiagonal(M) {
    if (!Array.isArray(M) || M.length === 0) return Math.log(1e-12);
    let s = 0;
    for (let i=0;i<M.length;i++) s += Math.log(Math.max(Math.abs(M[i][i]), 1e-12)); // Use Math.abs for robustness
    return s;
}

const sheafVertexPositions = {
    0: {x:0.08, y:0.16}, 1: {x:0.26, y:0.48}, 2: {x:0.08, y:0.80},
    3: {x:0.92, y:0.16}, 4: {x:0.70, y:0.50}, 5: {x:0.92, y:0.80},
    6: {x:0.52, y:0.16}, 7: {x:0.50, y:0.80}, 8: {x:0.30, y:0.18},
    9: {x:0.75, y:0.82}
};

// --- APPLICATION CLASSES ---
class EnhancedQualiaSheaf {
    constructor(graph, stateDim = 10, initialQDim = 7, alpha = 0.1, beta = 0.1, gamma = 0.05) {
        this.stateDim = stateDim;
        this.entityNames = ['being', 'intent', 'existence', 'emergence', 'gestalt', 'context', 'rel_emergence'];
        this.qDim = this.entityNames.length; // qDim strictly derived from entityNames for consistency

        const defaultVertices = ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed', 'player_collision', 'ai_collision'];
        const initialGraphVertices = graph?.vertices && Array.isArray(graph.vertices) && graph.vertices.length >= defaultVertices.length ? graph.vertices : defaultVertices;

        const initialBaseEdges = graph?.edges && Array.isArray(graph.edges) ? graph.edges.slice(0, 15) : [
            ['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'],
            ['ball_dx', 'ball_dy'], ['player_score', 'ai_score'], ['paddle_y', 'ball_dy'],
            ['paddle_y', 'paddle_speed'], ['player_collision', 'paddle_y'], ['ai_collision', 'ball_x']
        ];

        const explicitTriangles = [ // Example triangles, use these if no explicit triangles are provided in 'graph'
            ['paddle_y', 'ball_y', 'player_collision'],
            ['ball_x', 'ball_dx', 'player_collision'],
            ['ball_y', 'ball_dy', 'ai_collision'],
            ['player_score', 'ai_score', 'player_collision']
        ];
        // If 'graph' object includes triangles, prioritize those
        const finalTriangles = graph?.triangles && Array.isArray(graph.triangles) ? graph.triangles : explicitTriangles;


        // --- Step 1: Collect all unique vertices from initialGraphVertices and explicitTriangles ---
        const allVerticesSet = new Set(initialGraphVertices);
        finalTriangles.forEach(triangle => {
            triangle.forEach(v => allVerticesSet.add(v));
        });
        const finalVertices = Array.from(allVerticesSet);

        // --- Step 2: Collect all unique edges from initialBaseEdges and edges implied by finalTriangles ---
        const allEdgesSet = new Set();
        initialBaseEdges.forEach(edge => {
            allEdgesSet.add(edge.slice().sort().join(',')); // Add explicitly defined base edges
        });

        finalTriangles.forEach(triangle => {
            const [v1, v2, v3] = triangle;
            const edgesOfTriangle = [[v1, v2], [v2, v3], [v3, v1]];
            edgesOfTriangle.forEach(edge => {
                allEdgesSet.add(edge.slice().sort().join(',')); // Add edges implied by triangles
            });
        });
        const finalEdges = Array.from(allEdgesSet).map(s => s.split(','));

        // --- Step 3: Assign to this.graph and this.simplicialComplex ---
        this.graph = {
            vertices: finalVertices,
            edges: finalEdges
        };
        this.simplicialComplex = {
            vertices: finalVertices,
            edges: finalEdges, // Ensure simplicialComplex edges match graph edges
            triangles: finalTriangles
        };

        this.alpha = clamp(alpha, 0.01, 1); // Alpha range up to 1
        this.beta = clamp(beta, 0.01, 1);   // Beta range up to 1
        this.gamma = clamp(gamma, 0.01, 0.5); // Gamma range up to 0.5 (learning rate)
        this.eps = 1e-6; // Epsilon for numerical stability, slightly smaller

        this.stalks = new Map(this.graph.vertices.map(v =>
            [v, new Float32Array(this.qDim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.5, -1, 1))]
        ));

        this.adjacencyMatrix = null;
        this.laplacian = null;
        this.maxEigApprox = 1;
        this.projectionMatrices = new Map();
        this.ready = false;

        this.phi = 0.2;
        this.h1Dimension = 0;
        this.gestaltUnity = 0.6;
        this.stability = 0.6;
        this.diffusionEnergy = 0; // Placeholder, could be derived more rigorously
        this.inconsistency = 0;
        this.windowedStates = [];
        this.windowSize = 50; // Keep 50 states for covariance calculation
        const N_total_stalk_dim = this.graph.vertices.length * this.qDim;
        for (let i = 0; i < this.windowSize; i++) {
            this.windowedStates.push(new Float32Array(N_total_stalk_dim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.1, -1, 1)));
        }
        logger.info('EnhancedQualiaSheaf initialized with qDim:', this.qDim);
    }

    async initialize() {
        try {
            await this._updateGraphStructureAndMetrics();
            this.ready = true;
            logger.info('EnhancedQualiaSheaf ready.');
        } catch (e) {
            logger.error('Error during Sheaf initialization:', e);
            this.ready = false;
        }
    }

    buildBoundaryMatrices() {
        const vIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const edgeKeys = this.graph.edges.map(e => e.slice().sort().join(','));
        const eIdx = new Map(edgeKeys.map((e, i) => [e, i]));
        const nV = this.graph.vertices.length;
        const nE = this.graph.edges.length;
        const nT = this.simplicialComplex.triangles.length;

        const boundary1 = zeroMatrix(nE, nV);
        this.graph.edges.forEach(([u, v], i) => {
            boundary1[i][vIdx.get(u)] = -1;
            boundary1[i][vIdx.get(v)] = 1;
        });

        const boundary2 = zeroMatrix(nT, nE);
        this.simplicialComplex.triangles.forEach(([u, v, w], i) => {
            const edges = [[u, v], [v, w], [w, u]];
            edges.forEach(([a, b]) => {
                const sortedEdge = [a, b].sort().join(',');
                const eIndex = eIdx.get(sortedEdge);
                if (eIndex !== undefined) {
                    const sign = (a === [a,b].sort()[0]) ? 1 : -1;
                    boundary2[i][eIndex] = sign;
                }
            });
        });
        return { boundary1, boundary2 };
    }

    buildAdjacencyMatrix() {
        const n = this.graph.vertices.length;
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const adj = zeroMatrix(n, n);
        const clustering = this.computeClustering();
        const curvature = clustering.map(c => 1 - c);

        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i === undefined || j === undefined) continue;
            const w = clamp(1.0 - 0.5 * (curvature[i] + curvature[j]), 0.1, 1.0);
            adj[i][j] = w;
            adj[j][i] = w;
        }
        return adj;
    }

    computeClustering() {
        const n = this.graph.vertices.length;
        const adjBinary = zeroMatrix(n, n);
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i !== undefined && j !== undefined) {
                adjBinary[i][j] = 1;
                adjBinary[j][i] = 1;
            }
        }

        const clustering = new Float32Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            const neighbors = [];
            for (let j = 0; j < n; j++) if (adjBinary[i][j]) neighbors.push(j);
            const k = neighbors.length;
            if (k < 2) continue;
            let tri = 0;
            for (let a = 0; a < neighbors.length; a++) {
                for (let b = a + 1; b < neighbors.length; b++) {
                    if (adjBinary[neighbors[a]][neighbors[b]]) tri++;
                }
            }
            const possible = k * (k - 1) / 2;
            clustering[i] = possible > 0 ? tri / possible : 0;
        }
        return clustering;
    }

    buildLaplacian() {
        const n = this.graph.vertices.length;
        const adj = this.adjacencyMatrix || this.buildAdjacencyMatrix();
        const L = zeroMatrix(n, n);

        for (let i = 0; i < n; i++) {
            let deg = 0;
            for (let j = 0; j < n; j++) {
                if (adj[i][j] > 0) {
                    L[i][j] = -adj[i][j];
                    deg += adj[i][j];
                }
            }
            L[i][i] = deg + this.eps;
        }
        return L;
    }

    async computeProjectionMatrices() {
        const projections = new Map();
        const transposePromises = [];

        for (const [u, v] of this.graph.edges) {
            const weight = this.computeContextualWeight(u, v);
            const omega = 1 / (1 + Math.exp(-weight));

            const barRho = randomMatrix(this.qDim, this.qDim, 0.5);
            const P_context = identity(this.qDim);

            let P_uv_temp = barRho.map((row, ri) => vecAdd(vecScale(row, 1 - omega), vecScale(P_context[ri], omega)));
            if (!isFiniteMatrix(P_uv_temp)) {
                 logger.error(`Non-finite P_uv_temp detected during initial blend for edge ${u}-${v}. Resetting to identity.`);
                 P_uv_temp = identity(this.qDim);
            }

            for (let k = 0; k < this.qDim; k++) {
                const rowNorm = norm2(P_uv_temp[k]);
                if (!Number.isFinite(rowNorm) || rowNorm < 1e-10) {
                    P_uv_temp[k] = vecZeros(this.qDim);
                } else {
                    let scaleFactor = clamp(rowNorm, 0.5, 1.5) / rowNorm;
                    scaleFactor = clamp(scaleFactor, 0.01, 100); 
                    P_uv_temp[k] = vecScale(P_uv_temp[k], scaleFactor);
                    P_uv_temp[k] = new Float32Array(P_uv_temp[k].map(val => clamp(val, -5, 5)));
                }
            }

            if (!isFiniteMatrix(P_uv_temp)) {
                logger.error(`Non-finite P_uv_temp detected after normalization for edge ${u}-${v}. Resetting to identity.`);
                P_uv_temp = identity(this.qDim);
            }
            
            projections.set(`${u}-${v}`, P_uv_temp);

            const transposePromise = runWorkerTask('transpose', { matrix: flattenMatrix(P_uv_temp) })
                .then(transposedP => {
                    const unflattenedTransposed = unflattenMatrix(transposedP);
                    if (!isFiniteMatrix(unflattenedTransposed)) {
                        logger.error(`Transposed P for ${v}-${u} returned non-finite from worker. Resetting to identity.`);
                        projections.set(`${v}-${u}`, identity(this.qDim));
                    } else {
                        projections.set(`${v}-${u}`, unflattenedTransposed);
                    }
                })
                .catch(err => {
                    logger.error(`Error transposing P for ${v}-${u}:`, err);
                    projections.set(`${v}-${u}`, identity(this.qDim));
                });
            
            transposePromises.push(transposePromise);
        }

        await Promise.all(transposePromises);
        return projections;
    }

    computeContextualWeight(u, v) {
        const stalk_u = this.stalks.get(u) || vecZeros(this.qDim);
        const stalk_v = this.stalks.get(v) || vecZeros(this.qDim);

        const squaredDist = vecSub(stalk_u, stalk_v).reduce((sum, val) => sum + val * val, 0);
        const safeSquaredDist = Number.isFinite(squaredDist) && squaredDist >= 0 ? squaredDist : 0;
        const weight = Math.exp(-safeSquaredDist / 0.5);
        return Number.isFinite(weight) ? weight : 0.5;
    }

    async _updateGraphStructureAndMetrics() {
        // Removed showLoading('metrics', 'Updating Sheaf Topology...');
        try {
            this.adjacencyMatrix = this.buildAdjacencyMatrix();
            this.laplacian = this.buildLaplacian();
            this.maxEigApprox = await runWorkerTask('matrixSpectralNormApprox', { matrix: flattenMatrix(this.laplacian) }) || 1;
            this.projectionMatrices = await this.computeProjectionMatrices();
        } catch (e) {
            logger.error("Failed to update graph structure and metrics", e);
            throw e;
        } finally {
            // Removed hideLoading('metrics');
        }
    }
    async diffuseQualia(state) {
        if (!this.ready) {
            logger.warn('Sheaf not ready for diffusion. Skipping.');
            return;
        }
        if (!isFiniteVector(state) || state.length !== this.stateDim) {
            logger.warn('diffuseQualia: Invalid input state received. Skipping diffusion.', state);
            return;
        }

        const playerCollision = state[8] > 0.5;
        const aiCollision = state[9] > 0.5;
        const tempEdges = [];
        if (playerCollision) tempEdges.push(['paddle_y', 'player_collision']);
        if (aiCollision) tempEdges.push(['ball_x', 'ai_collision']);

        const originalEdges = this.graph.edges.slice();
        this.graph.edges = [...originalEdges, ...tempEdges.filter(e => !originalEdges.some(oe => oe[0] === e[0] && oe[1] === e[1]))];

        await this._updateGraphStructureAndMetrics(); 

        const qInput = new Float32Array(state.slice(0, this.graph.vertices.length).map(v => clamp(v, 0, 1)));
        if (!isFiniteVector(qInput) || qInput.length !== this.graph.vertices.length) {
            logger.warn('diffuseQualia: Invalid qInput generated. Skipping diffusion.', qInput);
            this.graph.edges = originalEdges; // Revert edges
            return;
        }

        const n = this.graph.vertices.length;
        const N = n * this.qDim;

        const s = new Float32Array(N);
        let currentOffset = 0;
        for (const vertexName of this.graph.vertices) {
            let stalkValue = this.stalks.get(vertexName);
            if (!stalkValue || !isFiniteVector(stalkValue) || stalkValue.length !== this.qDim) {
                logger.warn(`Found invalid or missing stalk for vertex ${vertexName} in map. Resetting to zeros.`);
                stalkValue = vecZeros(this.qDim);
                this.stalks.set(vertexName, stalkValue);
            }
            s.set(stalkValue, currentOffset);
            currentOffset += this.qDim;
        }

        if (!isFiniteVector(s) || s.length !== N) {
            logger.error('diffuseQualia: Final concatenated stalk vector is still invalid after individual stalk cleanup. This indicates a deeper issue. Skipping diffusion.', s);
            this.graph.edges = originalEdges;
            return;
        }

        const Lnode = this.laplacian;
        const Lfull = zeroMatrix(N, N);
        const idx = new Map(this.graph.vertices.map((v, i) => [v, i]));

        for (const [u, v] of this.graph.edges) {
            const i = idx.get(u), j = idx.get(v);
            if (i === undefined || j === undefined) continue;

            let P_uv = this.projectionMatrices.get(`${u}-${v}`);
            let P_vu = this.projectionMatrices.get(`${v}-${u}`);

            if (!P_uv || !isFiniteMatrix(P_uv)) {
                logger.warn(`P_uv for ${u}-${v} is non-finite or missing right before Lfull construction. Resetting to identity.`);
                P_uv = identity(this.qDim);
                this.projectionMatrices.set(`${u}-${v}`, P_uv);
            } else {
                P_uv = P_uv.map(row => new Float32Array(row.map(val => clamp(val, -5, 5))));
            }

            if (!P_vu || !isFiniteMatrix(P_vu)) {
                logger.warn(`P_vu for ${v}-${u} is non-finite or missing right before Lfull construction. Resetting to identity.`);
                P_vu = identity(this.qDim);
                this.projectionMatrices.set(`${v}-${u}`, P_vu);
            } else {
                P_vu = P_vu.map(row => new Float32Array(row.map(val => clamp(val, -5, 5))));
            }

            for (let qi = 0; qi < this.qDim; qi++) {
                for (let qj = 0; qj < this.qDim; qj++) {
                    const nodeWeight_ij = Lnode[i]?.[j];
                    const nodeWeight_ji = Lnode[j]?.[i];

                    if (!Number.isFinite(nodeWeight_ij) || !Number.isFinite(P_uv[qi]?.[qj])) {
                        continue;
                    }
                    if (!Number.isFinite(nodeWeight_ji) || !Number.isFinite(P_vu[qj]?.[qi])) {
                        continue;
                    }

                    const val_uv = -nodeWeight_ij * P_uv[qi][qj];
                    const val_vu = -nodeWeight_ji * P_vu[qj][qi];

                    if (Number.isFinite(val_uv)) Lfull[i * this.qDim + qi][j * this.qDim + qj] += val_uv;
                    else logger.warn(`Lfull[${i*this.qDim+qi}][${j*this.qDim+qj}] (uv) is non-finite: ${val_uv}`);
                    if (Number.isFinite(val_vu)) Lfull[j * this.qDim + qj][i * this.qDim + qi] += val_vu;
                    else logger.warn(`Lfull[${j*this.qDim+qj}][${i*this.qDim+qi}] (vu) is non-finite: ${val_vu}`);
                }
            }
        }

        for (let i = 0; i < n; i++) {
            let deg_block = this.adjacencyMatrix[i].reduce((sum, w) => sum + w, 0);
            for (let qi = 0; qi < this.qDim; qi++) {
                Lfull[i * this.qDim + qi][i * this.qDim + qi] = (Lfull[i * this.qDim + qi][i * this.qDim + qi] || 0) + deg_block + this.eps;
            }
        }

        const f_s = new Float32Array(N).fill(0);
        for (let i = 0; i < n; i++) {
            const inputVal = qInput[i % qInput.length];
            for (let qi = 0; qi < this.qDim; qi++) {
                f_s[i * this.qDim + qi] = this.alpha * inputVal * 0.7;
            }
        }

        const eta = this.gamma / Math.max(1, this.maxEigApprox);
        const A = identity(N).map((row, i) => new Float32Array(row.map((v, j) => v + eta * (Lfull[i]?.[j] || 0))));
        const rhs = vecAdd(s, vecScale(f_s, eta)).map(v => clamp(v, -10, 10));

        if (!isFiniteMatrix(A) || !isFiniteVector(rhs)) {
            logger.error('diffuseQualia: Matrix A or RHS vector contains non-finite values before CG solve. Skipping diffusion.');
            this.graph.edges = originalEdges;
            return;
        }

        let sSolved;
        try {
            sSolved = await runWorkerTask('solveLinearSystemCG', { A: flattenMatrix(A), b: rhs, opts: { tol: 1e-6, maxIter: 15 } });
        } catch (e) {
            logger.error('Error solving linear system in worker:', e);
            sSolved = new Float32Array(s.map(v => clamp(v, -1, 1))); // Fallback to clamped current state
        }
        
        const sNext = new Float32Array(sSolved.map(v => clamp(v, -1, 1)));

        this._updateStalksAndWindow(sNext, n);
        await this._updateDerivedMetrics();

        this.graph.edges = originalEdges; // Revert temporary edges
    }

    _updateStalksAndWindow(sNextVector, n) {
        for (let i = 0; i < n; i++) {
            const stalk = new Float32Array(sNextVector.slice(i * this.qDim, (i + 1) * this.qDim).map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
            this.stalks.set(this.graph.vertices[i], stalk);
        }
        const sanitizedNextVector = new Float32Array(sNextVector.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
        this.windowedStates.push(sanitizedNextVector);
        if (this.windowedStates.length > this.windowSize) this.windowedStates.shift();
    }

    async _updateDerivedMetrics() {
        try {
            await this.computeH1Dimension();
            await this.computeGluingInconsistency();
            this.computeGestaltUnity();
            await this.computeIntegratedInformation();
        } catch (e) {
            logger.error("Error during derived metrics update:", e);
            // Fallback values in case of error
            this.phi = 0.01;
            this.h1Dimension = 0.5;
            this.gestaltUnity = 0.05;
            this.stability = 0.01;
            this.inconsistency = 1.0;
        }
    }

    async computeH1Dimension() {
        const { boundary1, boundary2 } = this.buildBoundaryMatrices();
        if (!isFiniteMatrix(boundary1) || !isFiniteMatrix(boundary2)) {
            logger.warn("Non-finite boundary matrices detected. Setting H1 to default max/min.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        const flatBoundary1 = flattenMatrix(boundary1);
        const flatBoundary2 = flattenMatrix(boundary2);

        if (!flatBoundary1?.flatData || !isFiniteVector(flatBoundary1.flatData)) {
            logger.error("Flat boundary1 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        if (!flatBoundary2?.flatData || !isFiniteVector(flatBoundary2.flatData)) {
            logger.error("Flat boundary2 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        let rankB1, rankB2;
        try {
            rankB1 = await runWorkerTask('matrixRank', { matrix: flatBoundary1 });
        } catch (e) {
            logger.error('Error computing rankB1 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        try {
            rankB2 = await runWorkerTask('matrixRank', { matrix: flatBoundary2 });
        } catch (e) {
            logger.error('Error computing rankB2 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        
        const safeRankB1 = Number.isFinite(rankB1) && rankB1 >= 0 ? rankB1 : 0;
        const safeRankB2 = Number.isFinite(rankB2) && rankB2 >= 0 ? rankB2 : 0;

        const rawH1 = this.graph.edges.length - safeRankB1 - safeRankB2;
        this.h1Dimension = clamp(rawH1, 0, 3); // Clamp H1 to a sensible range
        if (!Number.isFinite(this.h1Dimension)) this.h1Dimension = 1;

        this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
        if (!Number.isFinite(this.stability)) this.stability = 0.5;
    }

    async computeGluingInconsistency() {
        let sum = 0;
        for (const [u, v] of this.graph.edges) {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            const P_uv = this.projectionMatrices.get(`${u}-${v}`);

            if (!P_uv || !isFiniteVector(stalk_u) || !isFiniteVector(stalk_v) || !isFiniteMatrix(P_uv)) {
                logger.warn(`Skipping inconsistency calculation for edge ${u}-${v} due to non-finite inputs.`);
                continue;
            }

            let projected_u;
            try {
                projected_u = await runWorkerTask('matVecMul', { matrix: flattenMatrix(P_uv), vector: stalk_u });
            } catch (e) {
                logger.error(`Error projecting stalk_u for edge ${u}-${v} in worker:`, e);
                projected_u = vecZeros(this.qDim);
            }
            
            const safeProjected_u = isFiniteVector(projected_u) ? projected_u : vecZeros(this.qDim);
            
            sum += norm2(vecSub(safeProjected_u, stalk_v));
        }
        this.inconsistency = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0, 1) : 0;
        if (!Number.isFinite(this.inconsistency)) this.inconsistency = 1.0;
    }

    computeGestaltUnity() {
        let sum = 0;
        this.graph.edges.forEach(([u, v]) => {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            if (isFiniteVector(stalk_u) && isFiniteVector(stalk_v)) {
                const diffNorm = norm2(vecSub(stalk_u, stalk_v));
                if (Number.isFinite(diffNorm)) {
                    sum += Math.exp(-diffNorm * this.beta);
                }
            }
        });
        this.gestaltUnity = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0.05, 0.99) : 0.05;
        if (!Number.isFinite(this.gestaltUnity)) this.gestaltUnity = 0.05;
    }

    async computeIntegratedInformation() {
        const validStates = this.windowedStates.filter(isFiniteVector);
        if (validStates.length < Math.max(4, this.stateDim + this.qDim)) {
            // Not enough data for meaningful covariance, use a base value influenced by other metrics
            this.phi = clamp(0.5 + this.gestaltUnity * this.stability, 0.01, 5);
            return;
        }
        let cov;
        try {
            cov = await runWorkerTask('covarianceMatrix', { states: validStates, eps: this.eps });
        } catch (e) {
            logger.error('Error computing covariance matrix in worker:', e);
            this.phi = clamp(0.5 + this.gestaltUnity * this.stability, 0.01, 5);
            return;
        }

        if (!isFiniteMatrix(cov)) {
            logger.warn("Non-finite covariance matrix. Setting MI to default.");
            this.phi = clamp(0.5 + this.gestaltUnity * this.stability, 0.01, 5);
            return;
        }

        const MI_val = logDeterminantFromDiagonal(cov);
        const MI = Number.isFinite(MI_val) ? Math.abs(MI_val) * 0.1 + 1e-6 : 1e-6; // Ensure MI is positive and non-zero
        
        const safeStability = Number.isFinite(this.stability) ? this.stability : 0.1;
        const safeGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.1;
        const safeInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 1.0;

        this.phi = clamp(Math.log(1 + MI) * safeStability * safeGestaltUnity * Math.exp(-safeInconsistency), 0.01, 5);
        if (!Number.isFinite(this.phi)) this.phi = 0.01;
    }

    visualizeActivity() {
        this.graph.vertices.forEach((vertexName, idx) => {
            const el = document.getElementById(`vertex-${idx}`);
            if (!el) return;
            const stalk = this.stalks.get(vertexName) || vecZeros(this.qDim);
            const norm = norm2(stalk);
            const intensity = Number.isFinite(norm) ? clamp(norm / Math.sqrt(this.qDim), 0, 1) : 0;
            el.classList.toggle('active', intensity > 0.5);
            const hue = 0;
            const saturation = 100;
            const lightness = 50 + intensity * 40;
            el.style.background = `radial-gradient(circle, hsl(${hue}, ${saturation}%, ${lightness}%), hsl(${hue}, ${saturation * 0.8}%, ${lightness * 0.6}%))`;
            if (intensity > 0.5) {
                 el.style.background = `radial-gradient(circle, #00ff99, #00cc66)`;
            }
        });
    }

    tuneParameters() {
        const currentStability = Number.isFinite(this.stability) ? this.stability : 0.5;
        const currentInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 0.5;
        const currentGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.5;
        const currentH1Dimension = Number.isFinite(this.h1Dimension) ? this.h1Dimension : 1;

        this.alpha = clamp(this.alpha * (1 + 0.02 * (1 - currentStability)) * (1 + 0.01 * currentInconsistency), 0.01, 1);
        this.beta = clamp(this.beta * (1 + 0.02 * currentGestaltUnity) * (1 - 0.01 * currentH1Dimension), 0.01, 1);
        this.gamma = clamp(this.gamma * (1 - 0.05 * currentH1Dimension) * (1 - 0.02 * currentInconsistency), 0.01, 0.5);
        logger.info(`Tuned parameters: Alpha=${this.alpha.toFixed(3)}, Beta=${this.beta.toFixed(3)}, Gamma=${this.gamma.toFixed(3)}`);
    }
}
class OntologicalWorldModel {
    constructor(stateDim = 10, actionDim = 3, qDim = 7, hiddenSizes = [16, 32, 16], isPlayerTwo = false) {
        this.stateDim = stateDim;
        this.actionDim = actionDim;
        this.qDim = qDim; // This qDim will be matched by EnhancedQualiaSheaf
        this.isPlayerTwo = isPlayerTwo;

        // Graph definition might vary slightly between AI for their 'perspective'
        const commonVertices = ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed', 'player_collision', 'ai_collision'];
        this.graph = {
            vertices: commonVertices,
            edges: [
                ['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'],
                ['player_collision', 'paddle_y'], ['ai_collision', 'ball_x']
            ]
        };
        // Ensure the sheaf receives the correct qDim based on its internal definition.
        this.qualiaSheaf = new EnhancedQualiaSheaf(this.graph, this.stateDim, this.qDim, 0.1, 0.1, 0.05);
        this.qDim = this.qualiaSheaf.qDim; // Override with the canonical qDim from the sheaf.

        this.inputDim = this.stateDim + this.actionDim + 1 + (this.graph.vertices.length * this.qualiaSheaf.qDim);
        this.hiddenSizes = hiddenSizes;

        this.layers = [];
        for (let i = 0; i < this.hiddenSizes.length; i++) {
            const currentInputDim = i === 0 ? this.inputDim : this.hiddenSizes[i - 1];
            const scale = Math.sqrt(2.0 / (currentInputDim + this.hiddenSizes[i]));
            this.layers.push({ W: randomMatrix(this.hiddenSizes[i], currentInputDim, scale), b: vecZeros(this.hiddenSizes[i]), activation: 'tanh' });
        }
        const outputScale = Math.sqrt(2.0 / (this.hiddenSizes[this.hiddenSizes.length - 1] + this.stateDim));
        this.outputLayer = { W: randomMatrix(this.stateDim, this.hiddenSizes[this.hiddenSizes.length - 1], outputScale), b: vecZeros(this.stateDim) };

        this.attentionWeights = randomMatrix(this.qualiaSheaf.qDim, this.inputDim, 0.1);

        this.freeEnergy = 0;
        this.predictionError = 0;
        this.memory = [];
        this.ready = false;
        this.lastActivations = []; // Store activations for visualization/learning
    }

    async initialize() {
        try {
            await this.qualiaSheaf.initialize();
            this.ready = true;
            logger.info(`OntologicalWorldModel for ${this.isPlayerTwo ? 'AI' : 'Player'} ready.`);
        } catch (e) {
            logger.error('Error during OWM initialization:', e);
            this.ready = false;
        }
    }

     async forward(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.forward: Invalid input for forward pass, length mismatch or non-finite values. Returning zeros.', input);
            return { output: vecZeros(this.stateDim), activations: [] };
        }

        let x = new Float32Array(input);
        const activations = [x.slice()]; // activations[0] -> input

        for (const layer of this.layers) {
            // Offload matVecMul to worker
            x = await runWorkerTask('matVecMul', { matrix: flattenMatrix(layer.W), vector: x });
            x = vecAdd(x, layer.b);
            if (layer.activation === 'tanh') x = tanhVec(x);
            activations.push(x.slice()); // activations for hidden layers (lIndex 1, 2, 3)
        }
        const out = vecAdd(await runWorkerTask('matVecMul', { matrix: flattenMatrix(this.outputLayer.W), vector: x }), this.outputLayer.b);
        
        // --- FIX START ---
        activations.push(out.slice()); // ADD THIS LINE: Push the final output layer activations (lIndex 4)
        // --- FIX END ---

        return { output: out, activations };
    }

    applyAttention(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.applyAttention: Invalid input for attention mechanism, length mismatch or non-finite values. Returning original input.', input);
            return input; // Return original input as fallback
        }

        // Simple dot-product attention for qualia, kept local for now
        const scores = this.attentionWeights.map(w => dot(w, input));
        const maxScore = scores.length > 0 ? Math.max(...scores) : 0;
        const expScores = scores.map(s => Math.exp(s - maxScore));
        const sumExpScores = expScores.reduce((s, x) => s + x, 1e-10);
        const softmaxScores = new Float32Array(expScores.map(s => s / sumExpScores));

        const att = vecZeros(input.length);
        for (let i = 0; i < softmaxScores.length; i++) {
            if (!Number.isFinite(softmaxScores[i])) continue; // Ensure softmaxScores are finite
            for (let j = 0; j < input.length; j++) {
                att[j] += softmaxScores[i] * (input[j] || 0); // Ensure input[j] is defined
            }
        }
        return vecAdd(input, vecScale(att, this.qualiaSheaf.beta)); // Beta influences attention strength
    }

    async predict(state, action, audioAmplitude = 0) {
        if (!this.ready) {
            logger.warn('OWM not ready for prediction. Returning zero state.');
            return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
        }
        if (!isFiniteVector(state) || !isFiniteVector(action)) {
            logger.error('OWM.predict: Invalid state or action for prediction, non-finite values. Returning zero state.', { state, action });
            return { nextState: vecZeros(this.stateDim), phi: 0, activations: [] };
        }

        // 1. Qualia Diffusion (asynchronous)
        await this.qualiaSheaf.diffuseQualia(state);
        
        const qualiaStalksMap = this.qualiaSheaf.stalks;
        let finalQualiaArray;
        const expectedQualiaLength = this.graph.vertices.length * this.qualiaSheaf.qDim;

        if (!qualiaStalksMap || !(qualiaStalksMap instanceof Map)) {
            logger.error("OWM.predict: qualiaSheaf.stalks is not a valid Map. Returning zero qualia array.");
            finalQualiaArray = vecZeros(expectedQualiaLength);
        } else {
            const qualiaStalkValues = [];
            for (const vertexName of this.qualiaSheaf.graph.vertices) {
                let stalk = qualiaStalksMap.get(vertexName);
                // Reinforced sanitization for each stalk
                if (!stalk || !isFiniteVector(stalk) || stalk.length !== this.qualiaSheaf.qDim) {
                    logger.error(`OWM.predict: Found non-finite or malformed stalk for vertex ${vertexName}. Resetting to zeros and correcting map.`);
                    stalk = vecZeros(this.qualiaSheaf.qDim);
                    qualiaStalksMap.set(vertexName, stalk); // Correct the map
                }
                // Use Array.from for safety, then push all elements
                qualiaStalkValues.push(...Array.from(stalk));
            }

            if (qualiaStalkValues.length < expectedQualiaLength) {
                const zerosToPad = Array.from(vecZeros(expectedQualiaLength - qualiaStalkValues.length));
                finalQualiaArray = new Float32Array([...qualiaStalkValues, ...zerosToPad]);
            } else if (qualiaStalkValues.length > expectedQualiaLength) {
                finalQualiaArray = new Float32Array(qualiaStalkValues.slice(0, expectedQualiaLength));
            } else {
                finalQualiaArray = new Float32Array(qualiaStalkValues);
            }
        }


        if (!isFiniteVector(finalQualiaArray)) {
             logger.error('OWM.predict: Final qualia array contains non-finite values. Detected value:', finalQualiaArray.find(v => !Number.isFinite(v)));
             return { nextState: vecZeros(this.stateDim), phi: this.qualiaSheaf.phi, activations: [] };
        }

        // 2. Prepare NN Input
        const input = new Float32Array([...state, ...action, audioAmplitude, ...finalQualiaArray]);
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error(`OWM.predict: Input vector for NN is invalid or incorrect length (${input.length} vs ${this.inputDim}). Returning zero state.`);
            return { nextState: vecZeros(this.stateDim), phi: this.qualiaSheaf.phi, activations: [] };
        }

        // 3. Apply Attention & Forward Pass (asynchronous)
        const attended = this.applyAttention(input);
        const { output: nextState, activations } = await this.forward(attended);
        this.lastActivations = activations; // Store for visualization/learning

        // 4. Calculate Free Energy and Prediction Error
        const error = norm2(vecSub(nextState, state.slice(0, Math.min(nextState.length, state.length)))); // Ensure lengths match for comparison
        this.predictionError = clamp(error, 0, 10); // Clamp prediction error

        // --- Start of Free Energy FIX ---
        // Replace L_proxy with a more meaningful approximation
        const globalStalkDim = finalQualiaArray.length;
        const numNodes = this.qualiaSheaf.graph.vertices.length;
        const qDim = this.qualiaSheaf.qDim;

        let L_approx_global = zeroMatrix(globalStalkDim, globalStalkDim);
        const nodeLaplacian = this.qualiaSheaf.laplacian; // This is the nxn matrix for nodes

        if (nodeLaplacian && isFiniteMatrix(nodeLaplacian) && nodeLaplacian.length === numNodes) {
            for (let i = 0; i < numNodes; i++) {
                for (let j = 0; j < numNodes; j++) {
                    const nodeWeight = nodeLaplacian[i][j];
                    if (!Number.isFinite(nodeWeight)) continue;

                    // Create block diagonal elements
                    for (let qi = 0; qi < qDim; qi++) {
                        for (let qj = 0; qj < qDim; qj++) {
                            const globalRow = i * qDim + qi;
                            const globalCol = j * qDim + qj;
                            // Simplified for performance: assuming identity within qualia space, only node-level Laplacian affects.
                            // A more complex model might involve a full tensor product.
                            if (qi === qj) { 
                                L_approx_global[globalRow][globalCol] = nodeWeight;
                            }
                        }
                    }
                }
            }
        } else {
            logger.warn('OWM.predict: nodeLaplacian is invalid or missing, Free Energy calculation will be affected.');
            // Fallback: If nodeLaplacian is bad, L_approx_global will remain zero.
        }

        let lapQuad = 0;
        try {
            const matMulResult = await runWorkerTask('matVecMul', { matrix: flattenMatrix(L_approx_global), vector: finalQualiaArray });
            if(isFiniteVector(matMulResult)) {
                lapQuad = 0.5 * dot(finalQualiaArray, matMulResult);
            } else {
                logger.warn('matVecMul for L_approx_global returned non-finite vector.');
            }
        } catch (e) {
            logger.error('Error during matVecMul for Free Energy calculation:', e);
        }
        
        // Ensure lapQuad is finite
        const safeLapQuad = Number.isFinite(lapQuad) ? lapQuad : 0;
        // --- End of Free Energy FIX ---

        this.freeEnergy = 0.85 * (this.freeEnergy || 0) + 0.15 * (safeLapQuad + this.qualiaSheaf.h1Dimension);
        this.freeEnergy = clamp(this.freeEnergy, 0, 10); // Clamp free energy

        return { nextState: new Float32Array(nextState.map(v => clamp(v, -5, 5))), phi: this.qualiaSheaf.phi, activations };
    }

    // A very simple learning rule (Gradient Descent for prediction error)
    // This is a minimal example and not a full backpropagation implementation.
    async learn(actualNextState, predictedNextState, learningRate = 0.01) {
        if (!isFiniteVector(actualNextState) || !isFiniteVector(predictedNextState)) {
            logger.warn('OWM.learn: Invalid input for learning, non-finite values. Skipping learning.', { actualNextState, predictedNextState });
            return;
        }
        const errorVector = vecSub(predictedNextState, actualNextState);
        if (norm2(errorVector) < 1e-3) return; // No significant error to learn from

        // --- FIX START ---
        // Ensure there are enough activations recorded to get the last hidden layer.
        // We need at least the input layer, one hidden layer, and the output layer.
        // If hiddenSizes is empty, we'd only have input and output, so index would be -1.
        // With hidden layers, the last hidden is at activations.length - 2.
        if (this.lastActivations.length < 2) {
            logger.warn('Skipping OWM learning: Not enough activations captured to identify last hidden layer. Array length:', this.lastActivations.length);
            return;
        }

        // Get the activations of the *last hidden layer*.
        const lastHiddenActivation = this.lastActivations[this.lastActivations.length - 2]; 
        // --- FIX END ---

        // The condition `lastHiddenActivation.length === this.outputLayer.W[0].length`
        // is correct, as the input dimension of the output layer's weights (W[0].length)
        // should match the output dimension of the last hidden layer (lastHiddenActivation.length).
        if (lastHiddenActivation && isFiniteVector(lastHiddenActivation) && lastHiddenActivation.length === this.outputLayer.W[0].length) {
            const gradOutput = vecScale(errorVector, learningRate);
            
            for (let i = 0; i < this.outputLayer.W.length; i++) {
                if (!Number.isFinite(gradOutput[i])) continue;
                for (let j = 0; j < this.outputLayer.W[0].length; j++) {
                    if (!Number.isFinite(lastHiddenActivation[j])) continue;
                    const deltaW_ij = gradOutput[i] * lastHiddenActivation[j];
                    if (Number.isFinite(deltaW_ij)) {
                        this.outputLayer.W[i][j] = clamp(this.outputLayer.W[i][j] - deltaW_ij, -10, 10); // Clamp weights
                    } else {
                        logger.warn(`Non-finite deltaW_ij during learning for OutputLayer.W[${i}][${j}]`);
                    }
                }
            }
            this.outputLayer.b = new Float32Array(vecSub(this.outputLayer.b, gradOutput).map(v => clamp(v, -10, 10)));
        } else {
            logger.warn('Skipping OWM learning due to invalid lastHiddenActivation state.');
        }
    }
}

        class LearningAI {
    // Constants for normalization and game physics
    static BALL_DX_NORMALIZATION = 10;
    static BALL_DY_NORMALIZATION = 12;
    static PADDLE_DY_NORMALIZATION = 7;
    static PADDLE_HEIGHT_BASE = 80;
    static PADDLE_WIDTH_BASE = 15;
    static PADDLE_OFFSET_X = 10; // Player paddle X, AI paddle X offset from width

    constructor(worldModel, gameBounds, isPlayerTwo = false, aiResponseTime = 3) {
        this.worldModel = worldModel;
        this.gameWidth = gameBounds.width;
        this.gameHeight = gameBounds.height;
        this.scoreToWin = gameBounds.scoreToWin || 10;
        this.isPlayerTwo = isPlayerTwo;
        this.lastStateVec = vecZeros(10);
        this.lastActionVec = [0, 0, 1]; // IDLE
        this.lastPrediction = { nextState: vecZeros(10), phi: 0, activations: [] };
        this.aiResponseTime = aiResponseTime; // New: AI response time (frames delay)
        this.actionQueue = []; // Queue actions for delayed response
    }

    createStateVector(gameState) {
        const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
        const opponentPaddle = this.isPlayerTwo ? gameState.player : gameState.ai;

        const stateVec = new Float32Array([
            gameState.ball.x / this.gameWidth,                                          // 0: Ball X (normalized)
            gameState.ball.y / this.gameHeight,                                         // 1: Ball Y (normalized)
            gameState.ball.dx / LearningAI.BALL_DX_NORMALIZATION,                       // 2: Ball DX (normalized)
            gameState.ball.dy / LearningAI.BALL_DY_NORMALIZATION,                       // 3: Ball DY (normalized)
            paddle.y / this.gameHeight,                                                 // 4: Own Paddle Y (normalized)
            opponentPaddle.y / this.gameHeight,                                         // 5: Opponent Paddle Y (normalized)
            paddle.dy / LearningAI.PADDLE_DY_NORMALIZATION,                             // 6: Own Paddle DY (normalized)
            opponentPaddle.dy / LearningAI.PADDLE_DY_NORMALIZATION,                     // 7: Opponent Paddle DY (normalized)
            gameState.playerCollision ? 1 : 0,                                          // 8: Player Collision
            gameState.aiCollision ? 1 : 0                                               // 9: AI Collision
        ]).map(v => clamp(v, -1, 1)); // Clamp values to a reasonable range

        if (!isFiniteVector(stateVec) || stateVec.length !== 10) {
            logger.error('LearningAI.createStateVector: Generated state vector is invalid. Returning zeros.', stateVec);
            return vecZeros(10);
        }
        return stateVec;
    }

    selectStrategy(phi, gestaltUnity, inconsistency) {
        if (phi > 3 && gestaltUnity > 0.8 && inconsistency < 0.2) {
            return 'predictive'; // High consciousness, stable, coherent
        } else if (phi < 1 || inconsistency > 0.5 || gestaltUnity < 0.3) {
            return 'reactive'; // Low consciousness, unstable, incoherent
        } else {
            return 'balanced'; // Moderate consciousness
        }
    }

    async makeDecision(gameState, audioAmplitude = 0) {
        // Apply response delay
        if (this.actionQueue.length >= this.aiResponseTime) {
            return this.actionQueue.shift(); // Return oldest queued action
        }

        const actions = [{ name: 'UP', vec: [1, 0, 0] }, { name: 'DOWN', vec: [0, 1, 0] }, { name: 'IDLE', vec: [0, 0, 1] }];
        let bestActionName = 'IDLE', bestActionVec = actions[2].vec, bestScore = -Infinity, bestActivations = [];

        const stateVec = this.createStateVector(gameState);
        this.worldModel.lastActivations = []; // Reset activations for current decision

        const ballY = gameState.ball.y;
        const ballDx = gameState.ball.dx;
        const ballDy = gameState.ball.dy;
        const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
        const paddleCenter = paddle.y + paddle.height / 2;

        // Simple physics prediction for ball's target Y
        const targetPaddleX = this.isPlayerTwo ? this.gameWidth - paddle.width - LearningAI.PADDLE_OFFSET_X : LearningAI.PADDLE_OFFSET_X + paddle.width; // Correct target X
        let timeToPaddle = Math.abs(targetPaddleX - gameState.ball.x) / Math.max(Math.abs(ballDx), 1e-3);
        let predictedBallY_physics = ballY + ballDy * timeToPaddle;
        predictedBallY_physics = clamp(predictedBallY_physics, 0, this.gameHeight); // Simplified bounce

        let validPredictions = [];
        for (const action of actions) {
            const { nextState, phi, activations } = await this.worldModel.predict(stateVec, action.vec, audioAmplitude);
            if (isFiniteVector(nextState) && nextState.length === this.worldModel.stateDim && Number.isFinite(phi)) {
                validPredictions.push({ action, nextState, phi, activations });
            } else {
                logger.warn(`Invalid prediction for action ${action.name}. Skipping.`, {nextState, phi});
            }
        }

        if (validPredictions.length === 0) {
            logger.warn('No valid predictions available. Falling back to simple heuristic.');
            if (predictedBallY_physics < paddleCenter - 15) { bestActionName = 'UP'; }
            else if (predictedBallY_physics > paddleCenter + 15) { bestActionName = 'DOWN'; }
            bestActionVec = actions.find(a => a.name === bestActionName).vec;
            this.lastPrediction = { nextState: stateVec, phi: 0, activations: [] };
            this.actionQueue.push({ action: bestActionVec, activations: [] });
        } else {
            const currentPhi = this.worldModel.qualiaSheaf.phi;
            const currentGestaltUnity = this.worldModel.qualiaSheaf.gestaltUnity;
            const currentInconsistency = this.worldModel.qualiaSheaf.inconsistency;
            const strategy = this.selectStrategy(currentPhi, currentGestaltUnity, currentInconsistency);

            validPredictions.forEach(({ action, nextState, phi, activations }) => {
                const predictedBallY_model = nextState[1] * this.gameHeight;
                let score = 0;

                const distanceToTarget = Math.abs(predictedBallY_model - paddleCenter);
                score -= 2.0 * (distanceToTarget / this.gameHeight); // Penalize distance to ball

                if (strategy === 'predictive') {
                    score += 0.5 * phi; // Reward higher consciousness
                    score -= 1.0 * this.worldModel.predictionError; // Penalize prediction error
                    score += 0.2 * currentGestaltUnity; // Reward coherent internal model
                    score -= 0.5 * currentInconsistency; // Penalize internal contradictions
                } else if (strategy === 'reactive') {
                    score -= 1.0 * Math.abs(predictedBallY_physics - paddleCenter) / this.gameHeight; // Follow physics
                    score += 0.1 * (action.name === 'IDLE' ? -0.1 : 0.1); // Small penalty for idle if not precise
                } else { // 'balanced' strategy
                    score += 0.2 * phi;
                    score -= 0.5 * this.worldModel.predictionError;
                    score -= 0.5 * Math.abs(predictedBallY_physics - paddleCenter) / this.gameHeight;
                }

                const ballApproachingSpeed = this.isPlayerTwo ? -ballDx : ballDx;
                if (ballApproachingSpeed > 0.5 && action.name !== 'IDLE') {
                    score += 0.1 * (action.name === 'UP' && paddleCenter > predictedBallY_model ? 1 : 0);
                    score += 0.1 * (action.name === 'DOWN' && paddleCenter < predictedBallY_model ? 1 : 0);
                }

                if (!Number.isFinite(score)) { logger.warn('Decision score is non-finite, skipping action.'); return; }

                if (score > bestScore) {
                    bestScore = score;
                    bestActionName = action.name;
                    bestActionVec = action.vec;
                    bestActivations = activations;
                    this.lastPrediction = { nextState, phi, activations };
                    this.worldModel.lastActivations = activations; // Store for learning
                }
            });
            this.actionQueue.push({ action: bestActionVec, activations: bestActivations });
        }
        this.lastStateVec = stateVec;
        this.lastActionVec = bestActionVec;

        // Return the oldest action in queue if enough actions are queued, otherwise the new best action
        return this.actionQueue.shift() || { action: bestActionVec, activations: bestActivations };
    }

    async learn(reward, newGameState, audioAmplitude = 0) {
        const nextStateVec = this.createStateVector(newGameState);
        this.worldModel.memory.push({ state: [...this.lastStateVec], action: [...this.lastActionVec], nextState: [...nextStateVec], reward, phi: this.worldModel.qualiaSheaf.phi });
        if (this.worldModel.memory.length > 1000) {
            this.worldModel.memory.shift();
        }
        // Call the simple learning rule
        await this.worldModel.learn(nextStateVec, this.lastPrediction.nextState);
    }
}
        class PongGame {
            // Game constants for clarity and easy tuning
            static PADDLE_HEIGHT_BASE = 80;
            static PADDLE_WIDTH_BASE = 15;
            static BALL_RADIUS = 8;
            static INITIAL_BALL_SPEED_X = 4;
            static INITIAL_BALL_SPEED_Y_MAX = 6;
            static PLAYER_PADDLE_SPEED = 7; // Fixed player speed

            constructor(canvas, initialWidth, initialHeight) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = initialWidth;
                this.height = initialHeight;
                this.scoreToWin = 10;
                this.ballSpeedMultiplier = 1.0;
                this.paddleHeightMultiplier = 1.0;
                this.MAX_BALL_SPEED_BASE = 8;
                this.MAX_PADDLE_SPEED_BASE = 7;
                this.reset();
            }

            reset() {
                // Ensure dimensions are valid, fallback to canvas client dimensions if needed
                this.width = this.canvas.clientWidth || this.width;
                this.height = this.canvas.clientHeight || this.height;
                if (this.width === 0 || this.height === 0) {
                    logger.warn("PongGame dimensions are zero during reset. Falling back to default dimensions.");
                    this.width = 600; this.height = 300;
                }
                
                const paddleH = PongGame.PADDLE_HEIGHT_BASE * this.paddleHeightMultiplier;
                const paddleW = PongGame.PADDLE_WIDTH_BASE;

                this.ball = { 
                    x: this.width / 2, 
                    y: this.height / 2, 
                    dx: (Math.random() > 0.5 ? 1 : -1) * PongGame.INITIAL_BALL_SPEED_X * this.ballSpeedMultiplier, 
                    dy: (Math.random() - 0.5) * PongGame.INITIAL_BALL_SPEED_Y_MAX * this.ballSpeedMultiplier, 
                    radius: PongGame.BALL_RADIUS 
                };
                this.ai = { x: this.width - 25, y: (this.height / 2) - (paddleH / 2), width: paddleW, height: paddleH, dy: 0 };
                this.player = { x: 10, y: (this.height / 2) - (paddleH / 2), width: paddleW, height: paddleH, dy: 0 };
                this.score = { ai: 0, player: 0 };
                this.playerCollision = false;
                this.aiCollision = false;
                this.gameOver = false;
                this.winner = null;
            }

            resetBall() {
                this.ball.x = this.width / 2;
                this.ball.y = this.height / 2;
                this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * PongGame.INITIAL_BALL_SPEED_X * this.ballSpeedMultiplier;
                this.ball.dy = (Math.random() - 0.5) * PongGame.INITIAL_BALL_SPEED_Y_MAX * this.ballSpeedMultiplier;
            }

            update() {
                if (this.gameOver) {
                    return { aReward: 0, pReward: 0, playerCollision: false, aiCollision: false, ballHitGround: false };
                }

                const MAX_BALL_DX = this.MAX_BALL_SPEED_BASE * this.ballSpeedMultiplier;
                const MAX_BALL_DY = this.MAX_BALL_SPEED_BASE * 1.25 * this.ballSpeedMultiplier; // DY can be slightly faster

                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                if (this.ball.y <= this.ball.radius || this.ball.y >= this.height - this.ball.radius) {
                    this.ball.dy *= -1;
                    this.ball.y = clamp(this.ball.y, this.ball.radius, this.height - this.ball.radius); // Prevent sticking
                }

                let aReward = 0, pReward = 0;
                this.playerCollision = false;
                this.aiCollision = false;

                let ballHitGround = false;
                if (this.ball.x <= 0) {
                    this.score.ai++;
                    aReward = 1; // AI scores, positive reward
                    pReward = -1; // Player fails, negative reward
                    this.resetBall();
                    ballHitGround = true;
                } else if (this.ball.x >= this.width) {
                    this.score.player++;
                    aReward = -1; // AI fails, negative reward
                    pReward = 1; // Player scores, positive reward
                    this.resetBall();
                    ballHitGround = true;
                }

                this.ai.y = clamp(this.ai.y + this.ai.dy, 0, this.height - this.ai.height);
                this.player.y = clamp(this.player.y + this.player.dy, 0, this.height - this.player.height);

                // Paddle collision (Player)
                if (this.ball.dx < 0 && // Only check if ball is moving towards player paddle
                    this.ball.x - this.ball.radius <= this.player.x + this.player.width &&
                    this.ball.x + this.ball.radius >= this.player.x &&
                    this.ball.y >= this.player.y &&
                    this.ball.y <= this.player.y + this.player.height) {
                    this.ball.dx = clamp(Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX);
                    this.ball.dy = clamp(this.ball.dy + (this.player.dy * 0.5), -MAX_BALL_DY, MAX_BALL_DY); // Paddle velocity influences ball
                    this.ball.x = this.player.x + this.player.width + this.ball.radius + 1; // Prevent sticking
                    this.playerCollision = true;
                    pReward += 0.1; // Small reward for hitting the ball
                    aReward -= 0.05; // Small penalty for AI not hitting it
                }

                // Paddle collision (AI)
                if (this.ball.dx > 0 && // Only check if ball is moving towards AI paddle
                    this.ball.x + this.ball.radius >= this.ai.x &&
                    this.ball.x - this.ball.radius <= this.ai.x + this.ai.width &&
                    this.ball.y >= this.ai.y &&
                    this.ball.y <= this.ai.y + this.ai.height) {
                    this.ball.dx = clamp(-Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX);
                    this.ball.dy = clamp(this.ball.dy + (this.ai.dy * 0.5), -MAX_BALL_DY, MAX_BALL_DY);
                    this.ball.x = this.ai.x - this.ball.radius - 1; // Prevent sticking
                    this.aiCollision = true;
                    aReward += 0.1; // Small reward for hitting the ball
                    pReward -= 0.05; // Small penalty for Player not hitting it
                }

                if (this.score.ai >= this.scoreToWin) {
                    this.gameOver = true;
                    this.winner = 'AI';
                } else if (this.score.player >= this.scoreToWin) {
                    this.gameOver = true;
                    this.winner = 'Player';
                }

                return { aReward, pReward, playerCollision: this.playerCollision, aiCollision: this.aiCollision, ballHitGround };
            }

            setAIAction(action) {
                const speed = this.MAX_PADDLE_SPEED_BASE * this.ballSpeedMultiplier;
                if (action[0] === 1) this.ai.dy = -speed;
                else if (action[1] === 1) this.ai.dy = speed;
                else this.ai.dy = 0;
            }

            setPlayerAction(action) {
                const speed = PongGame.PLAYER_PADDLE_SPEED;
                if (action[0] === 1) this.player.dy = -speed;
                else if (action[1] === 1) this.player.dy = speed;
                else this.player.dy = 0;
            }

            getState() {
                // Return a comprehensive state vector for AI learning
                return {
                    player: { y: this.player.y, dy: this.player.dy, width: this.player.width, height: this.player.height },
                    ai: { y: this.ai.y, dy: this.ai.dy, width: this.ai.width, height: this.ai.height },
                    ball: { x: this.ball.x, y: this.ball.y, dx: this.ball.dx, dy: this.ball.dy },
                    score: { player: this.score.player, ai: this.score.ai },
                    playerCollision: this.playerCollision,
                    aiCollision: this.aiCollision
                };
            }

            render(ctx) {
                if (!ctx) return;

                ctx.clearRect(0, 0, this.width, this.height);

                ctx.fillStyle = this.playerCollision ? 'var(--error-red)' : '#fff';
                ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                ctx.fillStyle = this.aiCollision ? 'var(--error-red)' : '#fff';
                ctx.fillRect(this.ai.x, this.ai.y, this.ai.width, this.ai.height);

                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                ctx.font = '24px "Courier Prime"';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'var(--primary-blue)';
                ctx.fillText(this.score.player, this.width / 4, 30);
                ctx.fillText(this.score.ai, this.width * 3 / 4, 30);

                if (this.gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, this.width, this.height);
                    ctx.fillStyle = 'var(--primary-blue)';
                    ctx.font = '48px "Courier Prime"';
                    ctx.fillText(`${this.winner} Wins!`, this.width / 2, this.height / 2);
                    ctx.font = '24px "Courier Prime"';
                    ctx.fillText('Press R to Reset', this.width / 2, this.height / 2 + 40);
                }
            }
        }

        class NeuralNetworkVisualizer {
            constructor(containerId, worldModel, theme = 'main') {
                this.container = document.getElementById(containerId);
                this.worldModel = worldModel;
                this.theme = theme;

                if (!this.container || !this.worldModel) {
                    logger.error(`NNVisualizer: Container '${containerId}' or worldModel not found.`);
                    return;
                }

                this.neuronElements = [];
                this.visualLayers = [];
                this.MAX_NEURONS_TO_DISPLAY = 12; // Reduced for clarity in smaller panels

                this._setupVisualLayers();
                this._setupDOM();
            }

            _setupVisualLayers() {
                const model = this.worldModel;
                // Input layer should represent: stateDim + actionDim + audioAmplitude + (graph.vertices.length * qualiaSheaf.qDim)
                const fullInputDim = model.stateDim + model.actionDim + 1 + (model.qualiaSheaf.graph.vertices.length * model.qualiaSheaf.qDim);
                this.visualLayers.push({ name: 'input', actualCount: fullInputDim });
                model.hiddenSizes.forEach((size, index) => this.visualLayers.push({ name: `hidden${index+1}`, actualCount: size }));
                this.visualLayers.push({ name: 'output', actualCount: model.stateDim });
            }

            _setupDOM() {
                this.container.innerHTML = '';

                this.canvas = document.createElement('canvas');
                this.canvas.className = 'nn-connections-canvas';
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);

                this.visualLayers.forEach((layer, lIndex) => {
                    const lDiv = document.createElement('div');
                    lDiv.className = 'nn-layer';
                    this.neuronElements[lIndex] = [];

                    const neuronsToDisplay = Math.min(layer.actualCount, this.MAX_NEURONS_TO_DISPLAY);
                    for (let i = 0; i < neuronsToDisplay; i++) {
                        const nDiv = document.createElement('div');
                        nDiv.className = 'nn-neuron';
                        lDiv.appendChild(nDiv);
                        this.neuronElements[lIndex].push(nDiv);
                    }
                    this.container.appendChild(lDiv);
                });

                const ro = new ResizeObserver(() => {
                    const dpr = window.devicePixelRatio || 1;
                    this.canvas.width = this.container.clientWidth * dpr;
                    this.canvas.height = this.container.clientHeight * dpr;
                    this.ctx.scale(dpr, dpr);
                    this._drawConnections();
                });
                ro.observe(this.container);
            }

            _getNeuronPosition(lIndex, nIndex) {
                const el = this.neuronElements[lIndex]?.[nIndex];
                if (!el) {
                    // Fallback to approximate center if element isn't rendered yet
                    const layerDiv = this.container.children[lIndex + 1]; // +1 because canvas is first child
                    if (!layerDiv) return { x: 0, y: 0 };
                    const layerRect = layerDiv.getBoundingClientRect();
                    const containerRect = this.container.getBoundingClientRect();
                    return {
                        x: (layerRect.left - containerRect.left) + layerRect.width / 2,
                        y: (layerRect.top - containerRect.top) + layerRect.height / 2
                    };
                }

                const r = el.getBoundingClientRect();
                const cr = this.container.getBoundingClientRect();

                return {
                    x: r.left - cr.left + r.width / 2,
                    y: r.top - cr.top + r.height / 2
                };
            }

            _drawConnections() {
                if (!this.ctx || !this.neuronElements || this.visualLayers.length <= 1) return;

                this.ctx.clearRect(0, 0, this.canvas.width / (window.devicePixelRatio || 1), this.canvas.height / (window.devicePixelRatio || 1));

                const matrices = this.worldModel.layers.map(layer => layer.W).concat([this.worldModel.outputLayer.W]);
                const colors = this.theme === 'opponent' ? { pos: 'rgba(255,165,0,', neg: 'rgba(138,43,226,' } : { pos: 'rgba(68,170,255,', neg: 'rgba(255,85,85,' };

                for (let l = 0; l < this.visualLayers.length - 1; l++) {
                    const matrix = matrices[l];
                    if (!matrix || matrix.length === 0) continue;

                    for (let i = 0; i < this.neuronElements[l].length; i++) {
                        for (let j = 0; j < this.neuronElements[l + 1].length; j++) {
                            const start = this._getNeuronPosition(l, i);
                            const end = this._getNeuronPosition(l + 1, j);

                            const srcMatrixIdx = Math.floor(i * (this.visualLayers[l].actualCount / this.neuronElements[l].length));
                            const tgtMatrixIdx = Math.floor(j * (this.visualLayers[l + 1].actualCount / this.neuronElements[l+1].length));

                            const w = matrix[tgtMatrixIdx]?.[srcMatrixIdx] || 0;
                            const alpha = clamp(Math.abs(w) * 3, 0.05, 0.6); // Increased max alpha

                            if (alpha < 0.05) continue;

                            this.ctx.strokeStyle = w > 0 ? colors.pos + `${alpha})` : colors.neg + `${alpha})`;
                            this.ctx.lineWidth = clamp(alpha * 2, 0.5, 2);
                            this.ctx.beginPath();
                            this.ctx.moveTo(start.x, start.y);
                            this.ctx.lineTo(end.x, end.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }

            update(activations) {
                // If activations are not provided or invalid, visualize a neutral state
                if (!activations || activations.length === 0 || !activations.every(isFiniteVector)) {
                    this.visualLayers.forEach((layerViz, l_idx) => {
                        this.neuronElements[l_idx].forEach(el => {
                            if (el) {
                                el.style.backgroundColor = '#333';
                                el.style.borderColor = '#888';
                                el.style.boxShadow = 'none';
                            }
                        });
                    });
                    this._drawConnections();
                    return;
                }

                const hues = this.theme === 'opponent' ? { pos: 39, neg: 271 } : { pos: 195, neg: 0 };

                this.visualLayers.forEach((layerViz, l_idx) => {
                    const layerActivations = activations[l_idx];
                    if (!layerActivations || !isFiniteVector(layerActivations)) {
                        logger.warn(`NNVisualizer: Layer ${l_idx} activations are invalid.`);
                        return;
                    }

                    let maxAbs = 0;
                    for (const v of layerActivations) if (Math.abs(v) > maxAbs) maxAbs = Math.abs(v);
                    const norm = maxAbs + 1e-9; // Add small epsilon to avoid division by zero

                    for (let n_idx = 0; n_idx < this.neuronElements[l_idx].length; n_idx++) {
                        const data_idx = Math.floor(n_idx * (layerActivations.length / this.neuronElements[l_idx].length));
                        const val = layerActivations[data_idx] || 0;
                        const intensity = clamp(Math.abs(val / norm), 0, 1);

                        const hue = val >= 0 ? hues.pos : hues.neg;
                        const lightness = clamp((0.1 + 0.9 * intensity) * 60, 10, 90); // Brighter range
                        const el = this.neuronElements[l_idx][n_idx];
                        if (el) {
                            el.style.backgroundColor = `hsl(${hue},100%,${lightness}%)`;
                            el.style.borderColor = `hsl(${hue},100%,${lightness * 1.2}%)`;
                            el.style.boxShadow = `0 0 ${clamp(intensity * 8, 0, 8)}px hsl(${hue},100%,${lightness}%)`;
                        }
                    }
                });
                this._drawConnections();
            }
        }

        class MainApp {
    constructor() {
        this.gameCanvas = document.getElementById('gameCanvas');
        this.sheafGraphCanvas = document.getElementById('sheafGraphCanvas');

        if (!this.gameCanvas || !this.sheafGraphCanvas) {
            document.getElementById('status').textContent = 'Error: Canvas not found. Check HTML IDs.';
            logger.error('Canvas not found');
            throw new Error('Canvas not found');
        }

        this.ctx = this.gameCanvas.getContext('2d');
        this.sheafGraphCtx = this.sheafGraphCanvas.getContext('2d');

        if (!this.ctx || !this.sheafGraphCtx) {
            document.getElementById('status').textContent = 'Error: Failed to get 2D rendering context for canvas.';
            logger.error('Failed to get 2D context');
            throw new Error('Failed to get 2D context');
        }

        this.applyCanvasDPR(this.sheafGraphCanvas, this.sheafGraphCtx);
        const gameCanvasRO = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                this.applyCanvasDPR(this.gameCanvas, this.ctx, width, height);
                if (this.pongGame) {
                    this.pongGame.width = width;
                    this.pongGame.height = height;
                    this.pongGame.render(this.ctx);
                    const newGameBounds = { width, height, scoreToWin: this.pongGame.scoreToWin };
                    if (this.mainAI) { this.mainAI.gameWidth = newGameBounds.width; this.mainAI.gameHeight = newGameBounds.height; }
                    if (this.opponentAI) { this.opponentAI.gameWidth = newGameBounds.width; this.opponentAI.gameHeight = newGameBounds.height; }
                }
            }
        });
        gameCanvasRO.observe(this.gameCanvas);

        this.isRunning = false;
        this.frameCount = 0;
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.boundGameLoop = this.gameLoop.bind(this); // Pre-bind for requestAnimationFrame
        this.setupTooltips();
        this.bindEvents();
        document.getElementById('status').textContent = 'Ready';

        this.setupGameAndAIs(); // Call asynchronously below
    }

    applyCanvasDPR(canvas, ctx, baseWidth = canvas.clientWidth, baseHeight = canvas.clientHeight) {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = baseWidth * dpr;
        canvas.height = baseHeight * dpr;
        canvas.style.width = `${baseWidth}px`;
        canvas.style.height = `${baseHeight}px`;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    async setupGameAndAIs() {
        showLoading('game', 'Initializing Pong Environment...');
        showLoading('mainBrain', 'Building Main AI World Model...');
        showLoading('opponentBrain', 'Building Opponent AI World Model...');
        showLoading('metrics', 'Initializing OFTCC Sheaf...');

        try {
            const { clientWidth: w, clientHeight: h } = this.gameCanvas;
            // Ensure PongGame is initialized with correct dimensions
            this.pongGame = new PongGame(this.gameCanvas, w, h);
            
            const gameBounds = { width: w, height: h, scoreToWin: 10 };

            this.mainAI_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16], true);
            this.opponent_worldModel = new OntologicalWorldModel(10, 3, 7, [16, 32, 16], false);

            await Promise.all([this.mainAI_worldModel.initialize(), this.opponent_worldModel.initialize()]);

            this.mainAI = new LearningAI(this.mainAI_worldModel, gameBounds, true);
            this.opponentAI = new LearningAI(this.opponent_worldModel, gameBounds, false);

            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            // Crucially, render the game AFTER everything is set up and dimensions are confirmed
            this.pongGame.render(this.ctx); 
            this.updateVisualization(); // Initial visualization update
            // Automatically start the game after successful initialization
            this.start();
            logger.info('Game and AIs initialized successfully.');

        } catch (e) {
            logger.error('Failed to set up game and AIs:', e);
            document.getElementById('status').textContent = `Initialization Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
        }
    }

    bindEvents() {
        document.getElementById('toggleSimButton').onclick = () => this.toggleGame();
        document.getElementById('resetSimButton').onclick = () => this.resetAI();
        document.getElementById('tuneButton').onclick = () => this.tuneParameters();
        document.getElementById('pauseButton').onclick = () => this.stop();
        // Updated call to gameLoop for stepButton
        document.getElementById('stepButton').onclick = () => this.gameLoop(null, true);

        window.addEventListener('keydown', (e) => this.handleKeyDown(e));
        window.addEventListener('keyup', (e) => this.handleKeyUp(e));

        ['alphaSlider', 'betaSlider', 'gammaSlider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.addEventListener('input', () => {
                const paramName = id.replace('Slider', '');
                const value = parseFloat(slider.value);
                if (this.mainAI_worldModel?.qualiaSheaf) this.mainAI_worldModel.qualiaSheaf[paramName] = value;
                if (this.opponent_worldModel?.qualiaSheaf) this.opponent_worldModel.qualiaSheaf[paramName] = value;
                document.getElementById(`${paramName}-param`).textContent = value.toFixed(3);
                slider.setAttribute('aria-valuetext', value.toFixed(3));
            });
        });

        ['ballSpeedSlider', 'paddleHeightSlider', 'aiResponseTimeSlider'].forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('change', () => {
                const value = parseFloat(input.value);
                if (this.pongGame) {
                    if (id === 'ballSpeedSlider') this.pongGame.ballSpeedMultiplier = value;
                    if (id === 'paddleHeightSlider') {
                        this.pongGame.paddleHeightMultiplier = value;
                        this.pongGame.player.height = PongGame.PADDLE_HEIGHT_BASE * value; // Update player paddle height
                        this.pongGame.ai.height = PongGame.PADDLE_HEIGHT_BASE * value;     // Update AI paddle height
                    }
                    if (id === 'aiResponseTimeSlider') {
                        if (this.mainAI) this.mainAI.aiResponseTime = value;
                        if (this.opponentAI) this.opponentAI.aiResponseTime = value;
                    }
                }
            });
        });
    }

    setupTooltips() {
        tippy('#phi-display', { content: 'Φ (Phi) measures integrated information, indicating the system\'s level of consciousness or experience.' });
        tippy('#free-energy', { content: 'Free Energy (F) quantifies the system’s predictive divergence from its world model; the AI strives to minimize this.' });
        tippy('#prediction-error', { content: 'Prediction Error measures the discrepancy between the AI\'s predicted next state and the actual observed next state.' });
        tippy('#gestalt-unity', { content: 'Gestalt Unity quantifies the holistic coherence and interconnectedness across the sheaf structure, indicating how well its internal model is integrated.' });
        tippy('#h1-dimension', { content: 'dim H¹ represents the first cohomology dimension, indicating structural complexity and the presence of "holes" or non-trivial loops in the information flow within the sheaf.' });
        tippy('#inconsistency', { content: 'Gluing Inconsistency measures the misalignment in qualia projections between connected vertices (concepts) in the sheaf, indicating internal contradictions.' });
        tippy('#qualia-being-fill', { content: 'Being: Reflects the system’s fundamental existence and persistent state, representing its self-awareness.' });
        tippy('#qualia-intent-fill', { content: 'Intent: Captures directed action potential and goal-oriented focus, signifying its purpose and goals.' });
        tippy('#qualia-existence-fill', { content: 'Existence: Models state persistence and resilience to change, representing its current state and environmental robustness.' });
        tippy('#qualia-emergence-fill', { content: 'Emergence: Represents non-linear state synthesis and novel property formation, indicating its capacity for novelty.' });
        tippy('#qualia-gestalt-fill', { content: 'Gestalt: Quantifies holistic coherence and pattern recognition, indicating its ability to form meaningful wholes from parts.' });
        tippy('#qualia-context-fill', { content: 'Context: Incorporates environmental modulation and background information, reflecting its understanding of the surrounding world.' });
        tippy('#qualia-rel-emergence-fill', { content: 'Relational Emergence: Captures dynamic entity coupling and interaction effects, indicating its comprehension of relationships.' });
        tippy('#alphaSlider', { content: 'α (Alpha) controls the influence of external sensory input on qualia diffusion; higher values mean more responsiveness to environment.' });
        tippy('#betaSlider', { content: 'β (Beta) adjusts the overall diffusion strength and speed across the sheaf; higher values lead to faster qualia propagation and integration.' });
        tippy('#gammaSlider', { content: 'γ (Gamma) sets the inertia for qualia updates and acts as an effective learning rate for diffusion; higher values imply quicker adaptation.' });
        tippy('#toggleSimButton', { content: 'Toggles the simulation run/pause state. (Spacebar)' });
        tippy('#resetSimButton', { content: 'Resets the game, AI states, and world models to their initial configurations. (R key)' });
        tippy('#tuneButton', { content: 'Adaptively adjusts AI parameters (α, β, γ) based on real-time system stability and consciousness metrics, aiming for optimal performance. (T key)' });
        tippy('#pauseButton', { content: 'Pauses the simulation if it is currently running. (P key or Spacebar)' });
        tippy('#stepButton', { content: 'Advances the simulation by a single frame/step. (S key)' });
        tippy('#vertex-0', { content: 'P-Y: Player (Left) paddle Y position. The vertical position of the human-controlled or opponent AI paddle.' });
        tippy('#vertex-1', { content: 'B-X: Ball X position. The horizontal position of the Pong ball in the game environment.' });
        tippy('#vertex-2', { content: 'B-Y: Ball Y position. The vertical position of the Pong ball in the game environment.' });
        tippy('#vertex-3', { content: 'B-DX: Ball X velocity. The horizontal speed and direction of the ball.' });
        tippy('#vertex-4', { content: 'B-DY: Ball Y velocity. The vertical speed and direction of the ball.' });
        tippy('#vertex-5', 'P-SC: Player (Left) score. The current score of the player\'s paddle.');
        tippy('#vertex-6', 'AI-SC: AI (Right) score. The current score of the main AI paddle.');
        tippy('#vertex-7', 'P-DY: Player (Left) paddle Y velocity. The vertical speed and direction of the human-controlled or opponent AI paddle.');
        tippy('#vertex-8', 'P-Col: Player (Left) collision state. Indicates if the ball has just collided with the player\'s paddle.');
        tippy('#vertex-9', 'AI-Col: AI (Right) collision state. Indicates if the ball has just collided with the main AI\'s paddle.');
    }

    drawSheafGraph() {
        if (!this.sheafGraphCtx) return;
        const dpr = window.devicePixelRatio || 1;
        const { clientWidth: w, clientHeight: h } = this.sheafGraphCanvas;
        this.sheafGraphCtx.clearRect(0, 0, w / dpr, h / dpr);

        this.sheafGraphCtx.strokeStyle = 'rgba(68, 170, 255, 0.3)';
        this.sheafGraphCtx.lineWidth = 1.5; // Slightly thicker lines
        const sheaf = this.mainAI_worldModel?.qualiaSheaf;
        if (!sheaf || !sheaf.graph || !sheaf.graph.vertices || !sheaf.graph.edges) {
            logger.warn("Sheaf graph data not available for drawing.");
            return;
        }

        sheaf.graph.edges.forEach(([u, v]) => {
            const uIdx = sheaf.graph.vertices.indexOf(u);
            const vIdx = sheaf.graph.vertices.indexOf(v);
            if (!sheafVertexPositions[uIdx] || !sheafVertexPositions[vIdx]) return;

            const p1 = sheafVertexPositions[uIdx], p2 = sheafVertexPositions[vIdx];
            this.sheafGraphCtx.beginPath();
            // Scale and offset positions based on current canvas client dimensions
            const scaledX1 = p1.x * (w / dpr - 36) + 18;
            const scaledY1 = p1.y * (h / dpr - 36) + 18;
            const scaledX2 = p2.x * (w / dpr - 36) + 18;
            const scaledY2 = p2.y * (h / dpr - 36) + 18;

            this.sheafGraphCtx.moveTo(scaledX1, scaledY1);
            this.sheafGraphCtx.lineTo(scaledX2, scaledY2);
            this.sheafGraphCtx.stroke();
        });
    }

    updateVisualization() {
        const qualia = this.mainAI_worldModel?.qualiaSheaf;
        const model = this.mainAI_worldModel;

        if (!qualia || !model) {
            logger.warn('Main AI World Model or Qualia Sheaf not initialized for visualization.');
            return;
        }

        const avgQualia = new Float32Array(qualia.qDim).fill(0);
        let count = 0;
        qualia.stalks.forEach((stalk) => {
            if (isFiniteVector(stalk)) {
                stalk.forEach((v, i) => avgQualia[i] += v);
                count++;
            }
        });
        if (count > 0) avgQualia.forEach((_, i) => avgQualia[i] /= count);

        const qualiaValues = avgQualia.map(v => clamp(v, 0, 1)); // Normalize qualia for bar display (0 to 1)

        requestAnimationFrame(() => {
            document.getElementById('being-value').textContent = qualiaValues[0].toFixed(3);
            document.getElementById('qualia-being-fill').style.width = `${qualiaValues[0] * 100}%`;
            document.getElementById('intent-value').textContent = qualiaValues[1].toFixed(3);
            document.getElementById('qualia-intent-fill').style.width = `${qualiaValues[1] * 100}%`;
            document.getElementById('existence-value').textContent = qualiaValues[2].toFixed(3);
            document.getElementById('qualia-existence-fill').style.width = `${qualiaValues[2] * 100}%`;
            document.getElementById('emergence-value').textContent = qualiaValues[3].toFixed(3);
            document.getElementById('qualia-emergence-fill').style.width = `${qualiaValues[3] * 100}%`;
            document.getElementById('gestalt-value').textContent = qualiaValues[4].toFixed(3);
            document.getElementById('qualia-gestalt-fill').style.width = `${qualiaValues[4] * 100}%`;
            document.getElementById('context-value').textContent = qualiaValues[5].toFixed(3);
            document.getElementById('qualia-context-fill').style.width = `${qualiaValues[5] * 100}%`;
            document.getElementById('rel-emergence-value').textContent = qualiaValues[6].toFixed(3);
            document.getElementById('qualia-rel-emergence-fill').style.width = `${qualiaValues[6] * 100}%`;

            document.getElementById('phi-display').textContent = `Φ: ${clamp(qualia.phi, 0, 5).toFixed(5)}`;
            document.getElementById('free-energy').textContent = model.freeEnergy.toFixed(5);
            document.getElementById('prediction-error').textContent = model.predictionError.toFixed(5);
            document.getElementById('h1-dimension').textContent = clamp(qualia.h1Dimension, 0, 3).toFixed(2);
            document.getElementById('gestalt-unity').textContent = clamp(qualia.gestaltUnity, 0, 1).toFixed(5);
            document.getElementById('inconsistency').textContent = (qualia.inconsistency || 0).toFixed(5);

            document.getElementById('stability-fill').style.width = `${clamp(qualia.stability, 0, 1) * 100}%`;

            document.getElementById('alpha-param').textContent = qualia.alpha.toFixed(3);
            document.getElementById('alphaSlider').value = qualia.alpha;
            document.getElementById('alphaSlider').setAttribute('aria-valuetext', qualia.alpha.toFixed(3));

            document.getElementById('beta-param').textContent = qualia.beta.toFixed(3);
            document.getElementById('betaSlider').value = qualia.beta;
            document.getElementById('betaSlider').setAttribute('aria-valuetext', qualia.beta.toFixed(3));

            document.getElementById('gamma-param').textContent = qualia.gamma.toFixed(3);
            document.getElementById('gammaSlider').value = qualia.gamma;
            document.getElementById('gammaSlider').setAttribute('aria-valuetext', qualia.gamma.toFixed(3));

            qualia.visualizeActivity();
            this.drawSheafGraph();
        });
    }

    playSound(type = 'collision') {
        try {
            // Ensure audio context is running
            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume().then(() => {
                    logger.info("AudioContext resumed.");
                    this._playActualSound(type);
                }).catch(e => {
                    logger.error("Failed to resume AudioContext:", e);
                });
                return 0; // Return 0 immediately, sound will play after resume
            } else {
                return this._playActualSound(type);
            }
        } catch (e) {
            logger.warn('Audio playback failed or context error', e.message);
            return 0;
        }
    }

    _playActualSound(type) {
        if (this.audioContext.state !== 'running') return 0;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        if (type === 'collision') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440 + Math.random() * 100, this.audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + 0.2);
            return 0.1; // Return a small amplitude value to represent sound activity
        }
        return 0;
    }

    // Modified gameLoop signature to properly handle requestAnimationFrame's timestamp
    async gameLoop(timestamp, isManualStep = false) {
        // Use isManualStep for checks, ignore timestamp if it's not a manual step
        if (!this.isRunning && !isManualStep) {
            return;
        }
        
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready || !this.pongGame) {
            logger.warn('GameLoop: AIs or PongGame not ready. Waiting...');
            document.getElementById('status').textContent = 'Waiting for AI/Game initialization...';
            // Schedule another check if not a manual step, to retry after things are ready
            if (!isManualStep) requestAnimationFrame(this.boundGameLoop);
            return; 
        }

        try {
            this.frameCount++;

            const preGameState = this.pongGame.getState();
            const gameUpdateResult = this.pongGame.update();
            let audioAmplitude = 0;

            if (gameUpdateResult.playerCollision || gameUpdateResult.aiCollision) {
                audioAmplitude = this.playSound('collision');
            }

            // AI decisions are now awaited
            const [mainDecision, opponentDecision] = await Promise.all([
                this.mainAI.makeDecision(preGameState, audioAmplitude),
                this.opponentAI.makeDecision(preGameState, audioAmplitude)
            ]);

            this.pongGame.setAIAction(mainDecision.action);
            this.pongGame.setPlayerAction(opponentDecision.action);

            const postGameState = this.pongGame.getState();

            await Promise.all([
                this.mainAI.learn(gameUpdateResult.aReward, postGameState, audioAmplitude),
                this.opponentAI.learn(gameUpdateResult.pReward, postGameState, audioAmplitude)
            ]);

            document.getElementById('player-score').textContent = this.pongGame.score.player;
            document.getElementById('ai-score').textContent = this.pongGame.score.ai;

            if (this.frameCount % 5 === 0 || isManualStep) { // Update visualization less frequently or on step
                this.mainViz.update(mainDecision.activations);
                this.opponentViz.update(opponentDecision.activations);
                this.updateVisualization();
            }

            this.pongGame.render(this.ctx);

            if (this.pongGame.gameOver) {
                this.stop();
                logger.info(`${this.pongGame.winner} wins the game!`);
            }

        } catch (error) {
            // Log the full error object for better debugging
            logger.error("Error in game loop, stopping simulation:", error);
            // Also print to console directly in case logger has issues
            console.error("Critical error in gameLoop, stopping:", error);
            this.stop(); 
        } finally {
            // The critical change: use isManualStep here.
            // When requestAnimationFrame calls, isManualStep will be false (its default).
            // When the step button calls, isManualStep will be true.
            if (this.isRunning && !isManualStep && !this.pongGame.gameOver) {
                requestAnimationFrame(this.boundGameLoop);
            }
        }
    }
    toggleGame() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) {
            logger.warn('AIs are not fully initialized yet. Please wait.');
            document.getElementById('status').textContent = 'AIs Not Ready - Please Wait...';
            return;
        }
        this.isRunning = !this.isRunning;
        const btn = document.getElementById('toggleSimButton');
        btn.textContent = this.isRunning ? '⏸️ Pause Simulation' : '🚀 Toggle Simulation';
        document.getElementById('status').textContent = this.isRunning ? 'Conscious AI Active' : this.pongGame.gameOver ? `${this.pongGame.winner} Wins! (Paused)` : 'Paused';
        if (this.isRunning) {
            this.audioContext.resume().catch(e => logger.error("Failed to resume AudioContext on toggle:", e));
            this.gameLoop(null, false); // Explicitly pass null for timestamp, false for manual step
            logger.info('Simulation started.');
        } else {
            logger.info('Simulation paused.');
        }
    }

    stop() {
        this.isRunning = false;
        document.getElementById('toggleSimButton').textContent = '🚀 Toggle Simulation';
        document.getElementById('status').textContent = this.pongGame?.gameOver ? `${this.pongGame.winner} Wins! (Paused)` : 'Paused';
        logger.info('Simulation stopped.');
    }

    start() {
        if (!this.ctx) {
            document.getElementById('status').textContent = 'Error: Canvas context missing. Cannot start game.';
            logger.error('Cannot start: Missing canvas context.');
            return;
        }
        if (this.pongGame?.gameOver) {
            this.resetAI();
        }
        if (!this.isRunning) {
            this.toggleGame();
        }
    }

    async resetAI() {
        this.stop();
        logger.info('Resetting all game and AI states...');
        showLoading('game', 'Resetting Game...');
        showLoading('mainBrain', 'Resetting Main AI...');
        showLoading('opponentBrain', 'Resetting Opponent AI...');
        showLoading('metrics', 'Resetting Metrics...');

        try {
            // Get current client dimensions for accurate reset
            const { clientWidth: w, clientHeight: h } = this.gameCanvas;
            this.pongGame = new PongGame(this.gameCanvas, w, h); // Re-initialize PongGame with current dimensions
            document.getElementById('player-score').textContent = 0;
            document.getElementById('ai-score').textContent = 0;
            await this.setupGameAndAIs(); // Re-initialize AI and world models, which will call this.start()
            this.frameCount = 0;
            document.getElementById('status').textContent = 'Ready';
            this.updateVisualization();
            this.pongGame.render(this.ctx);
            logger.info('All states reset successfully.');
        } catch (e) {
            logger.error('Error during reset:', e);
            document.getElementById('status').textContent = `Reset Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
        }
    }

    tuneParameters() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) {
            logger.warn('AIs are not fully initialized yet. Cannot tune parameters.');
            return;
        }
        this.mainAI_worldModel.qualiaSheaf.tuneParameters();
        this.opponent_worldModel.qualiaSheaf.tuneParameters();
        this.updateVisualization();
    }

    handleKeyDown(e) {
        switch (e.key) {
            case ' ': e.preventDefault(); this.toggleGame(); break;
            case 'r': case 'R': e.preventDefault(); this.resetAI(); break;
            case 't': case 'T': e.preventDefault(); this.tuneParameters(); break;
            case 'ArrowUp': e.preventDefault(); this.pongGame?.setPlayerAction([1, 0, 0]); break;
            case 'ArrowDown': e.preventDefault(); this.pongGame?.setPlayerAction([0, 1, 0]); break;
            case 'p': case 'P': e.preventDefault(); this.stop(); break;
            case 's': case 'S': e.preventDefault(); if (!this.isRunning) this.gameLoop(null, true); break; // Only step if paused
        }
    }

    handleKeyUp(e) {
        switch (e.key) {
            case 'ArrowUp':
            case 'ArrowDown': this.pongGame?.setPlayerAction([0, 0, 1]); break; // Player idle when key released
        }
    }
}
// --- App Initialization ---
        window.onload = async () => {
            function positionVertices() {
                const graph = document.getElementById('sheafGraph');
                if (!graph) return;
                const rect = graph.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const innerWidth = rect.width / dpr;
                const innerHeight = rect.height / dpr;

                for (let i = 0; i < 10; i++) {
                    const v = document.getElementById('vertex-' + i);
                    if (!v) continue;
                    const p = sheafVertexPositions[i] || { x: 0.5, y: 0.5 };
                    // Adjust position for vertex size (36px) and ensure it's within bounds
                    v.style.left = Math.round(p.x * (innerWidth - 36)) + 'px';
                    v.style.top = Math.round(p.y * (innerHeight - 36)) + 'px';
                }
            }

            window.addEventListener('resize', positionVertices);

            try {
                const app = new MainApp();
                positionVertices(); // Initial positioning
                logger.info('UI initialized — ready.');
                // App will start automatically after AIs are initialized in setupGameAndAIs
            } catch (e) {
                document.getElementById('status').textContent = `Initialization Error: ${e.message}`;
                logger.error('Initialization failed', e.message);
            }
        };
    </script>
</body>
</html>
