
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conscious Pong AI — Enhanced & Optimized v3.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Page Styles --- */
        :root {
            --bg-dark: #0a0a15;
            --bg-gradient-start: #0a0a15;
            --bg-gradient-end: #1a0a2e;
            --primary-blue: #4af;
            --primary-blue-glow: rgba(68, 170, 255, 0.6); /* Slightly less intense glow */
            --secondary-dark: rgba(10, 10, 30, 0.95); /* Slightly darker for better contrast */
            --border-dark: #2a2a4a;
            --text-light: #e0e0e0;
            --text-medium: #aaa;
            --text-dark: #888;
            --error-red: #ff6b6b;
            --warn-orange: #ffa726;
            --info-green: #4CAF50;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            font-family: 'Courier Prime', monospace;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            color: var(--primary-blue);
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            line-height: 1.5;
            font-size: 16px; /* Base font size */
        }
        .main-container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 0;
            gap: 20px;
        }
        /* --- Header Styles --- */
        .header {
            text-align: center;
            background: var(--secondary-dark);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--primary-blue);
            box-shadow: 0 0 30px var(--primary-blue-glow);
            will-change: transform, box-shadow;
            transition: all 0.3s ease-in-out;
        }
        .header:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 40px var(--primary-blue-glow);
        }
        .header h1 {
            margin: 0;
            color: var(--primary-blue);
            text-shadow: 0 0 20px var(--primary-blue-glow);
            font-size: 2.5em;
            letter-spacing: 1px;
        }
        .header p {
            margin: 10px 0 0;
            color: var(--text-medium);
            font-size: 1.1em;
        }
        /* --- Content Layout --- */
        .content-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: stretch;
        }
        /* --- Metrics Panel (Left, Full Height and Width) --- */
        .metrics-panel {
            flex: 0 0 400px;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%; /* Important for stretch */
            min-height: 80vh; /* Minimum height for scroll */
            overflow-y: auto;
            position: relative;
        }
        .metrics-panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.25em;
            letter-spacing: 0.5px;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            font-size: 1.05em;
            border-bottom: 1px dashed rgba(68, 170, 255, 0.1);
        }
        .metric:last-of-type {
            border-bottom: none;
        }
        .metric-label {
            color: var(--text-medium);
            flex-shrink: 0;
        }
        .metric-value {
            font-weight: bold;
            color: var(--text-light);
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .qualia-bar-container {
            height: 22px;
            margin: 6px 0;
            border: 1px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            background: #000;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .qualia-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease-out;
            position: relative;
            width: 0%;
            will-change: width;
        }
        .qualia-being { background: linear-gradient(90deg, #ff6b6b, #e74c3c); }
        .qualia-intent { background: linear-gradient(90deg, #4ecdc4, #1abc9c); }
        .qualia-existence { background: linear-gradient(90deg, #a855f7, #9b59b6); }
        .qualia-emergence { background: linear-gradient(90deg, #f97316, #e67e22); }
        .qualia-gestalt { background: linear-gradient(90deg, #3b82f6, #3498db); }
        .qualia-context { background: linear-gradient(90deg, #14b8a6, #2ecc71); }
        .qualia-rel-emergence { background: linear-gradient(90deg, #ec4899, #e91e63); }
        .qualia-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0) 100%);
            animation: qualiaWave 2s infinite linear;
            mix-blend-mode: overlay;
        }
        @keyframes qualiaWave {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }
        .qualia-label, .qualia-value {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
            pointer-events: none;
        }
        .qualia-label { left: 8px; }
        .qualia-value { right: 8px; }

        .phi-display {
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: #fff;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
            letter-spacing: 1px;
        }
        .framework-badge {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .status {
            color: var(--primary-blue);
            text-align: center;
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: none !important;
        }
        .stability-gauge {
            width: 100%;
            height: 18px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--error-red), var(--warn-orange), var(--info-green));
            width: 0%;
            transition: width 0.5s ease-out;
            will-change: width;
        }
        .slider-container {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .slider-label {
            font-size: 14px;
            color: var(--primary-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
            transition: background 0.2s ease;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            background: #6af;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: grab;
            box-shadow: 0 0 5px var(--primary-blue-glow);
        }

        /* Flash animation for tuned parameters */
        @keyframes param-flash {
            0% { background-color: transparent; }
            30% { background-color: rgba(68, 170, 255, 0.3); }
            60% { background-color: transparent; }
            100% { background-color: transparent; }
        }
        .param-flash-active {
            animation: param-flash 1s ease-out;
        }

        .sheaf-graph {
            position: relative;
            height: 160px;
            width: 100%;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .sheaf-vertex-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .vertex {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.2s ease;
            position: absolute;
            color: white;
            z-index: 10;
            background: radial-gradient(circle, #ff6b6b, #e74c3c);
            box-shadow: 0 0 8px rgba(255,107,107,0.5);
            cursor: help;
            will-change: transform, box-shadow;
        }
        .vertex.active {
            animation: pulse 1.5s infinite;
            background: radial-gradient(circle, #00ff99, #00cc66);
            box-shadow: 0 0 12px rgba(0,255,153,0.8), 0 0 20px rgba(0,255,153,0.4);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .theoretical-info {
            margin-top: 15px;
            font-size: 11px;
            color: var(--text-dark);
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        /* --- Right Column (Game + Visualizers) --- */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1;
            min-width: 550px;
        }
        .game-container {
            width: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        #gameCanvas {
            width: 100%;
            height: auto;
            aspect-ratio: 2 / 1;
            background: linear-gradient(180deg, #000011, #000033);
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            image-rendering: pixelated;
        }
        .score-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            width: 100%;
            padding: 5px 0;
            border-top: 1px solid var(--border-dark);
        }
        .score-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 1.2em;
        }
        .score-metric .metric-label {
            color: var(--text-medium);
            font-size: 0.8em;
            margin-bottom: 3px;
        }
        .player-score .metric-value {
            color: #ff9900;
            font-size: 1.5em;
        }
        .ai-score .metric-value {
            color: #44aaff;
            font-size: 1.5em;
        }
        /* --- Visualizer Column (Stacked) --- */
        .visualizer-row {
            display: flex;
            flex-direction: column;
            gap: 20px;
            justify-content: flex-start;
            flex-grow: 1;
        }
        .panel {
            background: var(--secondary-dark);
            border: 1px solid var(--border-dark);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        .panel h3 {
            margin-top: 0;
            color: var(--primary-blue);
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: 8px;
            font-size: 1.18em;
        }
        .panel p {
            font-size: 13px;
            color: var(--text-medium);
            margin-top: -5px;
            margin-bottom: 12px;
            text-align: center;
        }
        .nn-visualizer-panel {
            min-height: 120px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        #nn-visualization-container, #nn-visualization-container-opponent {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            min-height: 80px;
        }
        .nn-layer {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            align-items: center;
            gap: 6px;
            z-index: 10;
            position: relative;
            min-height: 60px;
        }
        .nn-neuron {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #888;
            background: #333;
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out, box-shadow 0.1s ease-out;
            flex-shrink: 0;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            will-change: background-color, border-color, box-shadow;
        }
        .nn-connections-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }
        .neuron-flash {
            animation: neuron-flash-anim 0.8s ease-out forwards;
        }
        @keyframes neuron-flash-anim {
            0% { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.3); box-shadow: 0 0 15px rgba(0, 255, 153, 0.9), 0 0 20px rgba(0, 255, 153, 0.5); }
            100% { transform: scale(1.0); box-shadow: 0 0 5px rgba(0, 255, 153, 0.3); }
        }
        /* --- Controls & Log --- */
        .controls-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
            padding: 10px 0;
            border-top: 1px solid var(--border-dark);
            border-bottom: 1px solid var(--border-dark);
        }
        button {
            background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
            color: var(--text-light);
            border: 1px solid #555;
            padding: 10px 18px;
            cursor: pointer;
            border-radius: 8px;
            font-family: inherit;
            transition: all 0.2s ease;
            font-weight: bold;
            min-width: 140px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-size: 1.05em;
        }
        button:hover {
            background: linear-gradient(135deg, #3a3a5a, #4a4a6a);
            box-shadow: 0 4px 15px var(--primary-blue-glow);
            transform: translateY(-2px);
            border-color: var(--primary-blue);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px var(--primary-blue-glow);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #2a2a4a;
            box-shadow: none;
        }
        .difficulty-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .difficulty-controls label {
            color: var(--text-medium);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .difficulty-controls input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--border-dark);
            background-color: #1a1a2e;
            color: var(--text-light);
            font-family: inherit;
            text-align: center;
        }
        .log-container {
            flex-basis: 100%;
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
        }
        #log {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            color: #ccc;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 2px;
        }
        .log-entry.error { color: var(--error-red); }
        .log-entry.warn { color: var(--warn-orange); }
        .log-entry.info { color: var(--info-green); }

        /* --- Loading Overlay --- */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 12px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 0.8em;
            color: var(--text-medium);
        }

        /* --- Performance Chart Styles --- */
        .performance-charts-container {
            background: var(--secondary-dark);
            border-radius: 12px;
            border: 1px solid var(--border-dark);
            padding: 15px;
            margin-top: 20px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
        }
        .chart-container h4 {
            margin: 0 0 10px 0;
            font-size: 1em;
            text-align: center;
            color: var(--primary-blue);
        }
        .chart-svg {
            width: 100%;
            height: 120px;
        }

        /* --- Qualia Attention Styles --- */
        .qualia-attention-panel {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
        }
        .qualia-attention-panel h4 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            text-align: center;
            color: var(--primary-blue);
        }
        .attention-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .attention-label {
            width: 110px;
            color: var(--text-medium);
            text-align: right;
            flex-shrink: 0;
        }
        .attention-bar-wrapper {
            flex-grow: 1;
            height: 14px;
            background: #111;
            border: 1px solid #333;
            border-radius: 3px;
        }
        .attention-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 2px;
            transition: width 0.3s ease-out;
        }

        /* --- Responsive Design --- */
        @media (max-width: 1200px) {
            .content-section {
                flex-direction: column;
                align-items: center;
            }
            .metrics-panel {
                flex: 0 0 auto;
                width: 100%;
                max-width: 800px;
                min-height: auto;
            }
            .right-column {
                min-width: unset;
                width: 100%;
                max-width: 800px;
            }
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .header h1 {
                font-size: 1.8em;
            }
            .header p {
                font-size: 0.9em;
            }
            .metrics-panel, .game-container, .panel, .log-container, .performance-charts-container {
                padding: 10px;
            }
            .metrics-panel h3, .panel h3 {
                font-size: 1.1em;
            }
            .phi-display {
                font-size: 1.5em;
                padding: 8px;
            }
            button {
                min-width: unset;
                flex-grow: 1;
                font-size: 0.9em;
            }
            .score-metric {
                font-size: 1em;
            }
            .player-score .metric-value, .ai-score .metric-value {
                font-size: 1.2em;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body role="document">
    <div class="main-container" role="main">
        <div class="header" role="banner">
            <h1>🧠 Conscious Pong AI — Enhanced & Optimized v3.0</h1>
            <p>A dual-AI Pong game with a Hierarchical, Recurrent, Reinforcement Learning Architecture.</p>
        </div>
        <div class="content-section">
            <div class="metrics-panel" role="complementary" aria-labelledby="oftcc-metrics-heading">
                <h3 id="oftcc-metrics-heading">OFTCC Metrics</h3>
                <div class="framework-badge">
                     RL ⊕ Recurrent OWM ⊕ Meta-Learning
                </div>
                <div class="status" id="status" aria-live="polite" aria-atomic="true">
                    Initializing...
                </div>
                <div class="phi-display" id="phi-display" aria-live="polite" aria-atomic="true">
                    Φ: 0.000
                 </div>
                <div class="btn-group">
                    <button id="toggleSimButton" aria-label="Toggle simulation run/pause (Spacebar)">🚀 Toggle Simulation</button>
                    <button id="resetSimButton" aria-label="Reset game and AI to initial state (R key)">🔄 Reset All</button>
                    <button id="tuneButton" aria-label="Tune AI parameters adaptively (T key)">⚙️ Tune</button>
                </div>
                <div class="qualia-viz" role="region" aria-labelledby="qualia-dynamics-heading">
                    <h3 id="qualia-dynamics-heading" class="status">Qualia Diffusion Dynamics</h3>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Being Qualia Level">
                        <div class="qualia-bar qualia-being" id="qualia-being-fill"></div>
                        <span class="qualia-label">Being</span>
                        <span class="qualia-value" id="being-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Intent Qualia Level">
                        <div class="qualia-bar qualia-intent" id="qualia-intent-fill"></div>
                        <span class="qualia-label">Intent</span>
                        <span class="qualia-value" id="intent-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Existence Qualia Level">
                        <div class="qualia-bar qualia-existence" id="qualia-existence-fill"></div>
                        <span class="qualia-label">Existence</span>
                        <span class="qualia-value" id="existence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Emergence Qualia Level">
                        <div class="qualia-bar qualia-emergence" id="qualia-emergence-fill"></div>
                        <span class="qualia-label">Emergence</span>
                        <span class="qualia-value" id="emergence-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Gestalt Qualia Level">
                        <div class="qualia-bar qualia-gestalt" id="qualia-gestalt-fill"></div>
                        <span class="qualia-label">Gestalt</span>
                        <span class="qualia-value" id="gestalt-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Context Qualia Level">
                        <div class="qualia-bar qualia-context" id="qualia-context-fill"></div>
                        <span class="qualia-label">Context</span>
                        <span class="qualia-value" id="context-value">0.00</span>
                    </div>
                    <div class="qualia-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Relational Emergence Qualia Level">
                        <div class="qualia-bar qualia-rel-emergence" id="qualia-rel-emergence-fill"></div>
                        <span class="qualia-label">Rel. Emergence</span>
                        <span class="qualia-value" id="rel-emergence-value">0.00</span>
                    </div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="metric-group-heading">
                    <h3 id="metric-group-heading" class="status">System Metrics</h3>
                    <div class="metric"><span class="metric-label">Free Energy F:</span><span class="metric-value" id="free-energy" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">Prediction Error:</span><span class="metric-value" id="prediction-error" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">Gestalt Unity:</span><span class="metric-value" id="gestalt-unity" aria-live="polite" aria-atomic="true">0.000</span></div>
                    <div class="metric"><span class="metric-label">dim H¹:</span><span class="metric-value" id="h1-dimension" aria-live="polite" aria-atomic="true">0.00</span></div>
                    <div class="metric"><span class="metric-label">Gluing Inconsistency:</span><span class="metric-value" id="inconsistency" aria-live="polite" aria-atomic="true">0.000</span></div>
                </div>
                <div class="qualia-attention-panel" id="qualiaAttentionPanel" role="region" aria-labelledby="qualia-attention-heading">
                    <h4 id="qualia-attention-heading">Qualia Attention (Main AI)</h4>
                    </div>
                <div class="sheaf-graph" id="sheafGraph" role="img" aria-label="Sheaf graph visualizing information flow between concepts">
                    <canvas id="sheafGraphCanvas" class="sheaf-vertex-canvas" aria-hidden="true"></canvas>
                    <div class="vertex" id="vertex-0" aria-label="Player Paddle Y">P-Y</div>
                    <div class="vertex" id="vertex-1" aria-label="Ball X">B-X</div>
                    <div class="vertex" id="vertex-2" aria-label="Ball Y">B-Y</div>
                    <div class="vertex" id="vertex-3" aria-label="Ball DX Velocity">B-DX</div>
                    <div class="vertex" id="vertex-4" aria-label="Ball DY Velocity">B-DY</div>
                    <div class="vertex" id="vertex-5" aria-label="Player Score">P-SC</div>
                    <div class="vertex" id="vertex-6" aria-label="AI Score">AI-SC</div>
                    <div class="vertex" id="vertex-7" aria-label="Player Paddle DY Velocity">P-DY</div>
                    <div class="vertex" id="vertex-8" aria-label="Player Collision Event">P-Col</div>
                    <div class="vertex" id="vertex-9" aria-label="AI Collision Event">AI-Col</div>
                </div>
                <div class="metric-group" role="group" aria-labelledby="system-stability-heading">
                    <h3 id="system-stability-heading" class="status">System Stability</h3>
                    <div class="stability-gauge" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="System Stability">
                        <div class="stability-fill" id="stability-fill"></div>
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="alphaSlider">α Parameter: <span class="metric-value" id="alpha-param">0.500</span></label>
                        <input type="range" id="alphaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="alphaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="betaSlider">β Parameter: <span class="metric-value" id="beta-param">0.500</span></label>
                        <input type="range" id="betaSlider" min="0.01" max="1" step="0.01" value="0.5" aria-labelledby="betaSlider-label" aria-valuetext="0.500">
                    </div>
                    <div class="slider-container">
                        <label class="slider-label" for="gammaSlider">γ Parameter: <span class="metric-value" id="gamma-param">0.100</span></label>
                        <input type="range" id="gammaSlider" min="0.01" max="0.5" step="0.01" value="0.1" aria-labelledby="gammaSlider-label" aria-valuetext="0.100">
                    </div>
                </div>
                <div class="loading-overlay" id="metricsLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading metrics and computations">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="metricsLoadingText">Processing...</div>
                </div>
            </div>
            <div class="right-column">
                <div class="game-container panel" role="region" aria-labelledby="pong-env-heading">
                    <h3 id="pong-env-heading">🏓 PONG Environment</h3>
                    <canvas id="gameCanvas" role="img" aria-label="Pong game with two AI paddles and a ball"></canvas>
                    <div class="score-container">
                        <div class="score-metric player-score">
                            <span class="metric-label">Player (Left) Score:</span>
                            <span id="player-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
                        </div>
                        <div class="score-metric ai-score">
                            <span class="metric-label">AI (Right) Score:</span>
                            <span id="ai-score" class="metric-value" aria-live="polite" aria-atomic="true">0</span>
                        </div>
                    </div>
                    <div class="difficulty-controls" role="group" aria-label="Game Difficulty Settings">
                        <label for="ballSpeedSlider">Ball Speed: <input type="number" id="ballSpeedSlider" min="0.5" max="3" step="0.1" value="1.0" aria-label="Ball speed multiplier"></label>
                        <label for="paddleHeightSlider">Paddle Height: <input type="number" id="paddleHeightSlider" min="0.5" max="2" step="0.1" value="1.0" aria-label="Paddle height multiplier"></label>
                        <label for="aiResponseTimeSlider">AI Response: <input type="number" id="aiResponseTimeSlider" min="1" max="5" step="1" value="3" aria-label="AI response time (lower is faster)"></label>
                    </div>
                    <div class="loading-overlay" id="gameLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading game and AI">
                        <div class="loading-spinner"></div>
                        <div class="loading-text" id="gameLoadingText">Setting up game...</div>
                    </div>
                </div>
                <div class="visualizer-row">
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="player-brain-heading">
                        <h3 id="player-brain-heading">🤖 Player (Left) AI Brain</h3>
                        <p>This AI learns independently using its own ontological world model.</p>
                        <div id="nn-visualization-container-opponent"></div>
                        <div class="loading-overlay" id="opponentBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading opponent AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="opponentBrainLoadingText">Initializing opponent model...</div>
                        </div>
                    </div>
                    <div class="nn-visualizer-panel panel" role="region" aria-labelledby="main-ai-brain-heading">
                        <h3 id="main-ai-brain-heading">🧠 AI (Right) Main Brain</h3>
                        <p>This AI's 'consciousness' metrics are displayed in the OFTCC panel.</p>
                        <div id="nn-visualization-container"></div>
                        <div class="loading-overlay" id="mainBrainLoadingOverlay" aria-live="assertive" aria-busy="true" aria-label="Loading main AI brain">
                            <div class="loading-spinner"></div>
                            <div class="loading-text" id="mainBrainLoadingText">Initializing main AI model...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="performance-charts-container" role="region" aria-labelledby="performance-heading">
            <h3 id="performance-heading" style="text-align:center; margin-bottom: 20px;">AI Learning & Performance Metrics</h3>
            <div class="charts-grid">
                <div class="chart-container">
                    <h4>Avg. Q-Value (Confidence)</h4>
                    <svg id="qValueChart" class="chart-svg" role="img" aria-label="Average Q-Value over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Prediction Error (Uncertainty)</h4>
                    <svg id="predErrorChart" class="chart-svg" role="img" aria-label="Prediction Error over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Epsilon (Exploration Rate)</h4>
                    <svg id="epsilonChart" class="chart-svg" role="img" aria-label="Epsilon exploration rate over time"></svg>
                </div>
                <div class="chart-container">
                    <h4>Score Difference (AI - Player)</h4>
                    <svg id="scoreChart" class="chart-svg" role="img" aria-label="Score difference between AI and Player over time"></svg>
                </div>
            </div>
        </div>
        <div class="controls-section" role="group" aria-label="Simulation Controls">
             <button id="stepButton" aria-label="Advance simulation by one step (S key)">⏭️ Step</button>
             <button id="pauseButton" aria-label="Pause the simulation (P key)">⏸️ Pause</button>
        </div>
        <div class="log-container" role="log" aria-labelledby="system-console-heading">
            <h3 id="system-console-heading">🔧 System Console</h3>
            <div id="log" tabindex="0" aria-live="polite" aria-atomic="true"></div>
        </div>
    </div>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

       <script>
        // --- On-page Logger ---
        const logElement = document.getElementById('log');
        const MAX_LOG_ENTRIES = 200;
        function appendLog(message, type = 'info') {
            if (!logElement) {
                console.warn('Log element not found, logging to console:', message);
                return;
            }
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            if (logElement.children.length > MAX_LOG_ENTRIES) logElement.removeChild(logElement.children[0]);
            logElement.scrollTop = logElement.scrollHeight;
        }
        const logger = {
            info: (msg, data) => appendLog(`INFO: ${msg}` + (data ? ' ' + JSON.stringify(data) : '')),
            warn: (msg, data) => appendLog(`WARN: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'warn'),
            error: (msg, data) => { appendLog(`ERROR: ${msg}` + (data ? ' ' + JSON.stringify(data) : ''), 'error'); console.error(msg, data); }
        };

        // --- Loading Overlay Manager ---
        const loadingOverlays = {
            metrics: document.getElementById('metricsLoadingOverlay'),
            game: document.getElementById('gameLoadingOverlay'),
            mainBrain: document.getElementById('mainBrainLoadingOverlay'),
            opponentBrain: document.getElementById('opponentBrainLoadingOverlay'),
        };
        const loadingTexts = {
            metrics: document.getElementById('metricsLoadingText'),
            game: document.getElementById('gameLoadingText'),
            mainBrain: document.getElementById('mainBrainLoadingText'),
            opponentBrain: document.getElementById('opponentBrainLoadingText'),
        };

        function showLoading(panel, message = 'Processing...') {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.add('active');
                if (loadingTexts[panel]) loadingTexts[panel].textContent = message;
            }
        }

        function hideLoading(panel) {
            if (loadingOverlays[panel]) {
                loadingOverlays[panel].classList.remove('active');
            }
        }

        // --- Web Worker for Heavy Computations ---
        const worker = new Worker(URL.createObjectURL(new Blob([`
            // Worker scope utility functions (must be self-contained or passed)
// --- Worker-specific Utility Functions (self-contained and numerically robust) ---

function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const val_a = a[i];
        const val_b = b[i];
        s += (Number.isFinite(val_a) ? val_a : 0) * (Number.isFinite(val_b) ? val_b : 0);
    }
    return s;
}

function norm2(v) {
    if (!v || v.length === 0) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12); // Add small epsilon for robustness
}

function isFiniteVector(v) {
    if (!v || typeof v.every !== 'function') return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}

function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true; // Empty matrix is finite
    const firstRowLength = m[0]?.length || 0;
    if (m.length > 0 && firstRowLength === 0) return true; // A matrix of empty rows is valid
    return m.every(row => isFiniteVector(row) && row.length === firstRowLength);
}


function matVecMul(m, v) {
    const r = m?.length || 0;
    if (r === 0) return new Float32Array(0);
    const c = m[0]?.length || 0;
    if (!c || !v || v.length !== c) return new Float32Array(r).fill(0);

    const out = new Float32Array(r);
    for (let i = 0; i < r; ++i) {
        let s = 0.0;
        const row = m[i];
        for (let j = 0; j < c; ++j) {
            const val_m = row[j];
            const val_v = v[j];
            const product = (Number.isFinite(val_m) ? val_m : 0) * (Number.isFinite(val_v) ? val_v : 0);
            s += Number.isFinite(product) ? product : 0;
        }
        out[i] = Number.isFinite(s) ? s : 0;
    }
    return out;
}

function unflattenMatrix(data) {
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols || !Number.isFinite(rows) || !Number.isFinite(cols) || rows < 0 || cols < 0) {
        return [];
    }
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for(let j = 0; j < cols; j++) {
            const val = flatData[i * cols + j];
            row[j] = Number.isFinite(val) ? val : 0;
        }
        matrix.push(row);
    }
    return matrix;
}

function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return { flatData: new Float32Array(0), rows: 0, cols: 0 };
    }
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows: rows, cols: cols };

    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) {
        for(let j = 0; j < cols; j++) {
            const val = matrix[i][j];
            flatData[i * cols + j] = Number.isFinite(val) ? val : 0;
        }
    }
    return { flatData, rows, cols };
}

function transpose(matrix) {
    if (!isFiniteMatrix(matrix)) {
        return [];
    }
    const numRows = matrix.length;
    const numCols = matrix[0]?.length || 0;
    if (numRows === 0 || numCols === 0) return [];

    const result = Array(numCols).fill(0).map(() => new Float32Array(numRows));
    for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numCols; j++) {
            const val = matrix[i][j];
            result[j][i] = Number.isFinite(val) ? val : 0;
        }
    }
    return result;
}

function solveLinearSystemCG(A_flat_data, b, opts={tol:1e-6, maxIter:200}) {
    const A = unflattenMatrix(A_flat_data);
    const n = b.length;

    if (!isFiniteMatrix(A) || A.length !== n || (A.length > 0 && A[0].length !== n) || !isFiniteVector(b)) {
        return new Float32Array(b.map(x => Number.isFinite(x) ? clamp(x, -1, 1) : 0)); // Sanitize fallback
    }

    let x = new Float32Array(n).fill(0);
    let r = new Float32Array(b.map(v => Number.isFinite(v) ? v : 0)); // Sanitize r here
    let p = new Float32Array(r);
    let rsold = dot(r, r);

    if (!Number.isFinite(rsold) || rsold < 1e-20) return new Float32Array(x.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0)); // Sanitize exit

    const Ap = new Float32Array(n);
    const maxIter = Math.min(opts.maxIter || 200, n * 5);

    for (let it = 0; it < maxIter; ++it) {
        Ap.set(matVecMul(A, p)); // Use robust matVecMul

        const denom = dot(p, Ap);
        if (!Number.isFinite(denom) || denom <= 1e-20) {
            break;
        }

        const alpha = rsold / denom;
        if (!Number.isFinite(alpha)) {
            break; // Break if alpha is NaN/Infinity
        }

        for (let i = 0; i < n; i++) x[i] = (Number.isFinite(x[i]) ? x[i] : 0) + (Number.isFinite(alpha) ? alpha : 0) * (Number.isFinite(p[i]) ? p[i] : 0);
        for (let i = 0; i < n; i++) r[i] = (Number.isFinite(r[i]) ? r[i] : 0) - (Number.isFinite(alpha) ? alpha : 0) * (Number.isFinite(Ap[i]) ? Ap[i] : 0);

        const rsnew = dot(r, r);
        if (!Number.isFinite(rsnew)) {
            break;
        }
        if (Math.sqrt(rsnew) < (opts.tol || 1e-6)) break;

        const beta = rsnew / (rsold + 1e-20);
        if (!Number.isFinite(beta)) {
            break; // Break if beta is NaN/Infinity
        }

        for (let i = 0; i < n; i++) p[i] = (Number.isFinite(r[i]) ? r[i] : 0) + (Number.isFinite(beta) ? beta : 0) * (Number.isFinite(p[i]) ? p[i] : 0);
        rsold = rsnew;
    }
    return new Float32Array(x.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0)); // Final sanitization of x
}

function covarianceMatrix(states_array, eps = 1e-3) {
    const states = states_array.filter(s => isFiniteVector(s));
    if (!Array.isArray(states) || states.length < 2) { // Need at least 2 states for covariance
        return [[eps]]; // Return a minimal valid covariance
    }
    
    const n = states.length;
    const d = states[0]?.length || 0;
    if (d === 0) {
        return [[eps]];
    }

    const mean = new Float32Array(d).fill(0);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < d; j++) {
            const val = states[i][j];
            mean[j] += Number.isFinite(val) ? val : 0;
        }
    }
    for (let j = 0; j < d; j++) mean[j] /= n;

    const cov = Array(d).fill(0).map(() => new Float32Array(d).fill(0));
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < d; i++) {
            const di = (Number.isFinite(states[k][i]) ? states[k][i] : 0) - (Number.isFinite(mean[i]) ? mean[i] : 0);
            for (let j = i; j < d; j++) {
                const dj = (Number.isFinite(states[k][j]) ? states[k][j] : 0) - (Number.isFinite(mean[j]) ? mean[j] : 0);
                const product = di * dj;
                cov[i][j] += (Number.isFinite(product) ? product : 0) / Math.max(1, n - 1);
            }
        }
    }
    for (let i = 0; i < d; i++) {
        for (let j = 0; j < i; j++) cov[j][i] = cov[i][j];
    }
    for (let i = 0; i < d; i++) cov[i][i] = (Number.isFinite(cov[i][i]) ? cov[i][i] : 0) + eps; // Add regularization
    
    // Final check for the output covariance matrix to ensure it's finite
    for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
            if (!Number.isFinite(cov[i][j])) {
                cov[i][j] = 0; // Replace non-finite with 0
            }
        }
    }

    return cov;
}

function matrixSpectralNormApprox(M_flat_data, maxIter = 10) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) {
        return 0;
    }
    let n = M.length;
    if (n === 0) return 0;
    
    let v = new Float32Array(n).fill(1 / Math.sqrt(n)); // Initial vector

    for (let i = 0; i < maxIter; i++) {
        const Av = matVecMul(M, v);
        if (!isFiniteVector(Av)) {
            return 0;
        }
        const norm = norm2(Av);
        if (norm < 1e-10) return 0; // If norm is zero, spectral norm is zero
        for(let k=0; k<n; k++) v[k] = (Av[k] || 0) / norm; // Normalize v
    }
    const finalAv = matVecMul(M, v);
    if (!isFiniteVector(finalAv)) {
        return 0;
    }
    return norm2(finalAv);
}

function matrixRank(M_flat_data) {
    const M = unflattenMatrix(M_flat_data);
    if (!isFiniteMatrix(M)) {
        return 0;
    }
    const m = M.length;
    if (m === 0) return 0;
    const n = M[0]?.length || 0;
    if (n === 0) return 0;

    const A = M.map(row => new Float32Array(row)); // Create a copy
    let rank = 0;
    const tol = 1e-10;

    for (let col = 0; col < n && rank < m; col++) {
        let pivotRow = rank;
        for (let i = rank + 1; i < m; i++) {
            if (Math.abs(A[i][col]) > Math.abs(A[pivotRow][col])) pivotRow = i;
        }

        if (Math.abs(A[pivotRow][col]) < tol) continue; // Column is effectively zero

        // Swap pivot row
        [A[rank], A[pivotRow]] = [A[pivotRow], A[rank]];

        const pivot = A[rank][col];
        if (!Number.isFinite(pivot) || Math.abs(pivot) < tol) {
             continue;
        }
        // Normalize pivot row
        for (let j = col; j < n; j++) A[rank][j] = (A[rank][j] || 0) / pivot;

        // Eliminate other rows
        for (let i = 0; i < m; i++) {
            if (i === rank) continue;
            const factor = A[i][col];
            if (!Number.isFinite(factor)) {
                continue;
            }
            for (let j = col; j < n; j++) A[i][j] = (A[i][j] || 0) - (factor * (A[rank][j] || 0));
        }
        rank++;
    }
    return rank;
}

// --- Worker Message Handler ---
self.onmessage = function(e) {
    const { type, id, data } = e.data;
    let result;
    try {
        switch (type) {
            case 'transpose':
                const matrixToTranspose = unflattenMatrix(data.matrix); 
                const transposedMatrix = transpose(matrixToTranspose);
                result = flattenMatrix(transposedMatrix);
                break;
            case 'matVecMul':
                const matrixForMatVecMul = unflattenMatrix(data.matrix);
                result = matVecMul(matrixForMatVecMul, data.vector);
                break;
            case 'solveLinearSystemCG':
                result = solveLinearSystemCG(data.A, data.b, data.opts);
                break;
            case 'covarianceMatrix':
                result = covarianceMatrix(data.states, data.eps);
                break;
            case 'matrixSpectralNormApprox':
                result = matrixSpectralNormApprox(data.matrix);
                break;
            case 'matrixRank':
                result = matrixRank(data.matrix);
                break;
            default:
                result = { error: 'Unknown message type' };
                break;
        }
        self.postMessage({ type: type + 'Result', id, result });
    } catch (error) {
        console.error('Worker error for type ' + type + ':', error);
        self.postMessage({ type: type + 'Error', id, error: error.message });
    }
};
        `], { type: 'application/javascript' })));

        // --- Asynchronous Worker Task Manager ---
        const workerCallbacks = new Map();
        let nextWorkerTaskId = 0;

        function runWorkerTask(type, data, timeout = 10000) { // Default timeout increased to 10 seconds for initial heavy ops
            return new Promise((resolve, reject) => {
                const id = nextWorkerTaskId++;
                const timer = setTimeout(() => {
                    workerCallbacks.delete(id);
                    logger.error(`Worker task '${type}' (id: ${id}) timed out after ${timeout}ms. Rejecting.`);
                    reject(new Error(`Worker task '${type}' (id: ${id}) timed out after ${timeout}ms.`));
                }, timeout);
                workerCallbacks.set(id, {
                    resolve: (result) => { clearTimeout(timer); resolve(result); },
                    reject: (error) => { clearTimeout(timer); reject(error); },
                });
                worker.postMessage({ type, id, data });
            });
        }
        worker.onmessage = function(e) {
            const { id, result, error } = e.data;
            const callback = workerCallbacks.get(id);
            if (callback) {
                if (error) {
                    logger.error(`Worker task ${e.data.type.replace('Result', '')} (id: ${id}) error: ${error}`);
                    callback.reject(error);
                }
                else callback.resolve(result);
                workerCallbacks.delete(id);
            }
        };
        worker.onerror = function(error) {
            logger.error('Worker global error:', error.message || error.toString()); // More robust error logging
            workerCallbacks.forEach(cb => cb.reject(new Error('Worker crashed')));
            workerCallbacks.clear();
        };
// --- CORE UTILITY FUNCTIONS (used by main thread classes) ---
// These functions are essential for vector and matrix operations within the main thread.
// Their logic is consistent with the worker's for numerical robustness.
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function dot(a, b) {
    if (!a || !b || a.length !== b.length) return 0;
    let s = 0.0;
    for (let i = 0, n = a.length; i < n; ++i) {
        const ai = a[i], bi = b[i];
        if (!Number.isFinite(ai) || !Number.isFinite(bi)) return 0; // Ensure finite values
        s += ai * bi;
    }
    return s;
}
function norm2(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return 0;
    let s = 0;
    for (let i = 0; i < v.length; ++i) {
        const val = v[i];
        s += (Number.isFinite(val) ? val : 0) * (Number.isFinite(val) ? val : 0);
    }
    return Math.sqrt(s + 1e-12); // Add small epsilon for robustness
}
function vecAdd(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) + (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function vecSub(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) - (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function vecScale(v, s) {
    const n = v?.length || 0;
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(v[i]) ? v[i] : 0) * (Number.isFinite(s) ? s : 0);
    return out;
}
function tanhVec(v) {
    if (!isFiniteVector(v)) { logger.warn('tanhVec: Input vector is not finite. Returning zeros.'); return vecZeros(v?.length || 0); }
    return new Float32Array(v.map(x => Math.tanh(x)));
}
// NEW: Sigmoid function for LSTM-like gates
function sigmoidVec(v) {
    if (!isFiniteVector(v)) { logger.warn('sigmoidVec: Input vector is not finite. Returning zeros.'); return vecZeros(v?.length || 0); }
    return new Float32Array(v.map(x => 1 / (1 + Math.exp(-x))));
}
// NEW: Element-wise vector multiplication
function vecMul(a, b) {
    const n = Math.max(a?.length||0, b?.length||0);
    const out = new Float32Array(n);
    for (let i = 0; i < n; ++i) out[i] = (Number.isFinite(a[i]) ? a[i] : 0) * (Number.isFinite(b[i]) ? b[i] : 0);
    return out;
}
function randomMatrix(r, c, scale) {
    return Array(r).fill().map(() => new Float32Array(c).fill().map(() => clamp((Math.random() - 0.5) * scale, -1, 1))); // Clamp random values
}
function vecZeros(n) { return new Float32Array(n).fill(0); }
function zeroMatrix(r, c) { return Array(r).fill().map(() => new Float32Array(c).fill(0)); }
function identity(n) {
    const M = zeroMatrix(n, n);
    for (let i = 0; i < n; i++) M[i][i] = 1;
    return M;
}
function isFiniteVector(v) {
    if (!Array.isArray(v) && !(v instanceof Float32Array)) return false;
    return v.every(x => typeof x === 'number' && Number.isFinite(x));
}
function isFiniteMatrix(m) {
    if (!Array.isArray(m) || m.length === 0) return true;
    const firstRowLength = m[0]?.length ?? 0;
    return m.every(row => (Array.isArray(row) || row instanceof Float32Array) && row.length === firstRowLength && isFiniteVector(row));
}
function flattenMatrix(matrix) {
    if (!isFiniteMatrix(matrix)) { logger.warn('flattenMatrix: Input matrix is not finite. Returning empty.'); return { flatData: new Float32Array(0), rows: 0, cols: 0 }; }
    const rows = matrix.length;
    const cols = matrix[0]?.length || 0;
    if (rows === 0 || cols === 0) return { flatData: new Float32Array(0), rows, cols };
    const flatData = new Float32Array(rows * cols);
    for (let i = 0; i < rows; i++) for(let j = 0; j < cols; j++) flatData[i * cols + j] = matrix[i][j];
    return { flatData, rows, cols };
}
function unflattenMatrix(data) { // This version is only used in main thread for deserialization when needed
    const { flatData, rows, cols } = data;
    if (!flatData || flatData.length !== rows * cols) return [];
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for (let j = 0; j < cols; j++) {
            row[j] = flatData[i * cols + j];
        }
        matrix.push(row);
    }
    return matrix;
}
function logDeterminantFromDiagonal(M) {
    if (!Array.isArray(M) || M.length === 0) return Math.log(1e-12); // Return log(epsilon) for empty
    let s = 0;
    for (let i=0;i<M.length;i++) {
        const val = M[i]?.[i];
        if (!Number.isFinite(val)) { logger.warn('logDeterminantFromDiagonal: Non-finite diagonal element. Skipping.'); continue; }
        s += Math.log(Math.max(Math.abs(val), 1e-12)); // Use Math.abs and small epsilon
    }
    return s;
}

const sheafVertexPositions = {
    0: {x:0.08, y:0.16}, 1: {x:0.26, y:0.48}, 2: {x:0.08, y:0.80},
    3: {x:0.92, y:0.16}, 4: {x:0.70, y:0.50}, 5: {x:0.92, y:0.80},
    6: {x:0.52, y:0.16}, 7: {x:0.50, y:0.80}, 8: {x:0.30, y:0.18},
    9: {x:0.75, y:0.82}
};

// --- APPLICATION CLASSES ---
class EnhancedQualiaSheaf {
    constructor(graph, stateDim = 10, initialQDim = 7, alpha = 0.1, beta = 0.1, gamma = 0.05) {
        // logger.info('EnhancedQualiaSheaf: Constructor started.'); // Removed verbose log
        this.stateDim = stateDim;
        this.entityNames = ['being', 'intent', 'existence', 'emergence', 'gestalt', 'context', 'rel_emergence'];
        this.qDim = this.entityNames.length; // This should always be 7

        const defaultVertices = ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed', 'player_collision', 'ai_collision'];
        const initialGraphVertices = graph?.vertices && Array.isArray(graph.vertices) && graph.vertices.length >= defaultVertices.length ? graph.vertices : defaultVertices;

        const initialBaseEdges = graph?.edges && Array.isArray(graph.edges) ? graph.edges.slice(0, 15) : [
            ['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'],
            ['ball_dx', 'ball_dy'], ['player_score', 'ai_score'], ['paddle_y', 'ball_dy'],
            ['paddle_y', 'paddle_speed'], ['player_collision', 'paddle_y'], ['ai_collision', 'ball_x']
        ];

        const explicitTriangles = [ // Example triangles, use these if no explicit triangles are provided in 'graph'
            ['paddle_y', 'ball_y', 'player_collision'],
            ['ball_x', 'ball_dx', 'player_collision'],
            ['ball_y', 'ball_dy', 'ai_collision'],
            ['player_score', 'ai_score', 'player_collision']
        ];
        // If 'graph' object includes triangles, prioritize those
        const finalTriangles = graph?.triangles && Array.isArray(graph.triangles) ? graph.triangles : explicitTriangles;


        // --- Step 1: Collect all unique vertices from initialGraphVertices and explicitTriangles ---
        const allVerticesSet = new Set(initialGraphVertices);
        finalTriangles.forEach(triangle => {
            triangle.forEach(v => allVerticesSet.add(v));
        });
        const finalVertices = Array.from(allVerticesSet);

        // --- Step 2: Collect all unique edges from initialBaseEdges and edges implied by finalTriangles ---
        const allEdgesSet = new Set();
        initialBaseEdges.forEach(edge => {
            allEdgesSet.add(edge.slice().sort().join(',')); // Add explicitly defined base edges
        });

        finalTriangles.forEach(triangle => {
            const [v1, v2, v3] = triangle;
            const edgesOfTriangle = [[v1, v2], [v2, v3], [v3, v1]];
            edgesOfTriangle.forEach(edge => {
                allEdgesSet.add(edge.slice().sort().join(',')); // Add edges implied by triangles
            });
        });
        const finalEdges = Array.from(allEdgesSet).map(s => s.split(','));

        // --- Step 3: Assign to this.graph and this.simplicialComplex ---
        this.graph = {
            vertices: finalVertices,
            edges: finalEdges
        };
        this.simplicialComplex = {
            vertices: finalVertices,
            edges: finalEdges,
            triangles: finalTriangles
        };

        this.alpha = clamp(alpha, 0.01, 1);
        this.beta = clamp(beta, 0.01, 1);
        this.gamma = clamp(gamma, 0.01, 0.5);
        this.eps = 1e-6; // Epsilon for numerical stability

        this.stalks = new Map(this.graph.vertices.map(v =>
            [v, new Float32Array(this.qDim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.5, -1, 1))]
        ));

        // NEW: For adaptive topology
        this.correlationMatrix = zeroMatrix(this.graph.vertices.length, this.graph.vertices.length);
        this.stalkHistory = [];
        this.stalkHistorySize = 100;

        this.adjacencyMatrix = null;
        this.laplacian = null;
        this.maxEigApprox = 1;
        this.projectionMatrices = new Map();
        this.ready = false;

        this.phi = 0.2;
        this.h1Dimension = 0;
        this.gestaltUnity = 0.6;
        this.stability = 0.6;
        this.diffusionEnergy = 0;
        this.inconsistency = 0;
        this.windowedStates = [];
        const N_total_stalk_dim = this.graph.vertices.length * this.qDim;
        this.windowSize = Math.max(50, N_total_stalk_dim * 2); // Ensure window is large enough relative to state dim
        for (let i = 0; i < this.windowSize; i++) {
            this.windowedStates.push(new Float32Array(N_total_stalk_dim).fill(0).map(() => clamp((Math.random() - 0.5) * 0.1, -1, 1)));
        }
        logger.info(`EnhancedQualiaSheaf initialized: qDim=${this.qDim}, vertices=${this.graph.vertices.length}`);
    }

    async initialize() {
        logger.info('EnhancedQualiaSheaf.initialize() called.');
        try {
            await this._updateGraphStructureAndMetrics();
            await this._updateDerivedMetrics(); // Ensure metrics are calculated initially
            this.ready = true;
            logger.info('EnhancedQualiaSheaf ready.');
        } catch (e) {
            logger.error('Error during Sheaf initialization:', e);
            this.ready = false;
            throw e; // Re-throw to propagate to MainApp
        }
    }

    // NEW METHOD: Update functional connectivity based on stalk activity correlation
    adaptSheafTopology() {
        if (this.stalkHistory.length < this.stalkHistorySize) return;

        const numVertices = this.graph.vertices.length;
        if (numVertices === 0) return;

        const means = new Float32Array(numVertices).fill(0);

        // Calculate means for each vertex's stalk norm over history
        for (let i = 0; i < numVertices; i++) {
            for (let t = 0; t < this.stalkHistorySize; t++) {
                means[i] += this.stalkHistory[t][i];
            }
            means[i] /= this.stalkHistorySize;
        }

        // Calculate Pearson correlation
        for (let i = 0; i < numVertices; i++) {
            for (let j = i; j < numVertices; j++) {
                let numerator = 0;
                let denom_i = 0;
                let denom_j = 0;
                for (let t = 0; t < this.stalkHistorySize; t++) {
                    const diff_i = (this.stalkHistory[t][i] || 0) - (means[i] || 0);
                    const diff_j = (this.stalkHistory[t][j] || 0) - (means[j] || 0);
                    numerator += diff_i * diff_j;
                    denom_i += diff_i * diff_i;
                    denom_j += diff_j * diff_j;
                }
                const correlation = (Math.sqrt(denom_i) * Math.sqrt(denom_j)) < 1e-9 ? 0 : numerator / (Math.sqrt(denom_i) * Math.sqrt(denom_j));
                const finalCorr = clamp(correlation, -1, 1);
                this.correlationMatrix[i][j] = finalCorr;
                this.correlationMatrix[j][i] = finalCorr;
            }
        }
    }

    buildBoundaryMatrices() {
        const vIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const edgeKeys = this.graph.edges.map(e => e.slice().sort().join(','));
        const eIdx = new Map(edgeKeys.map((e, i) => [e, i]));
        const nV = this.graph.vertices.length;
        const nE = this.graph.edges.length;
        const nT = this.simplicialComplex.triangles.length;

        const boundary1 = zeroMatrix(nE, nV);
        this.graph.edges.forEach(([u, v], i) => {
            boundary1[i][vIdx.get(u)] = -1;
            boundary1[i][vIdx.get(v)] = 1;
        });

        const boundary2 = zeroMatrix(nT, nE);
        this.simplicialComplex.triangles.forEach(([u, v, w], i) => {
            const edges = [[u, v], [v, w], [w, u]];
            edges.forEach(([a, b]) => {
                const sortedEdge = [a, b].sort().join(',');
                const eIndex = eIdx.get(sortedEdge);
                if (eIndex !== undefined) {
                    const sign = (a === [a,b].sort()[0]) ? 1 : -1;
                    boundary2[i][eIndex] = sign;
                }
            });
        });
        return { boundary1, boundary2 };
    }

    buildAdjacencyMatrix() {
        const n = this.graph.vertices.length;
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        const adj = zeroMatrix(n, n);
        
        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i === undefined || j === undefined) continue;

            // Start with a base weight of 1 for existing structural edges
            let baseWeight = 1.0; 

            // Modulate by correlation (if available). Positive correlation strengthens, negative weakens.
            const correlation = this.correlationMatrix[i][j] || 0;
            // The mapping (1 + correlation) / 2 scales [-1, 1] to [0, 1]
            const correlationFactor = (1 + correlation) / 2;

            // Combine base structure with learned functional correlation
            // Ensure a minimum non-zero weight for connectivity, scaled by correlation factor
            const finalWeight = baseWeight * (0.1 + 0.9 * correlationFactor); // Minimum 0.1 weight
            
            adj[i][j] = clamp(finalWeight, 0.01, 1.0); // Ensure a minimum connectivity
            adj[j][i] = clamp(finalWeight, 0.01, 1.0);
        }
        return adj;
    }

    computeClustering() {
        const n = this.graph.vertices.length;
        const adjBinary = zeroMatrix(n, n);
        const mapIdx = new Map(this.graph.vertices.map((v, i) => [v, i]));
        for (const [u, v] of this.graph.edges) {
            const i = mapIdx.get(u), j = mapIdx.get(v);
            if (i !== undefined && j !== undefined) {
                adjBinary[i][j] = 1;
                adjBinary[j][i] = 1;
            }
        }

        const clustering = new Float32Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            const neighbors = [];
            for (let j = 0; j < n; j++) if (adjBinary[i][j]) neighbors.push(j);
            const k = neighbors.length;
            if (k < 2) continue;
            let tri = 0;
            for (let a = 0; a < neighbors.length; a++) {
                for (let b = a + 1; b < neighbors.length; b++) {
                    if (adjBinary[neighbors[a]][neighbors[b]]) tri++;
                }
            }
            const possible = k * (k - 1) / 2;
            clustering[i] = possible > 0 ? tri / possible : 0;
        }
        return clustering;
    }

    buildLaplacian() {
        const n = this.graph.vertices.length;
        const adj = this.adjacencyMatrix || this.buildAdjacencyMatrix();
        const L = zeroMatrix(n, n);

        for (let i = 0; i < n; i++) {
            let deg = 0;
            for (let j = 0; j < n; j++) {
                if (adj[i][j] > 0) {
                    L[i][j] = -adj[i][j];
                    deg += adj[i][j];
                }
            }
            L[i][i] = deg + this.eps; // Add self-loop for robustness
        }
        return L;
    }

    async computeProjectionMatrices() {
        const projections = new Map();
        const identityMatrix = identity(this.qDim); // The stable identity matrix (no worker needed for this)

        for (const [u, v] of this.graph.edges) {
            const P_uv = identityMatrix;
            const P_vu = identityMatrix; // Transpose of identity is itself.

            projections.set(`${u}-${v}`, P_uv);
            projections.set(`${v}-${u}`, P_vu);
        }
        return projections;
    }

    async _updateGraphStructureAndMetrics() {
        // logger.info('EnhancedQualiaSheaf._updateGraphStructureAndMetrics() started.'); // Removed verbose log
        try {
            this.adaptSheafTopology(); // Adapt topology before rebuilding matrices
            this.adjacencyMatrix = this.buildAdjacencyMatrix();
            this.laplacian = this.buildLaplacian();
            // logger.info('Calling worker for matrixSpectralNormApprox (initialization)...'); // Removed verbose log
            this.maxEigApprox = await runWorkerTask('matrixSpectralNormApprox', { matrix: flattenMatrix(this.laplacian) }, 10000) || 1; // 10s timeout
            // logger.info('matrixSpectralNormApprox completed.'); // Removed verbose log
            this.projectionMatrices = await this.computeProjectionMatrices();
            if (!Number.isFinite(this.maxEigApprox) || this.maxEigApprox <= 0) {
                logger.warn(`maxEigApprox was invalid (${this.maxEigApprox}). Resetting to 1.`);
                this.maxEigApprox = 1; // Fallback
            }
            // logger.info('EnhancedQualiaSheaf._updateGraphStructureAndMetrics() completed.'); // Removed verbose log
        } catch (e) {
            logger.error("Failed to update graph structure and metrics", e);
            throw e; // Propagate error for loading overlay to catch
        }
    }
    async diffuseQualia(state) {
        if (!this.ready) {
            logger.warn('Sheaf not ready for diffusion. Skipping.');
            return;
        }
        if (!isFiniteVector(state) || state.length !== this.stateDim) {
            logger.warn('diffuseQualia: Invalid input state received. Skipping diffusion.', state);
            return;
        }

        const playerCollision = state[8] > 0.5;
        const aiCollision = state[9] > 0.5;
        const tempEdges = [];
        if (playerCollision) tempEdges.push(['paddle_y', 'player_collision']);
        if (aiCollision) tempEdges.push(['ball_x', 'ai_collision']);

        const originalEdges = this.graph.edges.slice();
        // Only add temporary edges if they are not already present
        this.graph.edges = [...originalEdges, ...tempEdges.filter(e => !originalEdges.some(oe => oe[0] === e[0] && oe[1] === e[1]))];

        await this._updateGraphStructureAndMetrics(); 

        const qInput = new Float32Array(state.slice(0, this.graph.vertices.length).map(v => clamp(v, 0, 1)));
        if (!isFiniteVector(qInput) || qInput.length !== this.graph.vertices.length) {
            logger.warn('diffuseQualia: Invalid qInput generated. Skipping diffusion.', qInput);
            this.graph.edges = originalEdges; // Revert edges
            return;
        }

        const n = this.graph.vertices.length;
        const N = n * this.qDim;

        const s = new Float32Array(N);
        let currentOffset = 0;
        for (const vertexName of this.graph.vertices) {
            let stalkValue = this.stalks.get(vertexName);
            if (!stalkValue || !isFiniteVector(stalkValue) || stalkValue.length !== this.qDim) {
                logger.warn(`Found invalid or missing stalk for vertex ${vertexName}. Resetting to zeros.`);
                stalkValue = vecZeros(this.qDim);
                this.stalks.set(vertexName, stalkValue); // Update the map with a clean vector
            }
            s.set(stalkValue.map(v => Number.isFinite(v) ? v : 0), currentOffset); // Ensure elements are finite on copy
            currentOffset += this.qDim;
        }

        // After assembling 's', make sure it's fully finite before proceeding
        if (!isFiniteVector(s)) {
            logger.error('diffuseQualia: Initial concatenated stalk vector "s" contains non-finite values. Resetting to zeros for current diffusion step.', s);
            s.fill(0); // Reset 's' to zeros to avoid feeding NaNs to the solver
        }

        const Lnode = this.laplacian;
        // --- FIX: Correctly construct the Sheaf Laplacian (Lfull) ---
        const Lfull = zeroMatrix(N, N);
        const idx = new Map(this.graph.vertices.map((v, i) => [v, i]));

        // 1. Build the off-diagonal blocks
        for (const [u, v] of this.graph.edges) {
            const i = idx.get(u), j = idx.get(v);
            if (i === undefined || j === undefined) continue;

            const weight = this.adjacencyMatrix[i][j];
            if (!Number.isFinite(weight) || weight <= 0) continue;

            const P_uv = this.projectionMatrices.get(`${u}-${v}`);
            const P_vu = this.projectionMatrices.get(`${v}-${u}`);

            if (!isFiniteMatrix(P_uv) || !isFiniteMatrix(P_vu)) {
                logger.warn(`Non-finite projection matrix for edge ${u}-${v}. Skipping block.`);
                continue;
            }

            // Off-diagonal block (i, j) is -W_ij * P_uv
            for (let qi = 0; qi < this.qDim; qi++) {
                for (let qj = 0; qj < this.qDim; qj++) {
                    const val_uv = -weight * (P_uv[qi]?.[qj] || 0);
                    if (Number.isFinite(val_uv)) {
                        Lfull[i * this.qDim + qi][j * this.qDim + qj] = val_uv;
                    } else {
                        Lfull[i * this.qDim + qi][j * this.qDim + qj] = 0;
                    }
                }
            }
            // Off-diagonal block (j, i) is -W_ji * P_vu
            for (let qi = 0; qi < this.qDim; qi++) {
                for (let qj = 0; qj < this.qDim; qj++) {
                     const val_vu = -weight * (P_vu[qi]?.[qj] || 0); // weight is symmetric
                     if (Number.isFinite(val_vu)) {
                        Lfull[j * this.qDim + qi][i * this.qDim + qj] = val_vu;
                     } else {
                         Lfull[j * this.qDim + qi][i * this.qDim + qj] = 0;
                     }
                }
            }
        }

        // 2. Build the diagonal blocks
        for (let i = 0; i < n; i++) {
            let degree = 0;
            // Sum of weights of edges incident to vertex i
            for (let j = 0; j < n; j++) {
                if (i !== j) { // Don't include self-loop degree here, it's added explicitly
                    degree += (this.adjacencyMatrix[i]?.[j] || 0);
                }
            }
            // The diagonal block (i, i) is degree_i * Identity - Sum_{k!=i} W_ik * P_ik
            // Since P_ik = Identity, the second term is just Sum_{k!=i} W_ik * Identity
            // So, Diag(L_ii) = (degree_i + eps) * Identity
            for (let qi = 0; qi < this.qDim; qi++) {
                Lfull[i * this.qDim + qi][i * this.qDim + qi] = (Number.isFinite(degree) ? degree : 0) + this.eps;
            }
        }

        const f_s = new Float32Array(N).fill(0);
        for (let i = 0; i < n; i++) {
            const inputVal = qInput[i % qInput.length];
            for (let qi = 0; qi < this.qDim; qi++) {
                f_s[i * this.qDim + qi] = this.alpha * inputVal * 0.7; // Sensory input
            }
        }

        const eta = this.gamma / Math.max(1, this.maxEigApprox); // Time step / effective learning rate
        
        // Ensure A is constructed robustly
        const A = identity(N).map((row, i) => new Float32Array(row.map((v, j) => {
            const val = v + eta * (Lfull[i]?.[j] || 0);
            return Number.isFinite(val) ? val : 0; // Sanitize A elements
        })));
        
        const rhs = vecAdd(s, vecScale(f_s, eta)).map(v => Number.isFinite(v) ? clamp(v, -10, 10) : 0); // Explicitly sanitize rhs

        if (!isFiniteMatrix(A) || !isFiniteVector(rhs)) {
            logger.error('diffuseQualia: Matrix A or RHS vector contains non-finite values before CG solve. Skipping diffusion or using fallback.');
            const sNext = new Float32Array(N).fill(0); 
            this._updateStalksAndWindow(sNext, n);
            await this._updateDerivedMetrics();
            this.graph.edges = originalEdges;
            return;
        }

        let sSolved;
        try {
            sSolved = await runWorkerTask('solveLinearSystemCG', { A: flattenMatrix(A), b: rhs, opts: { tol: 1e-6, maxIter: 15 } }, 5000); // 5s timeout
        } catch (e) {
            logger.error('Error solving linear system in worker (CG). Falling back to zero vector:', e);
            sSolved = new Float32Array(N).fill(0); // Fallback to a clean zero vector on worker error
        }

        // --- Stronger Circuit Breaker ---
        if (!isFiniteVector(sSolved)) {
            logger.error('CRITICAL: Solver output or fallback contained non-finite values. Resetting sSolved to zero vector.', { sSolved });
            sSolved = new Float32Array(N).fill(0); 
        }
        
        const sNext = new Float32Array(sSolved.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));

        this._updateStalksAndWindow(sNext, n);
        await this._updateDerivedMetrics();

        this.graph.edges = originalEdges; // Revert temporary edges
    }

    _updateStalksAndWindow(sNextVector, n) {
        // Update stalk history for correlation analysis
        const currentStalkNorms = new Float32Array(n);
        for (let i = 0; i < n; i++) {
            // Ensure each stalk is fully finite before setting
            const rawStalkSlice = sNextVector.slice(i * this.qDim, (i + 1) * this.qDim);
            const sanitizedStalk = new Float32Array(rawStalkSlice.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
            this.stalks.set(this.graph.vertices[i], sanitizedStalk);
            currentStalkNorms[i] = norm2(sanitizedStalk); // Use sanitized stalk for norm
        }
        this.stalkHistory.push(currentStalkNorms);
        if (this.stalkHistory.length > this.stalkHistorySize) {
            this.stalkHistory.shift();
        }

        const sanitizedNextVector = new Float32Array(sNextVector.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));
        // Also ensure the windowedStates are always finite
        this.windowedStates.push(sanitizedNextVector);
        if (this.windowedStates.length > this.windowSize) this.windowedStates.shift();
    }

    async _updateDerivedMetrics() {
        // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics() started.'); // Removed verbose log
        try {
            // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics(): Calling computeH1Dimension().'); // Removed verbose log
            await this.computeH1Dimension();
            // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics(): computeH1Dimension() completed. Calling computeGluingInconsistency().'); // Removed verbose log
            await this.computeGluingInconsistency();
            // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics(): computeGluingInconsistency() completed. Calling computeGestaltUnity().'); // Removed verbose log
            this.computeGestaltUnity(); // Not async
            // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics(): computeGestaltUnity() completed. Calling computeIntegratedInformation().'); // Removed verbose log
            await this.computeIntegratedInformation();
            // logger.info('EnhancedQualiaSheaf._updateDerivedMetrics() completed.'); // Removed verbose log
        } catch (e) {
            logger.error("Error during derived metrics update:", e);
            // Fallback values in case of error
            this.phi = 0.01;
            this.h1Dimension = 0.5;
            this.gestaltUnity = 0.05;
            this.stability = 0.01;
            this.inconsistency = 1.0;
        }
    }

    async computeH1Dimension() {
        // logger.info('EnhancedQualiaSheaf.computeH1Dimension() started.'); // Removed verbose log
        const { boundary1, boundary2 } = this.buildBoundaryMatrices();
        if (!isFiniteMatrix(boundary1) || !isFiniteMatrix(boundary2)) {
            logger.warn("Non-finite boundary matrices detected. Setting H1 to default max/min.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        const flatBoundary1 = flattenMatrix(boundary1);
        const flatBoundary2 = flattenMatrix(boundary2);

        if (!flatBoundary1?.flatData || !isFiniteVector(flatBoundary1.flatData)) {
            logger.error("Flat boundary1 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        if (!flatBoundary2?.flatData || !isFiniteVector(flatBoundary2.flatData)) {
            logger.error("Flat boundary2 is invalid before sending to worker for rank calculation.");
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }

        let rankB1, rankB2;
        try {
            // logger.info('Calling worker for matrixRank (B1)...'); // Removed verbose log
            rankB1 = await runWorkerTask('matrixRank', { matrix: flatBoundary1 }, 10000); // 10s timeout
            // logger.info('matrixRank for B1 completed.'); // Removed verbose log
        } catch (e) {
            logger.error('Error computing rankB1 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        try {
            // logger.info('Calling worker for matrixRank (B2)...'); // Removed verbose log
            rankB2 = await runWorkerTask('matrixRank', { matrix: flatBoundary2 }, 10000); // 10s timeout
            // logger.info('matrixRank for B2 completed.'); // Removed verbose log
        } catch (e) {
            logger.error('Error computing rankB2 in worker:', e);
            this.h1Dimension = 1;
            this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
            return;
        }
        
        const safeRankB1 = Number.isFinite(rankB1) && rankB1 >= 0 ? rankB1 : 0;
        const safeRankB2 = Number.isFinite(rankB2) && rankB2 >= 0 ? rankB2 : 0;

        const rawH1 = this.graph.edges.length - safeRankB1 - safeRankB2;
        this.h1Dimension = clamp(rawH1, 0, 3); // Clamp H1 to a sensible range
        if (!Number.isFinite(this.h1Dimension)) this.h1Dimension = 1;

        this.stability = clamp(Math.exp(-this.h1Dimension * 0.2), 0.01, 1);
        if (!Number.isFinite(this.stability)) this.stability = 0.5;
        // logger.info('EnhancedQualiaSheaf.computeH1Dimension() completed.'); // Removed verbose log
    }

    async computeGluingInconsistency() {
        // logger.info('EnhancedQualiaSheaf.computeGluingInconsistency() started.'); // Removed verbose log
        let sum = 0;
        for (const [u, v] of this.graph.edges) {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            const P_uv = this.projectionMatrices.get(`${u}-${v}`);

            if (!P_uv || !isFiniteVector(stalk_u) || !isFiniteVector(stalk_v) || !isFiniteMatrix(P_uv)) {
                logger.warn(`Skipping inconsistency calculation for edge ${u}-${v} due to non-finite inputs.`);
                continue;
            }

            let projected_u;
            try {
                projected_u = await runWorkerTask('matVecMul', { matrix: flattenMatrix(P_uv), vector: stalk_u }, 5000); // 5s timeout
            } catch (e) {
                logger.error(`Error projecting stalk_u for edge ${u}-${v} in worker:`, e);
                projected_u = vecZeros(this.qDim);
            }
            
            const safeProjected_u = isFiniteVector(projected_u) ? projected_u : vecZeros(this.qDim);
            
            sum += norm2(vecSub(safeProjected_u, stalk_v));
        }
        this.inconsistency = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0, 1) : 0;
        if (!Number.isFinite(this.inconsistency)) this.inconsistency = 1.0;
        // logger.info('EnhancedQualiaSheaf.computeGluingInconsistency() completed.'); // Removed verbose log
    }

    computeGestaltUnity() {
        // logger.info('EnhancedQualiaSheaf.computeGestaltUnity() started.'); // Removed verbose log
        let sum = 0;
        this.graph.edges.forEach(([u, v]) => {
            const stalk_u = this.stalks.get(u);
            const stalk_v = this.stalks.get(v);
            if (isFiniteVector(stalk_u) && isFiniteVector(stalk_v)) {
                const diffNorm = norm2(vecSub(stalk_u, stalk_v));
                if (Number.isFinite(diffNorm)) {
                    sum += Math.exp(-diffNorm * this.beta);
                }
            }
        });
        this.gestaltUnity = this.graph.edges.length > 0 ? clamp(sum / this.graph.edges.length, 0.05, 0.99) : 0.05;
        if (!Number.isFinite(this.gestaltUnity)) this.gestaltUnity = 0.05;
        // logger.info('EnhancedQualiaSheaf.computeGestaltUnity() completed.'); // Removed verbose log
    }

    async computeIntegratedInformation() {
        // logger.info('EnhancedQualiaSheaf.computeIntegratedInformation() started.'); // Removed verbose log
        const validStates = this.windowedStates.filter(isFiniteVector);
        if (validStates.length < Math.max(4, this.stateDim + this.qDim)) { // Need enough samples for meaningful covariance
            logger.warn('Not enough valid states for meaningful covariance calculation. Using base Phi.');
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }
        let cov;
        try {
            // logger.info('Calling worker for covarianceMatrix...'); // Removed verbose log
            cov = await runWorkerTask('covarianceMatrix', { states: validStates, eps: this.eps }, 10000); // 10s timeout
            // logger.info('covarianceMatrix completed.'); // Removed verbose log
        } catch (e) {
            logger.error('Error computing covarianceMatrix in worker:', e);
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }

        if (!isFiniteMatrix(cov)) {
            logger.warn("Non-finite covariance matrix. Setting MI to default.");
            this.phi = clamp(0.5 + (this.gestaltUnity || 0.1) * (this.stability || 0.1), 0.01, 5);
            return;
        }

        const MI_val = logDeterminantFromDiagonal(cov);
        const MI = Number.isFinite(MI_val) ? Math.abs(MI_val) * 0.1 + 1e-6 : 1e-6; // Ensure MI is positive and non-zero
        
        const safeStability = Number.isFinite(this.stability) ? this.stability : 0.1;
        const safeGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.1;
        const safeInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 1.0;

        this.phi = clamp(Math.log(1 + MI) * safeStability * safeGestaltUnity * Math.exp(-safeInconsistency), 0.01, 5);
        if (!Number.isFinite(this.phi)) this.phi = 0.01;
        // logger.info('EnhancedQualiaSheaf.computeIntegratedInformation() completed.'); // Removed verbose log
    }

    visualizeActivity() {
        this.graph.vertices.forEach((vertexName, idx) => {
            const el = document.getElementById(`vertex-${idx}`);
            if (!el) return;
            const stalk = this.stalks.get(vertexName) || vecZeros(this.qDim);
            const norm = norm2(stalk);
            const intensity = Number.isFinite(norm) ? clamp(norm / Math.sqrt(this.qDim), 0, 1) : 0;
            el.classList.toggle('active', intensity > 0.5);
            const hue = 0; // Fixed hue for general visualization unless active
            const saturation = 100;
            const lightness = 50 + intensity * 40; // Makes it brighter with higher intensity
            
            // Set default/inactive color
            el.style.background = `radial-gradient(circle, hsl(${hue}, ${saturation}%, ${lightness}%), hsl(${hue}, ${saturation * 0.8}%, ${lightness * 0.6}%))`;

            // If active, use the greenish pulse color
            if (intensity > 0.5) {
                 el.style.background = `radial-gradient(circle, #00ff99, #00cc66)`;
            }
        });
    }

    tuneParameters() {
        const currentStability = Number.isFinite(this.stability) ? this.stability : 0.5;
        const currentInconsistency = Number.isFinite(this.inconsistency) ? this.inconsistency : 0.5;
        const currentGestaltUnity = Number.isFinite(this.gestaltUnity) ? this.gestaltUnity : 0.5;
        const currentH1Dimension = Number.isFinite(this.h1Dimension) ? this.h1Dimension : 1;

        // Tune alpha: More responsive if unstable or inconsistent
        this.alpha = clamp(this.alpha * (1 + 0.02 * (1 - currentStability)) * (1 + 0.01 * currentInconsistency), 0.01, 1);
        // Tune beta: Increase unity with higher unity, decrease if H1 is high (too complex)
        this.beta = clamp(this.beta * (1 + 0.02 * currentGestaltUnity) * (1 - 0.01 * currentH1Dimension), 0.01, 1);
        // Tune gamma: Lower if H1 is high (stability), lower if inconsistent
        this.gamma = clamp(this.gamma * (1 - 0.05 * currentH1Dimension) * (1 - 0.02 * currentInconsistency), 0.01, 0.5);
        logger.info(`Tuned parameters: Alpha=${this.alpha.toFixed(3)}, Beta=${this.beta.toFixed(3)}, Gamma=${this.gamma.toFixed(3)}`);
    }
}
class OntologicalWorldModel {
    constructor(stateDim = 10, actionDim = 3, qDim = 7, hiddenSizes = [64, 64], isPlayerTwo = false) {
        // logger.info(`OWM Constructor (${isPlayerTwo ? 'AI' : 'Player'}) started.`); // Removed verbose log
        this.stateDim = stateDim;
        this.actionDim = actionDim;
        this.isPlayerTwo = isPlayerTwo;
        const recurrentStateSize = hiddenSizes[hiddenSizes.length - 1]; // Size of our LSTM-like state

        // Graph and Sheaf setup remains the same
        const commonVertices = ['paddle_y', 'ball_x', 'ball_y', 'ball_dx', 'ball_dy', 'player_score', 'ai_score', 'paddle_speed', 'player_collision', 'ai_collision'];
        const initialEdges = [['paddle_y', 'ball_y'], ['ball_x', 'ball_dx'], ['ball_y', 'ball_dy'], ['player_collision', 'paddle_y'], ['ai_collision', 'ball_x']];
        this.graph = { vertices: commonVertices, edges: initialEdges };
        
        this.qualiaSheaf = new EnhancedQualiaSheaf(this.graph, this.stateDim, qDim, 0.1, 0.1, 0.05);
        this.qDim = this.qualiaSheaf.qDim; // Use the canonical qDim from the sheaf

        // Define the expected length of the qualia part of the input
        this.expectedQualiaInputLength = this.graph.vertices.length * this.qDim; // 10 vertices * 7 qDim = 70

        // Define the total input dimension expected by the NN for current state + qualia
        this.inputDim = this.stateDim + this.expectedQualiaInputLength; // 10 state + 70 qualia = 80

        this.hiddenState = vecZeros(recurrentStateSize);
        this.cellState = vecZeros(recurrentStateSize);

        const combinedInputSize = this.inputDim + recurrentStateSize;
        const weightScale = Math.sqrt(2.0 / combinedInputSize); // Glorot/Xavier initialization approximation

        this.Wf = randomMatrix(recurrentStateSize, combinedInputSize, weightScale); // Forget gate
        this.Wi = randomMatrix(recurrentStateSize, combinedInputSize, weightScale); // Input gate
        this.Wc = randomMatrix(recurrentStateSize, combinedInputSize, weightScale); // Cell state candidate
        this.Wo = randomMatrix(recurrentStateSize, combinedInputSize, weightScale); // Output gate
        this.bf = vecZeros(recurrentStateSize);
        this.bi = vecZeros(recurrentStateSize);
        this.bc = vecZeros(recurrentStateSize);
        this.bo = vecZeros(recurrentStateSize);
        
        // Output heads are now fed from the recurrent hidden state
        const qValueScale = Math.sqrt(2.0 / (recurrentStateSize + this.actionDim));
        this.qValueHead = { W: randomMatrix(this.actionDim, recurrentStateSize, qValueScale), b: vecZeros(this.actionDim) };
        
        const statePredScale = Math.sqrt(2.0 / (recurrentStateSize + this.stateDim));
        this.statePredHead = { W: randomMatrix(this.stateDim, recurrentStateSize, statePredScale), b: vecZeros(this.stateDim) };

        this.attentionWeights = randomMatrix(this.qDim, this.inputDim, 0.1); // Attention weights dim: qDim x inputDim
        this.lastSoftmaxScores = vecZeros(this.qDim); // Size qDim
        
        this.freeEnergy = 0;
        this.predictionError = 0;
        this.ready = false;
        this.lastActivations = [];

        logger.info(`OWM constructed (${isPlayerTwo ? 'AI' : 'Player'}): inputDim=${this.inputDim}, qualiaSheaf.qDim=${this.qualiaSheaf.qDim}, expectedQualiaInputLength=${this.expectedQualiaInputLength}`);
    }

    async initialize() {
        logger.info(`OWM.initialize() (${this.isPlayerTwo ? 'AI' : 'Player'}) called.`);
        try {
            // logger.info(`OWM.initialize() (${this.isPlayerTwo ? 'AI' : 'Player'}): Calling qualiaSheaf.initialize().`); // Removed verbose log
            await this.qualiaSheaf.initialize();
            this.ready = true;
            logger.info(`Recurrent OWM for ${this.isPlayerTwo ? 'AI' : 'Player'} ready.`);
        } catch (e) {
            logger.error(`Error during Recurrent OWM initialization (${this.isPlayerTwo ? 'AI' : 'Player'}):`, e);
            this.ready = false;
            throw e; // Re-throw to propagate to MainApp
        }
    }

    async forward(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.forward: Invalid input. Returning zeros.', {expected: this.inputDim, got: input.length});
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        
        const activations = [input.slice()];
        
        // --- NEW: LSTM-like Recurrent Block ---
        const combinedInput = new Float32Array([...input, ...this.hiddenState]);
        if (!isFiniteVector(combinedInput)) {
            logger.error('OWM.forward: Combined input for LSTM is non-finite. Resetting hidden/cell states and returning zeros.');
            this.resetRecurrentState(); // Attempt to recover
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }

        const Wf_flat = flattenMatrix(this.Wf);
        const Wi_flat = flattenMatrix(this.Wi);
        const Wc_flat = flattenMatrix(this.Wc);
        const Wo_flat = flattenMatrix(this.Wo);
        
        let ft, it, c_tilde, ot;

        try {
            ft = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wf_flat, vector: combinedInput}, 2000), this.bf)); // Increased timeout
            it = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wi_flat, vector: combinedInput}, 2000), this.bi)); // Increased timeout
            c_tilde = tanhVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wc_flat, vector: combinedInput}, 2000), this.bc)); // Increased timeout
            
            this.cellState = vecAdd(vecMul(ft, this.cellState), vecMul(it, c_tilde));
            if (!isFiniteVector(this.cellState)) {
                logger.error('OWM.forward: Cell state became non-finite. Resetting.');
                this.cellState.fill(0);
            }
            activations.push(this.cellState.slice());

            ot = sigmoidVec(vecAdd(await runWorkerTask('matVecMul', {matrix: Wo_flat, vector: combinedInput}, 2000), this.bo)); // Increased timeout
            this.hiddenState = vecMul(ot, tanhVec(this.cellState));
            if (!isFiniteVector(this.hiddenState)) {
                logger.error('OWM.forward: Hidden state became non-finite. Resetting.');
                this.hiddenState.fill(0);
            }
            activations.push(this.hiddenState.slice());
        } catch (e) {
            logger.error('OWM.forward: Error during recurrent step:', e);
            this.resetRecurrentState(); // Attempt to recover
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        // --- END Recurrent Block ---

        // Output heads now take the new hiddenState as input
        let qValues, nextState;
        try {
            qValues = vecAdd(await runWorkerTask('matVecMul', { matrix: flattenMatrix(this.qValueHead.W), vector: this.hiddenState }, 2000), this.qValueHead.b); // Increased timeout
            nextState = vecAdd(await runWorkerTask('matVecMul', { matrix: flattenMatrix(this.statePredHead.W), vector: this.hiddenState }, 2000), this.statePredHead.b); // Increased timeout
        } catch (e) {
            logger.error('OWM.forward: Error during output head calculation:', e);
            return { qValues: vecZeros(this.actionDim), nextState: vecZeros(this.stateDim), activations: [] };
        }
        
        if (!isFiniteVector(qValues)) { logger.warn('OWM.forward: Q-values are non-finite. Returning zeros.'); qValues = vecZeros(this.actionDim); }
        if (!isFiniteVector(nextState)) { logger.warn('OWM.forward: Next state prediction is non-finite. Returning zeros.'); nextState = vecZeros(this.stateDim); }

        activations.push(qValues.slice()); // Push Q-values as final activation layer for visualization
        
        return { qValues, nextState, activations };
    }

    applyAttention(input) {
        if (!isFiniteVector(input) || input.length !== this.inputDim) {
            logger.error('OWM.applyAttention: Invalid input. Returning original input.', {expected: this.inputDim, got: input.length});
            this.lastSoftmaxScores.fill(0); // Reset scores
            return input;
        }

        const scores = this.attentionWeights.map(w => dot(w, input));
        if (!isFiniteVector(scores)) {
            logger.warn('OWM.applyAttention: Scores became non-finite. Returning original input.');
            this.lastSoftmaxScores.fill(0);
            return input;
        }

        const maxScore = scores.length > 0 ? Math.max(...scores) : 0;
        const expScores = scores.map(s => Math.exp(s - maxScore)); // Subtract max for numerical stability
        const sumExpScores = expScores.reduce((s, x) => s + x, 1e-10); // Add epsilon to prevent division by zero
        const softmaxScores = new Float32Array(expScores.map(s => s / sumExpScores));
        
        if (!isFiniteVector(softmaxScores)) {
            logger.warn('OWM.applyAttention: Softmax scores became non-finite. Returning original input.');
            this.lastSoftmaxScores.fill(0);
            return input;
        }

        this.lastSoftmaxScores = softmaxScores;

        const att = vecZeros(input.length);
        for (let i = 0; i < softmaxScores.length; i++) {
            if (!Number.isFinite(softmaxScores[i])) continue; // Skip non-finite scores
            for (let j = 0; j < input.length; j++) {
                att[j] += softmaxScores[i] * (input[j] || 0);
            }
        }
        const weightedAttended = vecAdd(input, vecScale(att, this.qualiaSheaf.beta));
        return isFiniteVector(weightedAttended) ? weightedAttended : input; // Fallback to original if non-finite
    }

    async predict(state) {
        if (!this.ready) {
            logger.warn('OWM not ready for prediction.');
            return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }
        if (!isFiniteVector(state) || state.length !== this.stateDim) {
            logger.error(`OWM.predict: Invalid state vector received. Expected length ${this.stateDim}, got ${state.length}.`, { state });
            return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }

        let corruptedFlag = false;

        // Diffuse qualia - this can modify the sheaf's internal state (stalks, metrics)
        try {
            await this.qualiaSheaf.diffuseQualia(state);
        } catch (e) {
            logger.error('OWM.predict: Error during qualia diffusion:', e);
            corruptedFlag = true;
        }
        
        const qualiaStalksMap = this.qualiaSheaf.stalks;
        let finalQualiaArray = new Float32Array(this.expectedQualiaInputLength); // Initialize with zeros

        if (qualiaStalksMap instanceof Map && qualiaStalksMap.size > 0) {
            let offset = 0;
            for (const vertexName of this.qualiaSheaf.graph.vertices) {
                let stalk = qualiaStalksMap.get(vertexName);
                if (!stalk || !isFiniteVector(stalk) || stalk.length !== this.qDim) {
                    logger.warn(`OWM.predict: Corrupted or missing stalk for vertex "${vertexName}" in qualiaStalksMap. Replacing with zeros.`);
                    stalk = vecZeros(this.qDim); 
                    corruptedFlag = true;
                }
                
                for (let i = 0; i < this.qDim; i++) {
                    finalQualiaArray[offset + i] = Number.isFinite(stalk[i]) ? clamp(stalk[i], -1, 1) : 0;
                }
                offset += this.qDim;
            }
        } else {
            logger.warn('qualiaStalksMap is empty or not a Map, using all-zero qualia vector for input. Flagging as corrupted.');
            corruptedFlag = true;
        }

        if (!isFiniteVector(finalQualiaArray) || finalQualiaArray.length !== this.expectedQualiaInputLength) {
             logger.error(`FATAL: finalQualiaArray became non-finite or wrong length after construction. Resetting to all zeros and flagging corrupted.`);
             finalQualiaArray = vecZeros(this.expectedQualiaInputLength);
             corruptedFlag = true;
        }

        const input = new Float32Array([...state, ...finalQualiaArray]);
        
        if (input.length !== this.inputDim || !isFiniteVector(input)) {
             logger.error(`FATAL: Input size mismatch or non-finite values just before attention. Expected ${this.inputDim}, got ${input.length}. Flagging corrupted.`);
             return { qValues: vecZeros(this.actionDim), activations: [], corrupted: true };
        }

        const attended = this.applyAttention(input);
        
        let qValues, nextState, activations;
        try {
            const forwardResult = await this.forward(attended);
            qValues = forwardResult.qValues;
            nextState = forwardResult.nextState;
            activations = forwardResult.activations;
        } catch (e) {
            logger.error('OWM.predict: Error during forward pass:', e);
            corruptedFlag = true;
            qValues = vecZeros(this.actionDim);
            nextState = vecZeros(this.stateDim);
            activations = [];
        }

        const error = norm2(vecSub(nextState, state));
        this.predictionError = clamp(error, 0, 10);
        if (!Number.isFinite(this.predictionError)) { logger.warn('OWM.predict: Prediction error is non-finite. Resetting to 0.'); this.predictionError = 0; corruptedFlag = true; }

        this.freeEnergy = 0.85 * (this.freeEnergy || 0) + 0.15 * (this.predictionError * 0.5 + (this.qualiaSheaf.h1Dimension || 0));
        this.freeEnergy = clamp(this.freeEnergy, 0, 10);
        if (!Number.isFinite(this.freeEnergy)) { logger.warn('OWM.predict: Free energy is non-finite. Resetting to 0.'); this.freeEnergy = 0; corruptedFlag = true; }

        this.lastActivations = activations;

        return { qValues, activations, corrupted: corruptedFlag };
    }

    async learn(state, actionIndex, reward, nextState, isDone, learningRate = 0.01, gamma = 0.99) {
        if (!isFiniteVector(state) || !isFiniteVector(nextState) || !Number.isFinite(reward) || !Number.isFinite(actionIndex)) {
            logger.warn('OWM.learn: Invalid input (state, nextState, reward, or actionIndex). Skipping learning step.');
            return;
        }
        if (actionIndex < 0 || actionIndex >= this.actionDim) {
            logger.warn(`OWM.learn: Invalid actionIndex ${actionIndex}. Skipping learning step.`);
            return;
        }

        // Use a version of predict that doesn't flag corruption for learning purposes
        // to avoid feedback loops if the state is temporarily noisy.
        const { qValues: currentQValues } = await this.predict(state); // Corruption info is ignored here
        const { qValues: nextQValues } = await this.predict(nextState);
        
        const maxNextQ = isDone ? 0 : Math.max(...nextQValues);

        const targetQ = (Number.isFinite(reward) ? reward : 0) + (Number.isFinite(gamma) ? gamma : 0) * (Number.isFinite(maxNextQ) ? maxNextQ : 0);
        const currentQForAction = (currentQValues && Number.isFinite(currentQValues[actionIndex])) ? currentQValues[actionIndex] : 0;
        const tdError = targetQ - currentQForAction;

        const lastRecurrentState = this.lastActivations[2]; // hiddenState (index 2 in activations array)
        if (lastRecurrentState && isFiniteVector(lastRecurrentState)) {
            for (let j = 0; j < lastRecurrentState.length; j++) {
                const deltaW = (Number.isFinite(learningRate) ? learningRate : 0) * (Number.isFinite(tdError) ? tdError : 0) * (Number.isFinite(lastRecurrentState[j]) ? lastRecurrentState[j] : 0);
                if (Number.isFinite(deltaW)) {
                    this.qValueHead.W[actionIndex][j] = (Number.isFinite(this.qValueHead.W[actionIndex][j]) ? this.qValueHead.W[actionIndex][j] : 0) + deltaW;
                } else {
                    // logger.warn('OWM.learn: Non-finite deltaW calculated. Skipping update for this weight.'); // Removed verbose log
                }
            }
            const deltaB = (Number.isFinite(learningRate) ? learningRate : 0) * (Number.isFinite(tdError) ? tdError : 0);
            if (Number.isFinite(deltaB)) {
                this.qValueHead.b[actionIndex] = (Number.isFinite(this.qValueHead.b[actionIndex]) ? this.qValueHead.b[actionIndex] : 0) + deltaB;
            } else {
                // logger.warn('OWM.learn: Non-finite deltaB calculated. Skipping update for this bias.'); // Removed verbose log
            }
        } else {
            logger.warn('OWM.learn: lastRecurrentState is invalid or missing. Skipping learning update.');
        }
    }

    resetRecurrentState() {
        this.hiddenState.fill(0);
        this.cellState.fill(0);
        logger.info(`OWM recurrent state for ${this.isPlayerTwo ? 'AI' : 'Player'} has been reset.`);
    }
}
        class LearningAI {
    // Constants for normalization and game physics
    static BALL_DX_NORMALIZATION = 10;
    static BALL_DY_NORMALIZATION = 12;
    static PADDLE_DY_NORMALIZATION = 7;
    static PADDLE_HEIGHT_BASE = 80;
    static PADDLE_WIDTH_BASE = 15;
    static PADDLE_OFFSET_X = 10; // Player paddle X, AI paddle X offset from width

    constructor(worldModel, gameBounds, isPlayerTwo = false, aiResponseTime = 3) {
        this.worldModel = worldModel;
        this.gameWidth = gameBounds.width;
        this.gameHeight = gameBounds.height;
        this.isPlayerTwo = isPlayerTwo;
        this.aiResponseTime = Math.max(1, aiResponseTime); // Ensure minimum 1 frame response
        this.actionQueue = [];

        // State for Reinforcement Learning
        this.epsilon = 1.0; // Initial exploration rate
        this.epsilonMin = 0.05;
        this.epsilonDecay = 0.9995;
        this.learningRate = 0.01;
        
        this.lastStateVec = vecZeros(this.worldModel.stateDim);
        this.lastActionIndex = 2; // Corresponds to 'IDLE'
        this.lastActivations = [];
        this.avgQValue = 0; // For tracking/visualization
    }

    createStateVector(gameState) {
        const paddle = this.isPlayerTwo ? gameState.ai : gameState.player;
        const opponentPaddle = this.isPlayerTwo ? gameState.player : gameState.ai;

        const safeGameWidth = Math.max(1, this.gameWidth);
        const safeGameHeight = Math.max(1, this.gameHeight);

        const stateVec = new Float32Array([
            (gameState.ball.x || 0) / safeGameWidth,
            (gameState.ball.y || 0) / safeGameHeight,
            (gameState.ball.dx || 0) / LearningAI.BALL_DX_NORMALIZATION,
            (gameState.ball.dy || 0) / LearningAI.BALL_DY_NORMALIZATION,
            (paddle.y || 0) / safeGameHeight,
            (opponentPaddle.y || 0) / safeGameHeight,
            (paddle.dy || 0) / LearningAI.PADDLE_DY_NORMALIZATION,
            (opponentPaddle.dy || 0) / LearningAI.PADDLE_DY_NORMALIZATION,
            (gameState.playerCollision ? 1 : 0),
            (gameState.aiCollision ? 1 : 0)
        ]);

        // Ensure all values are finite and clamped
        const clampedStateVec = new Float32Array(stateVec.map(v => Number.isFinite(v) ? clamp(v, -1, 1) : 0));

        if (!isFiniteVector(clampedStateVec) || clampedStateVec.length !== this.worldModel.stateDim) {
            logger.error(`LearningAI.createStateVector: Generated state vector is invalid. Returning zeros.`, {clampedStateVec});
            return vecZeros(this.worldModel.stateDim);
        }
        return clampedStateVec;
    }
    async makeDecision(gameState) {
        if (this.actionQueue.length >= this.aiResponseTime) {
            return this.actionQueue.shift();
        }

        const actions = [{ name: 'UP', vec: [1, 0, 0] }, { name: 'DOWN', vec: [0, 1, 0] }, { name: 'IDLE', vec: [0, 0, 1] }];
        let actionIndex = 2; // Default to IDLE

        const stateVec = this.createStateVector(gameState);
        this.lastStateVec = stateVec;

        const { qValues, activations, corrupted } = await this.worldModel.predict(stateVec);
        this.lastActivations = activations;

        if (corrupted) {
            logger.warn(`LearningAI (${this.isPlayerTwo ? 'AI' : 'Player'}): World model predicted a corrupted state. Defaulting to IDLE and signaling corruption.`);
            this.lastActionIndex = 2; // IDLE
            const decision = { action: actions[2].vec, activations: this.lastActivations, corrupted: true };
            this.actionQueue.push(decision);
            return this.actionQueue.shift() || decision;
        }

        if (Math.random() < this.epsilon) {
            actionIndex = Math.floor(Math.random() * actions.length);
        } else {
            if (qValues && isFiniteVector(qValues)) {
                actionIndex = qValues.indexOf(Math.max(...qValues));
                this.avgQValue = qValues.reduce((a, b) => a + b, 0) / qValues.length;
            } else {
                logger.warn(`LearningAI (${this.isPlayerTwo ? 'AI' : 'Player'}): Received invalid Q-values, defaulting to IDLE.`);
                actionIndex = 2;
                this.avgQValue = 0;
            }
        }
        
        this.lastActionIndex = actionIndex;
        const decision = { action: actions[actionIndex].vec, activations: this.lastActivations, corrupted: false };
        this.actionQueue.push(decision);

        return this.actionQueue.shift() || decision;
    }

    async learn(reward, newGameState, isDone) {
        const nextStateVec = this.createStateVector(newGameState);
        await this.worldModel.learn(this.lastStateVec, this.lastActionIndex, reward, nextStateVec, isDone, this.learningRate);
        
        if (this.epsilon > this.epsilonMin) {
            this.epsilon *= this.epsilonDecay;
        }

        const uncertaintyFactor = 1 + clamp(this.worldModel.predictionError, 0, 5); // Incorporate prediction error
        this.epsilon = clamp(this.epsilon * uncertaintyFactor, this.epsilonMin, 1.0);
    }

    reset() {
        this.worldModel.resetRecurrentState();
        this.epsilon = 1.0;
        this.avgQValue = 0;
        this.actionQueue = []; // Clear any pending actions
        logger.info(`LearningAI for ${this.isPlayerTwo ? 'AI' : 'Player'} has been reset.`);
    }
}
// NEW: StrategicAI for Meta-Learning
class StrategicAI {
    constructor(learningAI) {
        this.learningAI = learningAI;
        this.rewardHistory = [];
        this.HISTORY_SIZE = 200; // Analyze the last 200 steps
        this.epsilonModulationRate = 0.005; // Rate for epsilon adjustment
        this.learningRateModulationRate = 0.005; // Rate for learning rate adjustment
    }

    observe(reward) {
        if (Number.isFinite(reward)) {
            this.rewardHistory.push(reward);
            if (this.rewardHistory.length > this.HISTORY_SIZE) {
                this.rewardHistory.shift();
            }
        }
    }

    modulateParameters() {
        if (this.rewardHistory.length < this.HISTORY_SIZE) return;

        const avgReward = this.rewardHistory.reduce((a, b) => a + b, 0) / this.HISTORY_SIZE;
        const predError = Number.isFinite(this.learningAI.worldModel.predictionError) ? this.learningAI.worldModel.predictionError : 0;
        const gestaltUnity = Number.isFinite(this.learningAI.worldModel.qualiaSheaf.gestaltUnity) ? this.learningAI.worldModel.qualiaSheaf.gestaltUnity : 0.5;
        const h1Dimension = Number.isFinite(this.learningAI.worldModel.qualiaSheaf.h1Dimension) ? this.learningAI.worldModel.qualiaSheaf.h1Dimension : 1.0;

        // Dynamic adjustment based on performance and internal metrics
        // If performance is poor (low avg reward), increase learning rate and exploration slightly
        if (avgReward < -0.2 && predError > 1.0) { // If losing and confused
            this.learningAI.learningRate = clamp(this.learningAI.learningRate * (1 + this.learningRateModulationRate * 2), 0.001, 0.05); // More aggressive learning
            this.learningAI.epsilon = clamp(this.learningAI.epsilon * (1 + this.epsilonModulationRate * 1.5), this.learningAI.epsilonMin, 1.0); // More aggressive exploration
        } else if (avgReward > 0.1 && predError < 0.5) { // If doing well and confident
            this.learningAI.learningRate = clamp(this.learningAI.learningRate * (1 - this.learningRateModulationRate * 0.5), 0.001, 0.05);
            this.learningAI.epsilon = clamp(this.learningAI.epsilon * (1 - this.epsilonModulationRate * 0.5), this.learningAI.epsilonMin, 1.0);
        }

        // Adjust exploration based on Gestalt Unity (higher unity -> more confidence -> less exploration)
        // and H1 Dimension (higher complexity/holes -> more uncertainty -> more exploration)
        const explorationModifier = (1 - gestaltUnity) + (h1Dimension * 0.1); // Simple heuristic
        this.learningAI.epsilon = clamp(this.learningAI.epsilon * (1 + (explorationModifier - 0.5) * 0.01), this.learningAI.epsilonMin, 1.0);


        logger.info(`StrategicAI modulated LearningAI. Epsilon: ${this.learningAI.epsilon.toFixed(3)}, LR: ${this.learningAI.learningRate.toFixed(4)}`);
    }
}
        class PongGame {
            // Game constants for clarity and easy tuning
            static PADDLE_HEIGHT_BASE = 80;
            static PADDLE_WIDTH_BASE = 15;
            static BALL_RADIUS = 8;
            static INITIAL_BALL_SPEED_X = 4;
            static INITIAL_BALL_SPEED_Y_MAX = 6;
            static PLAYER_PADDLE_SPEED = 7; // Fixed player speed

            constructor(canvas, initialWidth, initialHeight) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = initialWidth;
                this.height = initialHeight;
                this.scoreToWin = 10;
                this.ballSpeedMultiplier = 1.0;
                this.paddleHeightMultiplier = 1.0;
                this.MAX_BALL_SPEED_BASE = 8;
                this.MAX_PADDLE_SPEED_BASE = 7;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); // Moved here
                this.reset();
            }

            // NEW: Method to explicitly resume AudioContext
            async resumeAudioContext() {
                if (this.audioContext.state === 'suspended') {
                    return this.audioContext.resume().then(() => {
                        logger.info("AudioContext resumed by PongGame.");
                    }).catch(e => {
                        logger.error("Failed to resume AudioContext in PongGame:", e);
                        throw e; // Re-throw to propagate if critical
                    });
                }
                return Promise.resolve(); // Already running or not suspended
            }


            reset() {
                // Ensure dimensions are valid, fallback to canvas client dimensions if needed
                this.width = this.canvas.clientWidth || this.width;
                this.height = this.canvas.clientHeight || this.height;
                if (this.width === 0 || this.height === 0) {
                    logger.warn("PongGame dimensions are zero during reset. Falling back to default dimensions.");
                    this.width = 600; this.height = 300;
                }
                
                const paddleH = PongGame.PADDLE_HEIGHT_BASE * this.paddleHeightMultiplier;
                const paddleW = PongGame.PADDLE_WIDTH_BASE;

                this.ball = { 
                    x: this.width / 2, 
                    y: this.height / 2, 
                    dx: (Math.random() > 0.5 ? 1 : -1) * PongGame.INITIAL_BALL_SPEED_X * this.ballSpeedMultiplier, 
                    dy: (Math.random() - 0.5) * PongGame.INITIAL_BALL_SPEED_Y_MAX * this.ballSpeedMultiplier, 
                    radius: PongGame.BALL_RADIUS 
                };
                this.ai = { x: this.width - 25, y: (this.height / 2) - (paddleH / 2), width: paddleW, height: paddleH, dy: 0 };
                this.player = { x: 10, y: (this.height / 2) - (paddleH / 2), width: paddleW, height: paddleH, dy: 0 };
                this.score = { ai: 0, player: 0 };
                this.playerCollision = false;
                this.aiCollision = false;
                this.gameOver = false;
                this.winner = null;
            }

            resetBall() {
                this.ball.x = this.width / 2;
                this.ball.y = this.height / 2;
                this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * PongGame.INITIAL_BALL_SPEED_X * this.ballSpeedMultiplier;
                this.ball.dy = (Math.random() - 0.5) * PongGame.INITIAL_BALL_SPEED_Y_MAX * this.ballSpeedMultiplier;
            }

            update() {
                if (this.gameOver) {
                    return { aReward: 0, pReward: 0, playerCollision: false, aiCollision: false, isDone: true };
                }

                const MAX_BALL_DX = this.MAX_BALL_SPEED_BASE * this.ballSpeedMultiplier;
                const MAX_BALL_DY = this.MAX_BALL_SPEED_BASE * 1.25 * this.ballSpeedMultiplier;

                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                // Ceiling and floor collision
                if (this.ball.y <= this.ball.radius || this.ball.y >= this.height - this.ball.radius) {
                    this.ball.dy *= -1;
                    this.ball.y = clamp(this.ball.y, this.ball.radius, this.height - this.ball.radius);
                }

                let aReward = -0.01; // Default "living" penalty
                let pReward = -0.01;
                this.playerCollision = false;
                this.aiCollision = false;
                let isDone = false;

                // Wall collision (scoring)
                if (this.ball.x <= 0) {
                    this.score.ai++;
                    aReward = 1; // AI scores, positive reward
                    pReward = -1; // Player fails, negative reward
                    this.resetBall();
                } else if (this.ball.x >= this.width) {
                    this.score.player++;
                    aReward = -1; // AI fails, negative reward
                    pReward = 1; // Player scores, positive reward
                    this.resetBall();
                }

                // Update paddle positions, clamped within bounds
                this.ai.y = clamp(this.ai.y + this.ai.dy, 0, this.height - this.ai.height);
                this.player.y = clamp(this.player.y + this.player.dy, 0, this.height - this.player.height);

                // Paddle collision (Player)
                if (this.ball.dx < 0 &&
                    this.ball.x - this.ball.radius <= this.player.x + this.player.width &&
                    this.ball.x + this.ball.radius >= this.player.x &&
                    this.ball.y >= this.player.y &&
                    this.ball.y <= this.player.y + this.player.height) {
                    this.ball.dx = clamp(Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX); // Increase speed, reverse direction
                    this.ball.dy = clamp(this.ball.dy + (this.player.dy * 0.5), -MAX_BALL_DY, MAX_BALL_DY); // Paddle velocity influences ball
                    this.ball.x = this.player.x + this.player.width + this.ball.radius + 1; // Prevent sticking
                    this.playerCollision = true;
                    pReward += 0.5; // Stronger reward for hitting the ball
                    this.playSound('collision');
                }

                // Paddle collision (AI)
                if (this.ball.dx > 0 &&
                    this.ball.x + this.ball.radius >= this.ai.x &&
                    this.ball.x - this.ball.radius <= this.ai.x + this.ai.width &&
                    this.ball.y >= this.ai.y &&
                    this.ball.y <= this.ai.y + this.ai.height) {
                    this.ball.dx = clamp(-Math.abs(this.ball.dx) * 1.1, -MAX_BALL_DX, MAX_BALL_DX);
                    this.ball.dy = clamp(this.ball.dy + (this.ai.dy * 0.5), -MAX_BALL_DY, MAX_BALL_DY);
                    this.ball.x = this.ai.x - this.ball.radius - 1; // Prevent sticking
                    this.aiCollision = true;
                    aReward += 0.5; // Stronger reward for hitting the ball
                    this.playSound('collision');
                }

                // Check for game over
                if (this.score.ai >= this.scoreToWin) {
                    this.gameOver = true;
                    this.winner = 'AI';
                    isDone = true;
                    aReward = 5; // Big bonus for winning
                    pReward = -5;
                    this.playSound('win');
                } else if (this.score.player >= this.scoreToWin) {
                    this.gameOver = true;
                    this.winner = 'Player';
                    isDone = true;
                    pReward = 5;
                    aReward = -5;
                    this.playSound('win');
                }

                return { aReward, pReward, playerCollision: this.playerCollision, aiCollision: this.aiCollision, isDone };
            }

            setAIAction(action) {
                const speed = this.MAX_PADDLE_SPEED_BASE * this.ballSpeedMultiplier;
                if (action[0] === 1) this.ai.dy = -speed;
                else if (action[1] === 1) this.ai.dy = speed;
                else this.ai.dy = 0;
            }

            setPlayerAction(action) {
                const speed = PongGame.PLAYER_PADDLE_SPEED;
                if (action[0] === 1) this.player.dy = -speed;
                else if (action[1] === 1) this.player.dy = speed;
                else this.player.dy = 0;
            }

            getState() {
                // Return a comprehensive state vector for AI learning
                return {
                    player: { y: this.player.y, dy: this.player.dy, width: this.player.width, height: this.player.height },
                    ai: { y: this.ai.y, dy: this.ai.dy, width: this.ai.width, height: this.ai.height },
                    ball: { x: this.ball.x, y: this.ball.y, dx: this.ball.dx, dy: this.ball.dy },
                    score: { player: this.score.player, ai: this.score.ai },
                    playerCollision: this.playerCollision,
                    aiCollision: this.aiCollision
                };
            }

            render(ctx) {
                if (!ctx) return;

                ctx.clearRect(0, 0, this.width, this.height);

                ctx.fillStyle = this.playerCollision ? 'var(--error-red)' : '#fff';
                ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                ctx.fillStyle = this.aiCollision ? 'var(--error-red)' : '#fff';
                ctx.fillRect(this.ai.x, this.ai.y, this.ai.width, this.ai.height);

                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                ctx.font = '24px "Courier Prime"';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'var(--primary-blue)';
                ctx.fillText(this.score.player, this.width / 4, 30);
                ctx.fillText(this.score.ai, this.width * 3 / 4, 30);

                if (this.gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, this.width, this.height);
                    ctx.fillStyle = 'var(--primary-blue)';
                    ctx.font = '48px "Courier Prime"';
                    ctx.fillText(`${this.winner} Wins!`, this.width / 2, this.height / 2);
                    ctx.font = '24px "Courier Prime"';
                    ctx.fillText('Press R to Reset', this.width / 2, this.height / 2 + 40);
                }
            }

            // Moved playSound and _playActualSound methods here
            playSound(type = 'collision') {
                try {
                    if (this.audioContext.state !== 'running') {
                        logger.warn('AudioContext is not running. Sound will not play until resumed by user interaction.');
                        return;
                    }
                    this._playActualSound(type);
                } catch (e) {
                    logger.warn('Audio playback failed or context error', e.message);
                }
            }

            _playActualSound(type) {
                if (this.audioContext.state !== 'running') return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                if (type === 'collision') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440 + Math.random() * 100, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                } else if (type === 'win') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(587.33, this.audioContext.currentTime); // D5
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                }
            }
        }

        class NeuralNetworkVisualizer {
            constructor(containerId, worldModel, theme = 'main') {
                this.container = document.getElementById(containerId);
                this.worldModel = worldModel;
                this.theme = theme;

                if (!this.container || !this.worldModel) {
                    logger.error(`NNVisualizer: Container '${containerId}' or worldModel not found.`);
                    return;
                }

                this.neuronElements = [];
                this.visualLayers = [];
                this.MAX_NEURONS_TO_DISPLAY = 12; // Reduced for clarity in smaller panels

                this._setupVisualLayers();
                this._setupDOM();
            }

            _setupVisualLayers() {
                const model = this.worldModel;
                this.visualLayers.push({ name: 'input', actualCount: model.inputDim });
                // NEW: The hidden layers are now the recurrent cell states
                this.visualLayers.push({ name: 'cellState', actualCount: model.cellState.length });
                this.visualLayers.push({ name: 'hiddenState', actualCount: model.hiddenState.length });
                this.visualLayers.push({ name: 'qValues', actualCount: model.actionDim }); // Output is now Q-values
            }

            _setupDOM() {
                this.container.innerHTML = '';

                this.canvas = document.createElement('canvas');
                this.canvas.className = 'nn-connections-canvas';
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);

                this.visualLayers.forEach((layer, lIndex) => {
                    const lDiv = document.createElement('div');
                    lDiv.className = 'nn-layer';
                    this.neuronElements[lIndex] = [];

                    const neuronsToDisplay = Math.min(layer.actualCount, this.MAX_NEURONS_TO_DISPLAY);
                    for (let i = 0; i < neuronsToDisplay; i++) {
                        const nDiv = document.createElement('div');
                        nDiv.className = 'nn-neuron';
                        lDiv.appendChild(nDiv);
                        this.neuronElements[lIndex].push(nDiv);
                    }
                    this.container.appendChild(lDiv);
                });

                const ro = new ResizeObserver(() => {
                    const dpr = window.devicePixelRatio || 1;
                    this.canvas.width = this.container.clientWidth * dpr;
                    this.canvas.height = this.container.clientHeight * dpr;
                    this.ctx.scale(dpr, dpr);
                    // Connections are too complex to meaningfully draw for LSTM, so we skip it.
                });
                ro.observe(this.container);
            }
            
            _getNeuronPosition(lIndex, nIndex) {
                const el = this.neuronElements[lIndex]?.[nIndex];
                if (!el) {
                    const layerDiv = this.container.children[lIndex + 1]; // +1 because canvas is first child
                    if (!layerDiv) return { x: 0, y: 0 };
                    const layerRect = layerDiv.getBoundingClientRect();
                    const containerRect = this.container.getBoundingClientRect();
                    return {
                        x: (layerRect.left - containerRect.left) + layerRect.width / 2,
                        y: (layerRect.top - containerRect.top) + layerRect.height / 2
                    };
                }

                const r = el.getBoundingClientRect();
                const cr = this.container.getBoundingClientRect();

                return {
                    x: r.left - cr.left + r.width / 2,
                    y: r.top - cr.top + r.height / 2
                };
            }

            _drawConnections() {
                // Connections are too complex to visualize for a recurrent net, so we disable this.
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }


            update(activations) {
                // If activations are not provided or invalid, visualize a neutral state
                if (!activations || activations.length === 0 || !activations.every(isFiniteVector)) {
                    this.visualLayers.forEach((layerViz, l_idx) => {
                        (this.neuronElements[l_idx] || []).forEach(el => {
                            if (el) {
                                el.style.backgroundColor = '#333';
                                el.style.borderColor = '#888';
                                el.style.boxShadow = 'none';
                            }
                        });
                    });
                    this._drawConnections();
                    return;
                }

                const hues = this.theme === 'opponent' ? { pos: 39, neg: 271 } : { pos: 195, neg: 0 }; // Yellow/Purple for opponent, Cyan/Red for main

                this.visualLayers.forEach((layerViz, l_idx) => {
                    const layerActivations = activations[l_idx];
                    if (!layerActivations || !isFiniteVector(layerActivations)) {
                        logger.warn(`NNVisualizer: Layer ${l_idx} activations are invalid.`);
                        return;
                    }

                    let maxAbs = 0;
                    for (const v of layerActivations) {
                        if (Number.isFinite(v) && Math.abs(v) > maxAbs) maxAbs = Math.abs(v);
                    }
                    const norm = maxAbs + 1e-9; // Add small epsilon to avoid division by zero

                    for (let n_idx = 0; n_idx < this.neuronElements[l_idx].length; n_idx++) {
                        const data_idx = Math.floor(n_idx * (layerActivations.length / this.neuronElements[l_idx].length));
                        const val = layerActivations[data_idx] || 0;
                        const intensity = clamp(Math.abs(val / norm), 0, 1);

                        const hue = val >= 0 ? hues.pos : hues.neg;
                        const lightness = clamp((0.1 + 0.9 * intensity) * 60, 10, 90); // Brighter range
                        const el = this.neuronElements[l_idx][n_idx];
                        if (el) {
                            el.style.backgroundColor = `hsl(${hue},100%,${lightness}%)`;
                            el.style.borderColor = `hsl(${hue},100%,${lightness * 1.2}%)`;
                            el.style.boxShadow = `0 0 ${clamp(intensity * 8, 0, 8)}px hsl(${hue},100%,${lightness}%)`;
                        }
                    }
                });
                this._drawConnections();
            }
        }

        class MainApp {
    constructor() {
        logger.info('MainApp Constructor started.');
        this.gameCanvas = document.getElementById('gameCanvas');
        this.sheafGraphCanvas = document.getElementById('sheafGraphCanvas');

        if (!this.gameCanvas || !this.sheafGraphCanvas) {
            document.getElementById('status').textContent = 'Error: Canvas not found. Check HTML IDs.';
            logger.error('Canvas not found');
            throw new Error('Canvas not found');
        }

        this.ctx = this.gameCanvas.getContext('2d');
        this.sheafGraphCtx = this.sheafGraphCanvas.getContext('2d');

        if (!this.ctx || !this.sheafGraphCtx) {
            document.getElementById('status').textContent = 'Error: Failed to get 2D rendering context for canvas.';
            logger.error('Failed to get 2D context');
            throw new Error('Failed to get 2D context');
        }

        // NEW: Performance Chart data stores
        this.chartData = {
            qValue: [],
            predError: [],
            epsilon: [],
            score: []
        };
        this.MAX_CHART_POINTS = 100;

        // Setup resize observers for canvases
        this.applyCanvasDPR(this.sheafGraphCanvas, this.sheafGraphCtx);
        const gameCanvasRO = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                this.applyCanvasDPR(this.gameCanvas, this.ctx, width, height);
                if (this.pongGame) {
                    this.pongGame.width = width;
                    this.pongGame.height = height;
                    this.pongGame.render(this.ctx); // Re-render immediately on resize
                    const newGameBounds = { width, height, scoreToWin: this.pongGame.scoreToWin };
                    if (this.mainAI) { this.mainAI.gameWidth = newGameBounds.width; this.mainAI.gameHeight = newGameBounds.height; }
                    if (this.opponentAI) { this.opponentAI.gameWidth = newGameBounds.width; this.opponentAI.gameHeight = newGameBounds.height; }
                }
            }
        });
        gameCanvasRO.observe(this.gameCanvas);

        this.isRunning = false;
        this.frameCount = 0;
        this.pongGame = null; // Will be initialized in setupGameAndAIs

        this.boundGameLoop = this.gameLoop.bind(this); // Pre-bind for requestAnimationFrame
        this.setupTooltips();
        this.bindEvents();
        this.setupQualiaAttentionPanel(); // Initialize the new panel
        document.getElementById('status').textContent = 'Ready';

        this.setupGameAndAIs(); // Call asynchronously below
        // logger.info('MainApp Constructor completed. Calling setupGameAndAIs.'); // Removed verbose log
    }

    applyCanvasDPR(canvas, ctx, baseWidth = canvas.clientWidth, baseHeight = canvas.clientHeight) {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = baseWidth * dpr;
        canvas.height = baseHeight * dpr;
        canvas.style.width = `${baseWidth}px`;
        canvas.style.height = `${baseHeight}px`;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Apply DPR scaling to context
    }

    async setupGameAndAIs() {
        logger.info('setupGameAndAIs() started.');
        showLoading('game', 'Initializing Pong Environment...');
        showLoading('mainBrain', 'Building Main AI World Model...');
        showLoading('opponentBrain', 'Building Opponent AI World Model...');
        showLoading('metrics', 'Initializing OFTCC Sheaf...');

        try {
            const { clientWidth: w, clientHeight: h } = this.gameCanvas;
            this.pongGame = new PongGame(this.gameCanvas, w, h);
            logger.info('PongGame initialized.');
            
            const gameBounds = { width: w, height: h, scoreToWin: 10 };

            this.mainAI_worldModel = new OntologicalWorldModel(10, 3, 7, [64, 64], true);
            this.opponent_worldModel = new OntologicalWorldModel(10, 3, 7, [64, 64], false);
            // logger.info('OntologicalWorldModels instantiated.'); // Removed verbose log

            logger.info('Calling Promise.all for OWM initialization...');
            await Promise.all([
                this.mainAI_worldModel.initialize(),
                this.opponent_worldModel.initialize()
            ]);
            logger.info('OWM initialization completed.');

            this.mainAI = new LearningAI(this.mainAI_worldModel, gameBounds, true);
            this.opponentAI = new LearningAI(this.opponent_worldModel, gameBounds, false);
            // logger.info('LearningAIs instantiated.'); // Removed verbose log
            
            this.mainStrategicAI = new StrategicAI(this.mainAI);
            this.opponentStrategicAI = new StrategicAI(this.opponentAI);
            // logger.info('StrategicAIs instantiated.'); // Removed verbose log

            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');
            // logger.info('NeuralNetworkVisualizers instantiated.'); // Removed verbose log

            this.pongGame.render(this.ctx); 
            this.updateVisualization();
            this.start(); // Start simulation automatically after setup
            logger.info('Game and AIs initialized successfully. Starting simulation.');

        } catch (e) {
            logger.error('Failed to set up game and AIs:', e);
            document.getElementById('status').textContent = `Initialization Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
            // logger.info('setupGameAndAIs() completed.'); // Removed verbose log
        }
    }

    bindEvents() {
        document.getElementById('toggleSimButton').onclick = () => this.toggleGame();
        document.getElementById('resetSimButton').onclick = () => this.resetAI();
        document.getElementById('tuneButton').onclick = () => this.tuneParameters();
        document.getElementById('pauseButton').onclick = () => this.stop();
        document.getElementById('stepButton').onclick = () => this.gameLoop(null, true);

        window.addEventListener('keydown', (e) => this.handleKeyDown(e));
        window.addEventListener('keyup', (e) => this.handleKeyUp(e));

        ['alphaSlider', 'betaSlider', 'gammaSlider'].forEach(id => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id.replace('Slider', '')}-param`);
            slider.addEventListener('input', () => {
                const paramName = id.replace('Slider', '');
                const value = parseFloat(slider.value);
                if (this.mainAI_worldModel?.qualiaSheaf) this.mainAI_worldModel.qualiaSheaf[paramName] = value;
                if (this.opponent_worldModel?.qualiaSheaf) this.opponent_worldModel.qualiaSheaf[paramName] = value;
                valueDisplay.textContent = value.toFixed(3);
                slider.setAttribute('aria-valuetext', value.toFixed(3));
            });
        });

        ['ballSpeedSlider', 'paddleHeightSlider', 'aiResponseTimeSlider'].forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('change', () => {
                const value = parseFloat(input.value);
                if (this.pongGame) {
                    if (id === 'ballSpeedSlider') this.pongGame.ballSpeedMultiplier = value;
                    if (id === 'paddleHeightSlider') {
                        this.pongGame.paddleHeightMultiplier = value;
                        // Recalculate paddle height for consistency
                        this.pongGame.player.height = PongGame.PADDLE_HEIGHT_BASE * value;
                        this.pongGame.ai.height = PongGame.PADDLE_HEIGHT_BASE * value;
                    }
                    if (id === 'aiResponseTimeSlider') {
                        if (this.mainAI) this.mainAI.aiResponseTime = value;
                        if (this.opponentAI) this.opponentAI.aiResponseTime = value;
                    }
                }
            });
        });
    }

    setupTooltips() {
        tippy('#phi-display', { content: 'Φ (Phi) measures integrated information, indicating the system\'s level of consciousness or experience.' });
        tippy('#free-energy', { content: 'Free Energy (F) quantifies the system’s predictive divergence from its world model; the AI strives to minimize this.' });
        tippy('#prediction-error', { content: 'Prediction Error measures the discrepancy between the AI\'s predicted next state and the actual observed next state.' });
        tippy('#gestalt-unity', { content: 'Gestalt Unity quantifies the holistic coherence and interconnectedness across the sheaf structure, indicating how well its internal model is integrated.' });
        tippy('#h1-dimension', { content: 'dim H¹ represents the first cohomology dimension, indicating structural complexity and the presence of "holes" or non-trivial loops in the information flow within the sheaf.' });
        tippy('#inconsistency', { content: 'Gluing Inconsistency measures the misalignment in qualia projections between connected vertices (concepts) in the sheaf, indicating internal contradictions.' });
        tippy('#qualia-being-fill', { content: 'Being: Reflects the system’s fundamental existence and persistent state, representing its self-awareness.' });
        tippy('#qualia-intent-fill', { content: 'Intent: Captures directed action potential and goal-oriented focus, signifying its purpose and goals.' });
        tippy('#qualia-existence-fill', { content: 'Existence: Models state persistence and resilience to change, representing its current state and environmental robustness.' });
        tippy('#qualia-emergence-fill', { content: 'Emergence: Represents non-linear state synthesis and novel property formation, indicating its capacity for novelty.' });
        tippy('#qualia-gestalt-fill', { content: 'Gestalt: Quantifies holistic coherence and pattern recognition, indicating its ability to form meaningful wholes from parts.' });
        tippy('#context-fill', { content: 'Context: Incorporates environmental modulation and background information, reflecting its understanding of the surrounding world.' });
        tippy('#qualia-rel-emergence-fill', { content: 'Relational Emergence: Captures dynamic entity coupling and interaction effects, indicating its comprehension of relationships.' });
        tippy('#alphaSlider', { content: 'α (Alpha) controls the influence of external sensory input on qualia diffusion; higher values mean more responsiveness to environment.' });
        tippy('#betaSlider', { content: 'β (Beta) adjusts the overall diffusion strength and speed across the sheaf; higher values lead to faster qualia propagation and integration.' });
        tippy('#gammaSlider', { content: 'γ (Gamma) sets the inertia for qualia updates and acts as an effective learning rate for diffusion; higher values imply quicker adaptation.' });
        tippy('#toggleSimButton', { content: 'Toggles the simulation run/pause state. (Spacebar)' });
        tippy('#resetSimButton', { content: 'Resets the game, AI states, and world models to their initial configurations. (R key)' });
        tippy('#tuneButton', { content: 'Adaptively adjusts AI parameters (α, β, γ) based on real-time system stability and consciousness metrics, aiming for optimal performance. (T key)' });
        tippy('#pauseButton', { content: 'Pauses the simulation if it is currently running. (P key or Spacebar)' });
        tippy('#stepButton', { content: 'Advances the simulation by a single frame/step. (S key)' });
        tippy('#vertex-0', { content: 'P-Y: Player (Left) paddle Y position. The vertical position of the human-controlled or opponent AI paddle.' });
        tippy('#vertex-1', { content: 'B-X: Ball X position. The horizontal position of the Pong ball in the game environment.' });
        tippy('#vertex-2', { content: 'B-Y: Ball Y position. The vertical position of the Pong ball in the game environment.' });
        tippy('#vertex-3', { content: 'B-DX: Ball X velocity. The horizontal speed and direction of the ball.' });
        tippy('#vertex-4', { content: 'B-DY: Ball Y velocity. The vertical speed and direction of the ball.' });
        tippy('#vertex-5', 'P-SC: Player (Left) score. The current score of the player\'s paddle.');
        tippy('#vertex-6', 'AI-SC: AI (Right) score. The current score of the main AI paddle.');
        tippy('#vertex-7', 'P-DY: Player (Left) paddle Y velocity. The vertical speed and direction of the human-controlled or opponent AI paddle.');
        tippy('#vertex-8', 'P-Col: Player (Left) collision state. Indicates if the ball has just collided with the player\'s paddle.');
        tippy('#vertex-9', 'AI-Col: AI (Right) collision state. Indicates if the ball has just collided with the main AI\'s paddle.');
    }
    
    setupQualiaAttentionPanel() {
        const panel = document.getElementById('qualiaAttentionPanel');
        if (!panel) return;
        
        const qualiaNames = ['Being', 'Intent', 'Existence', 'Emergence', 'Gestalt', 'Context', 'Rel. Emergence'];
        let html = `<h4 id="qualia-attention-heading">Qualia Attention (Main AI)</h4>`;
        qualiaNames.forEach((name, i) => {
            html += `
                <div class="attention-bar-container">
                    <span class="attention-label">${name}</span>
                    <div class="attention-bar-wrapper">
                        <div class="attention-bar" id="attention-bar-${i}"></div>
                    </div>
                </div>
            `;
        });
        panel.innerHTML = html;
    }

    updateQualiaAttentionVisuals() {
        const softmaxScores = this.mainAI_worldModel?.lastSoftmaxScores;
        if (!softmaxScores || !isFiniteVector(softmaxScores)) return; // Ensure scores are valid

        for (let i = 0; i < softmaxScores.length; i++) {
            const bar = document.getElementById(`attention-bar-${i}`);
            if (bar) {
                const normalizedWidth = (softmaxScores[i] || 0) * 100;
                bar.style.width = `${clamp(normalizedWidth, 0, 100)}%`;
            }
        }
    }

    drawSheafGraph() {
        if (!this.sheafGraphCtx) return;
        const dpr = window.devicePixelRatio || 1;
        const { clientWidth: w, clientHeight: h } = this.sheafGraphCanvas;
        this.sheafGraphCtx.clearRect(0, 0, w / dpr, h / dpr); // Clear using logical pixels

        const sheaf = this.mainAI_worldModel?.qualiaSheaf;
        if (!sheaf || !sheaf.graph || !sheaf.graph.vertices || !sheaf.graph.edges || !sheaf.adjacencyMatrix) {
            logger.warn("Sheaf graph data not available or incomplete for drawing.");
            return;
        }

        const adj = sheaf.adjacencyMatrix;

        sheaf.graph.edges.forEach(([u, v]) => {
            const uIdx = sheaf.graph.vertices.indexOf(u);
            const vIdx = sheaf.graph.vertices.indexOf(v);
            if (!sheafVertexPositions[uIdx] || !sheafVertexPositions[vIdx] || uIdx === -1 || vIdx === -1) return;

            const weight = adj[uIdx]?.[vIdx] || 0.1; // Fallback to 0.1
            this.sheafGraphCtx.strokeStyle = `rgba(68, 170, 255, ${clamp(weight, 0.1, 1.0)})`;
            this.sheafGraphCtx.lineWidth = clamp(weight * 2, 0.5, 3.0);
            
            const p1 = sheafVertexPositions[uIdx], p2 = sheafVertexPositions[vIdx];
            this.sheafGraphCtx.beginPath();
            // Scale positions, accounting for vertex size to keep lines centered on vertices
            const scaledX1 = p1.x * (w / dpr - 36) + 18;
            const scaledY1 = p1.y * (h / dpr - 36) + 18;
            const scaledX2 = p2.x * (w / dpr - 36) + 18;
            const scaledY2 = p2.y * (h / dpr - 36) + 18;

            this.sheafGraphCtx.moveTo(scaledX1, scaledY1);
            this.sheafGraphCtx.lineTo(scaledX2, scaledY2);
            this.sheafGraphCtx.stroke();
        });
    }

    drawChart(svgId, data, color, yMin, yMax) {
        const svg = document.getElementById(svgId);
        if (!svg) return;
        svg.innerHTML = ''; // Clear previous chart

        const width = svg.clientWidth;
        const height = svg.clientHeight;
        const padding = 10;

        if (data.length < 2) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d = `M ${padding},${height - padding} `;
        
        for (let i = 0; i < data.length; i++) {
            const x = padding + i * (width - 2 * padding) / (data.length - 1);
            // Ensure y_val is finite and clamped before scaling
            const y_val = Number.isFinite(data[i]) ? clamp(data[i], yMin, yMax) : (yMin + yMax) / 2; 
            const y = (height - 2 * padding) * (1 - (y_val - yMin) / (yMax - yMin)) + padding;
            d += `L ${x.toFixed(2)},${y.toFixed(2)} `;
        }

        path.setAttribute('d', d);
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
    }

    updatePerformanceCharts() {
        if(this.mainAI && this.pongGame) {
            this.chartData.qValue.push(this.mainAI.avgQValue);
            this.chartData.epsilon.push(this.mainAI.epsilon);
            this.chartData.predError.push(this.mainAI_worldModel.predictionError);
            this.chartData.score.push(this.pongGame.score.ai - this.pongGame.score.player);
        }

        for(const key in this.chartData) {
            if (this.chartData[key].length > this.MAX_CHART_POINTS) {
                this.chartData[key].shift();
            }
        }
        
        this.drawChart('qValueChart', this.chartData.qValue, 'var(--primary-blue)', -2, 2);
        this.drawChart('predErrorChart', this.chartData.predError, 'var(--warn-orange)', 0, 5);
        this.drawChart('epsilonChart', this.chartData.epsilon, 'var(--info-green)', 0, 1);
        this.drawChart('scoreChart', this.chartData.score, 'var(--error-red)', -10, 10);
    }


    updateVisualization() {
        const qualia = this.mainAI_worldModel?.qualiaSheaf;
        const model = this.mainAI_worldModel;

        if (!qualia || !model) {
            logger.warn('Main AI World Model or Qualia Sheaf not initialized for visualization.');
            return;
        }

        const avgQualia = new Float32Array(qualia.qDim).fill(0);
        let count = 0;
        qualia.stalks.forEach((stalk) => {
            if (isFiniteVector(stalk)) {
                stalk.forEach((v, i) => {
                    if (Number.isFinite(v)) avgQualia[i] += v;
                });
                count++;
            }
        });
        if (count > 0) avgQualia.forEach((_, i) => avgQualia[i] /= count);

        // Normalize qualia for bar display (0 to 1) and ensure finiteness
        const qualiaValues = avgQualia.map(v => Number.isFinite(v) ? clamp(v, 0, 1) : 0);

        requestAnimationFrame(() => {
            document.getElementById('being-value').textContent = qualiaValues[0].toFixed(3);
            document.getElementById('qualia-being-fill').style.width = `${qualiaValues[0] * 100}%`;
            document.getElementById('intent-value').textContent = qualiaValues[1].toFixed(3);
            document.getElementById('qualia-intent-fill').style.width = `${qualiaValues[1] * 100}%`;
            document.getElementById('existence-value').textContent = qualiaValues[2].toFixed(3);
            document.getElementById('qualia-existence-fill').style.width = `${qualiaValues[2] * 100}%`;
            document.getElementById('emergence-value').textContent = qualiaValues[3].toFixed(3);
            document.getElementById('qualia-emergence-fill').style.width = `${qualiaValues[3] * 100}%`;
            document.getElementById('gestalt-value').textContent = qualiaValues[4].toFixed(3);
            document.getElementById('qualia-gestalt-fill').style.width = `${qualiaValues[4] * 100}%`;
            document.getElementById('context-value').textContent = qualiaValues[5].toFixed(3);
            document.getElementById('qualia-context-fill').style.width = `${qualiaValues[5] * 100}%`;
            document.getElementById('rel-emergence-value').textContent = qualiaValues[6].toFixed(3);
            document.getElementById('qualia-rel-emergence-fill').style.width = `${qualiaValues[6] * 100}%`;

            document.getElementById('phi-display').textContent = `Φ: ${clamp(qualia.phi, 0, 5).toFixed(5)}`;
            document.getElementById('free-energy').textContent = (model.freeEnergy || 0).toFixed(5);
            document.getElementById('prediction-error').textContent = (model.predictionError || 0).toFixed(5);
            document.getElementById('h1-dimension').textContent = clamp(qualia.h1Dimension, 0, 3).toFixed(2);
            document.getElementById('gestalt-unity').textContent = clamp(qualia.gestaltUnity, 0, 1).toFixed(5);
            document.getElementById('inconsistency').textContent = (qualia.inconsistency || 0).toFixed(5);

            document.getElementById('stability-fill').style.width = `${clamp(qualia.stability, 0, 1) * 100}%`;

            document.getElementById('alpha-param').textContent = qualia.alpha.toFixed(3);
            document.getElementById('alphaSlider').value = qualia.alpha;
            document.getElementById('alphaSlider').setAttribute('aria-valuetext', qualia.alpha.toFixed(3));

            document.getElementById('beta-param').textContent = qualia.beta.toFixed(3);
            document.getElementById('betaSlider').value = qualia.beta;
            document.getElementById('betaSlider').setAttribute('aria-valuetext', qualia.beta.toFixed(3));

            document.getElementById('gamma-param').textContent = qualia.gamma.toFixed(3);
            document.getElementById('gammaSlider').value = qualia.gamma;
            document.getElementById('gammaSlider').setAttribute('aria-valuetext', qualia.gamma.toFixed(3));

            qualia.visualizeActivity();
            this.drawSheafGraph();
            this.updateQualiaAttentionVisuals();
        });
    }

    async gameLoop(timestamp, isManualStep = false) {
        if (!this.isRunning && !isManualStep) {
            return;
        }
        
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready || !this.pongGame) {
            document.getElementById('status').textContent = 'Waiting for AI/Game initialization...';
            if (!isManualStep) requestAnimationFrame(this.boundGameLoop);
            return; 
        }

        try {
            this.frameCount++;

            const preGameState = this.pongGame.getState();
            
            // logger.info('gameLoop: Making AI decisions...'); // Removed verbose log
            const [mainDecision, opponentDecision] = await Promise.all([
                this.mainAI.makeDecision(preGameState),
                this.opponentAI.makeDecision(preGameState)
            ]);
            // logger.info('gameLoop: AI decisions made.'); // Removed verbose log

            // FIX: Check for corruption and reset AI if needed
            if (mainDecision.corrupted) {
                logger.warn('Main AI state corrupted. Resetting its recurrent state and learning parameters.');
                this.mainAI.worldModel.resetRecurrentState();
                this.mainAI.epsilon = 1.0; // Reset epsilon to encourage re-exploration
            }
            if (opponentDecision.corrupted) {
                logger.warn('Opponent AI state corrupted. Resetting its recurrent state and learning parameters.');
                this.opponentAI.worldModel.resetRecurrentState();
                this.opponentAI.epsilon = 1.0;
            }

            this.pongGame.setAIAction(mainDecision.action);
            this.pongGame.setPlayerAction(opponentDecision.action);
            
            // logger.info('gameLoop: Updating game state...'); // Removed verbose log
            const gameUpdateResult = this.pongGame.update();
            const postGameState = this.pongGame.getState();
            // logger.info('gameLoop: Game state updated.'); // Removed verbose log

            // logger.info('gameLoop: AIs learning...'); // Removed verbose log
            await Promise.all([
                this.mainAI.learn(gameUpdateResult.aReward, postGameState, gameUpdateResult.isDone),
                this.opponentAI.learn(gameUpdateResult.pReward, postGameState, gameUpdateResult.isDone)
            ]);
            // logger.info('gameLoop: AIs learning completed.'); // Removed verbose log
            
            this.mainStrategicAI.observe(gameUpdateResult.aReward);
            this.opponentStrategicAI.observe(gameUpdateResult.pReward);
            if(this.frameCount % 50 === 0) { // Modulate every 50 frames
                this.mainStrategicAI.modulateParameters();
                this.opponentStrategicAI.modulateParameters();
            }

            document.getElementById('player-score').textContent = this.pongGame.score.player;
            document.getElementById('ai-score').textContent = this.pongGame.score.ai;

            if (this.frameCount % 5 === 0 || isManualStep) { // Update visualizers every 5 frames
                this.mainViz.update(mainDecision.activations);
                this.opponentViz.update(opponentDecision.activations);
                this.updateVisualization();
            }
            if (this.frameCount % 20 === 0 || isManualStep) { // Update charts every 20 frames
                this.updatePerformanceCharts();
            }

            this.pongGame.render(this.ctx);

            if (this.pongGame.gameOver) {
                this.stop();
                logger.info(`${this.pongGame.winner} wins the game!`);
            }

        } catch (error) {
            // Enhanced error logging
            logger.error("Error in game loop, stopping simulation:", error.message || error.toString() || error);
            console.error("Critical error in gameLoop, stopping:", error); // Keep console.error for full stack trace
            this.stop(); 
        } finally {
            if (this.isRunning && !isManualStep && !this.pongGame.gameOver) {
                requestAnimationFrame(this.boundGameLoop);
            }
        }
    }
    toggleGame() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) {
            logger.warn('AIs are not fully initialized yet. Please wait.');
            document.getElementById('status').textContent = 'AIs Not Ready - Please Wait...';
            return;
        }
        this.isRunning = !this.isRunning;
        const btn = document.getElementById('toggleSimButton');
        btn.textContent = this.isRunning ? '⏸️ Pause Simulation' : '🚀 Toggle Simulation';
        document.getElementById('status').textContent = this.isRunning ? 'Conscious AI Active' : this.pongGame.gameOver ? `${this.pongGame.winner} Wins! (Paused)` : 'Paused';
        if (this.isRunning) {
            // Attempt to resume AudioContext on user interaction
            if (this.pongGame && this.pongGame.audioContext.state === 'suspended') { // Check pongGame and its audioContext
                this.pongGame.resumeAudioContext().then(() => {
                    // logger.info("AudioContext resumed on user interaction."); // Removed verbose log
                    this.gameLoop(null, false);
                }).catch(e => logger.error("Failed to resume AudioContext on toggle:", e));
            } else {
                this.gameLoop(null, false);
            }
            logger.info('Simulation started.');
        } else {
            logger.info('Simulation paused.');
        }
    }

    stop() {
        this.isRunning = false;
        document.getElementById('toggleSimButton').textContent = '🚀 Toggle Simulation';
        document.getElementById('status').textContent = this.pongGame?.gameOver ? `${this.pongGame.winner} Wins! (Paused)` : 'Paused';
        logger.info('Simulation stopped.');
    }

    start() {
        if (!this.ctx) {
            document.getElementById('status').textContent = 'Error: Canvas context missing. Cannot start game.';
            logger.error('Cannot start: Missing canvas context.');
            return;
        }
        if (this.pongGame?.gameOver) {
            this.resetAI();
        }
        if (!this.isRunning) {
            this.toggleGame();
        }
    }

    async resetAI() {
        this.stop();
        logger.info('Resetting all game and AI states...');
        showLoading('game', 'Resetting Game...');
        showLoading('mainBrain', 'Resetting Main AI...');
        showLoading('opponentBrain', 'Resetting Opponent AI...');
        showLoading('metrics', 'Resetting Metrics...');

        // Clear chart data
        for (const key in this.chartData) {
            this.chartData[key] = [];
        }

        try {
            // Get current client dimensions for accurate reset
            const { clientWidth: w, clientHeight: h } = this.gameCanvas;
            this.pongGame = new PongGame(this.gameCanvas, w, h); // Re-initialize PongGame with current dimensions
            document.getElementById('player-score').textContent = 0;
            document.getElementById('ai-score').textContent = 0;
            
            // Recreate OWMs and LearningAIs to ensure a clean state
            this.mainAI_worldModel = new OntologicalWorldModel(10, 3, 7, [64, 64], true);
            await this.mainAI_worldModel.initialize();
            this.mainAI = new LearningAI(this.mainAI_worldModel, { width: w, height: h, scoreToWin: 10 }, true);
            this.mainStrategicAI = new StrategicAI(this.mainAI);
            
            this.opponent_worldModel = new OntologicalWorldModel(10, 3, 7, [64, 64], false);
            await this.opponent_worldModel.initialize();
            this.opponentAI = new LearningAI(this.opponent_worldModel, { width: w, height: h, scoreToWin: 10 }, false);
            this.opponentStrategicAI = new StrategicAI(this.opponentAI);
            
            // Reinitialize visualizers with new world models
            this.mainViz = new NeuralNetworkVisualizer('nn-visualization-container', this.mainAI_worldModel, 'main');
            this.opponentViz = new NeuralNetworkVisualizer('nn-visualization-container-opponent', this.opponent_worldModel, 'opponent');

            this.frameCount = 0;
            document.getElementById('status').textContent = 'Ready';
            this.updateVisualization();
            this.pongGame.render(this.ctx);
            logger.info('All states reset successfully.');
            this.start(); // Automatically start after reset

        } catch (e) {
            logger.error('Error during reset:', e);
            document.getElementById('status').textContent = `Reset Failed: ${e.message}`;
        } finally {
            hideLoading('game');
            hideLoading('mainBrain');
            hideLoading('opponentBrain');
            hideLoading('metrics');
        }
    }

    tuneParameters() {
        if (!this.mainAI_worldModel?.ready || !this.opponent_worldModel?.ready) {
            logger.warn('AIs are not fully initialized yet. Cannot tune parameters.');
            return;
        }
        this.mainAI_worldModel.qualiaSheaf.tuneParameters();
        this.opponent_worldModel.qualiaSheaf.tuneParameters();

        // Add flash animation to parameter displays
        const paramIds = ['alpha-param', 'beta-param', 'gamma-param'];
        paramIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('param-flash-active'); // Reset animation
                void el.offsetWidth; // Trigger reflow
                el.classList.add('param-flash-active');
            }
        });

        this.updateVisualization();
    }

    handleKeyDown(e) {
        switch (e.key) {
            case ' ': e.preventDefault(); this.toggleGame(); break;
            case 'r': case 'R': e.preventDefault(); this.resetAI(); break;
            case 't': case 'T': e.preventDefault(); this.tuneParameters(); break;
            case 'ArrowUp': e.preventDefault(); this.pongGame?.setPlayerAction([1, 0, 0]); break;
            case 'ArrowDown': e.preventDefault(); this.pongGame?.setPlayerAction([0, 1, 0]); break;
            case 'p': case 'P': e.preventDefault(); this.stop(); break;
            case 's': case 'S': e.preventDefault(); if (!this.isRunning) this.gameLoop(null, true); break; // Only step if paused
        }
    }

    handleKeyUp(e) {
        switch (e.key) {
            case 'ArrowUp':
            case 'ArrowDown': this.pongGame?.setPlayerAction([0, 0, 1]); break; // Player idle when key released
        }
    }
}
// --- App Initialization ---
        window.onload = async () => {
            function positionVertices() {
                const graph = document.getElementById('sheafGraph');
                if (!graph) return;
                const rect = graph.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const innerWidth = rect.width / dpr;
                const innerHeight = rect.height / dpr;

                for (let i = 0; i < 10; i++) {
                    const v = document.getElementById('vertex-' + i);
                    if (!v) continue;
                    const p = sheafVertexPositions[i] || { x: 0.5, y: 0.5 };
                    // Adjust position for vertex size (36px) and ensure it's within bounds
                    v.style.left = Math.round(p.x * (innerWidth - 36)) + 'px';
                    v.style.top = Math.round(p.y * (innerHeight - 36)) + 'px';
                }
            }

            window.addEventListener('resize', positionVertices);

            try {
                const app = new MainApp();
                positionVertices(); // Initial positioning
                logger.info('UI initialized — ready.');
                // App will start automatically after AIs are initialized in setupGameAndAIs
            } catch (e) {
                document.getElementById('status').textContent = `Initialization Error: ${e.message}`;
                logger.error('Initialization failed', e.message);
            }
        };
    </script>
</body>
</html>
```
